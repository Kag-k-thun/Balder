#version 450 core


layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 1) uniform sampler2D positions;
layout (binding = 2) uniform sampler2D normals;
layout (binding = 3) uniform sampler2D binormals;
layout (binding = 4) uniform sampler2D albedo;
layout (binding = 5) uniform sampler2D depth;
layout (binding = 6) uniform usampler2D materialID;


struct Material {
    vec3 baseColor;
    float roughness;
    float metallic;
    float clearcoat;
    float clearcoatRoughness;    
};

layout(std430, binding = 7) readonly buffer Materials {
    Material materials[];
};

layout (binding = 8) uniform Camera {
    mat4 proj;
    mat4 view;
    mat4 viewProj;
    vec3 eyePos;
} camera;


struct Light {    
    vec3 position;
    vec3 color;    
};

layout (std430, binding = 9) readonly buffer Directions {
    uint nbLights;
    Light lights[];
} directionLights;

layout (std430, binding = 10) readonly buffer Spots {
    uint nbLights;
    Light lights[];
} spotLights;

layout (std430, binding = 11) readonly buffer Points {
    uint nbLights;
    Light lights[];
} pointLights;


layout (set = 0, binding = 0, rgba32f) uniform image2D outTex;

layout(push_constant) uniform PC {
    float shadowTexLen;
} pc;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          METALLIC          ====================================
 * ====================================================================================================
 * ====================================================================================================
 */


vec3 shadeMetallic (vec3 N, vec3 V, vec3 L, vec3 albedo, float roughness) {
    // Termes de base
    float NdotL = max(dot(N, L), 0.0);
    float NdotV = max(dot(N, V), 0.0);

    // Fresnel de Schlick simplifié
    vec3 F0 = albedo; // pour un métal, F0 = couleur du métal
    float VoH = max(dot(V, normalize(V + L)), 0.0);
    vec3 F = F0 + (1.0 - F0) * pow(1.0 - VoH, 5.0);

    // Distribution GGX simplifiée
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, normalize(V + L)), 0.0);
    float denom = (NdotH * NdotH) * (a2 - 1.0) + 1.0;
    float D = a2 / (3.14159 * denom * denom);

    // Géométrie Smith simplifiée
    float k = (roughness + 1.0);
    k = (k * k) / 8.0;
    float Gv = NdotV / (NdotV * (1.0 - k) + k);
    float Gl = NdotL / (NdotL * (1.0 - k) + k);
    float G = Gv * Gl;

    // BRDF spéculaire
    vec3 spec = (D * F * G) / max(4.0 * NdotL * NdotV, 0.001);

    // Pas de diffuse pour un métal pur
    return spec * NdotL;
}


vec4 shadeMetallic (Light light, Material mat, vec2 uv) {    
    vec3 normals = texture (normals, uv).xyz;
    vec3 position = texture (positions, uv).xyz;
    
    vec3 view = normalize (camera.eyePos - position);
    vec3 baseColor = texture (albedo, uv).xyz;
        
    vec3 color = shadeMetallic (normals, view, light.position, baseColor, mat.roughness);
        
    return vec4 (color * mat.metallic * light.color, 1);
}


/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          DIFFUSE          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

vec3 directionalLight (vec3 baseColor, vec3 normal, vec3 lightDir, vec3 lightColor) {    
    vec3 N = normalize(normal);    
    vec3 L = normalize(-lightDir);    
    float NdotL = max(dot(N, L), 0.0);

    return baseColor * lightColor * NdotL;
}

vec4 shadeDiffuse (Light light, Material mat, vec2 uv) {        
    vec3 normals = texture (normals, uv).xyz;
    vec3 baseColor = texture (albedo, uv).xyz;
        
    vec3 diffuse = directionalLight (baseColor, normals, light.position, vec3 (1));
        
    return vec4 (diffuse * mat.roughness, 1);
}

void main () {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(outTex);

    if(texelCoord.x < size.x && texelCoord.y < size.y)
    {                
        vec4 color = vec4(0, 0, 0, 1.0);    
        vec2 uv = vec2 (float (texelCoord.x) / size.x, float (texelCoord.y) / size.y);
        
        uint matID = uint (texture (materialID, uv).x);
        Material mat = materials [matID];

        for (uint i = 0 ; i < directionLights.nbLights ; i++) {    
            vec4 diffuse = shadeDiffuse (directionLights.lights [i], mat, uv);
            vec4 metalic = shadeMetallic (directionLights.lights [i], mat, uv);
        
            color += (diffuse + metalic);
        }

        for (uint i = 0 ; i < spotLights.nbLights ; i++) {    
            vec4 diffuse = shadeDiffuse (spotLights.lights [i], mat, uv);
            vec4 metalic = shadeMetallic (spotLights.lights [i], mat, uv);
        
            color += (diffuse + metalic);
        }

        for (uint i = 0 ; i < pointLights.nbLights ; i++) {    
            vec4 diffuse = shadeDiffuse (pointLights.lights [i], mat, uv);
            vec4 metalic = shadeMetallic (pointLights.lights [i], mat, uv);
        
            color += (diffuse + metalic);
        }
        
        imageStore(outTex, texelCoord, color);
    }    
}
