in main;
use std::{io, fs::_, time::_, rand};

mod balder;

use balder::{math::_, node::_, core::_};
use balder::core::{shader::_,
                   application::_, driver::_};

use balder::node::mesh::indexed;
use balder::utils::_;

use vulkan::_;
use sdl2::_;

record ColorVertex {
    pub let mut v_pos : vec3;
    pub let mut v_color : vec3;
    pub let mut v_uv : vec2;
    pub self (pos : vec3, color : vec3, uv : vec2)
        with v_pos = pos, v_color = color, v_uv = uv
    {}
}

record CameraValues {
    pub let mut view = mat4 ();
    pub let mut proj = mat4 ();
    pub self () {}
}

class MyActivity over Activity {

    let dmut _mesh : (&Mesh)? = none;
    let dmut _shadowMesh : (&Mesh)? = none;

    let dmut _descSet : (&DescriptorSet)? = none;

    let dmut _cam : (&UniformBufferObject)? = none;
    let dmut _shadowCam : (&UniformBufferObject)? = none;
    let dmut _world : (&UniformBufferObject)? = none;
    let dmut _texture : (&Texture)? = none;

    let dmut _camera = CameraValues ();
    let dmut _shadowCamera = CameraValues ();
    let dmut _model = mat4 ();

    let dmut _composeShader : (&Shader)? = none;
    let dmut _shadowShader : (&Shader)? = none;

    let mut _allAngle = 0.f;

    // let dmut _texture : (&Texture)? = none;

    pub self (dmut app : &Application)
        with super (alias app)
    {
        app:.getInputManager ():.connectQuit (&self:.onQuit);
        app:.getInputManager ():.connect (KeyInfo (SDLK_r, KeyEvent::ALL), &self:.redraw);
        app:.getInputManager ():.connectResize (&self:.onResize);

        let dim = app:.getWindow ().getDimension ();
        self._camera.view = math::utils::lookAt (makeVec3 (0.f, 1.f, 1.f), makeVec3 (0.f, 0.f, 0.f), makeVec3 (0.f, 1.f, 0.f));
        self._camera.proj = math::utils::perspective (radian (90.f), cast!f32 (dim._0) / cast!f32 (dim._1), 0.1f, 10.0f);

        self._shadowCamera.view = self._camera.view;
        self._shadowCamera.proj = math::utils::perspective (radian (90.f), cast!f32 (800) / cast!f32 (800), 0.1f, 10.0f);

        {
            let dmut texture = copy Texture2D (alias app:.getWindow ():.getVulkanDevice (), "images:/texture.jpg");


            self:.window:.addSubpass (&self:.loadShadowPhase,
                                      &self:.drawShadowPhase,
                                      800, 800,
                                      onlyDepth-> true);

            let dmut shadowShader = copy SubpassShader (alias app:.getWindow ():.getVulkanDevice (),
                                                        "shaders:/white.toml",
                                                        self:.window:.getSubpass (0));

            let dmut composeShader = copy ComposeShader (alias app:.getWindow ():.getVulkanDevice (),
                                                         "shaders:/triangle.toml");

            self:.window:.setComposePass (&self:.loadPhase, &self:.drawPhase);

            let dmut cam = copy UniformBufferObject!{CameraValues} (alias app:.getWindow ():.getVulkanDevice ());
            let dmut shadowCam = copy UniformBufferObject!{CameraValues} (alias app:.getWindow ():.getVulkanDevice ());

            composeShader:.setUniform ("camera", alias cam);
            shadowShader:.setUniform ("camera", alias shadowCam);

            self._cam = (alias cam)?;
            self._shadowCam = (alias shadowCam)?;
            cam:.update (self._camera);
            shadowCam:.update (self._shadowCamera);

            let dmut world = copy UniformBufferObject!{mat4} (alias app:.getWindow ():.getVulkanDevice ());
            composeShader:.setUniform ("world", alias world);
            shadowShader:.setUniform ("world", alias world);

            self._world = (alias world)?;

            composeShader:.setTexture ("albedo", alias texture);
            self._texture = (alias texture)?;

            if let dmut p : &VulkanDepthSubpass = alias self:.window:.getSubpass (0) {
                composeShader:.setTexture ("depth", p:.getDepth ());
            } else {
                println ("??");
            }

            self._shadowShader = (alias shadowShader)?;
            self._composeShader = (alias composeShader)?;
        } catch {
            err => {
                log::error (err);
                panic;
            }
        };

        let positions = copy [makeVec3 (-0.5f, -0.5f, 0.f), makeVec3 (0.5f, -0.5f, 0.0f),
                              makeVec3 (0.5f, 0.5f, 0.f), makeVec3 (-0.5f, 0.5f, 0.0f),
                              makeVec3 (-0.5f, -0.5f, -0.5f), makeVec3 (0.5f, -0.5f, -0.5f),
                              makeVec3 (0.5f, 0.5f, -0.5f), makeVec3 (-0.5f, 0.5f, -0.5f)];

        let colors = copy [makeVec3 (1.f, 0.f, 0.f), makeVec3 (0.f, 1.f, 0.f),
                           makeVec3 (0.f, 0.f, 1.f), makeVec3 (1.f, 1.f, 1.f),
                           makeVec3 (1.f, 0.f, 0.f), makeVec3 (0.f, 1.f, 0.f),
                           makeVec3 (0.f, 0.f, 1.f), makeVec3 (1.f, 1.f, 1.f)];

        let textureUVs = copy [makeVec2 (1.f, 0.f), makeVec2 (0.f, 0.f),
                               makeVec2 (0.f, 1.f), makeVec2 (1.f, 1.f),
                               makeVec2 (1.f, 0.f), makeVec2 (0.f, 0.f),
                               makeVec2 (0.f, 1.f), makeVec2 (1.f, 1.f)];

        let indices : [u32] = copy [0, 1, 2, 2, 3, 0,
                                    4, 5, 6, 6, 7, 4];

        self._mesh = (copy IndexedMesh (alias app:.getWindow ():.getVulkanDevice (),
                                        indices,
                                        positions,
                                        colors-> colors,
                                        textureUVs-> textureUVs))?;

        self._shadowMesh = (copy IndexedMesh (alias app:.getWindow ():.getVulkanDevice (),
                                              indices,
                                              positions))?;

        self:.redraw (KeyInfo (SDLK_r, KeyEvent::DOWN));
    }

    pub fn redraw (mut self, _ : KeyInfo) {
        self:.window:.redraw ();
    }

    pub fn onResize (mut self, w : u32, h : u32) {
        println (w, " ", h);
        self._camera.proj = math::utils::perspective (radian (90.f), cast!f32 (w) / cast!f32 (h), 0.1f, 10.0f);
        if let Ok (dmut cam) = alias self._cam {
            cam:.update (self._camera);
        }
    }

    pub over onUpdate (mut self, delta : Duration) {
        self._allAngle += (cast!f32 (delta.allMillis) / 100.f);
        self._allAngle %= 360.f;

        self._model = utils::rotationZ (radian (self._allAngle));
        if let Ok (dmut ubo) = alias self._world {
            ubo:.update (self._model);
        }
    }

    pub fn loadPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut mesh) = alias self._mesh {
            mesh:.register (alias cmdAlloc);
        }
    }

    pub fn drawPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut s) = alias self._composeShader {
            s:.select ();
        }

        if let Ok (dmut m : _) = alias self._mesh {
            m:.draw (alias cmdAlloc);
        }
    }

    pub fn loadShadowPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut mesh) = alias self._shadowMesh {
            mesh:.register (alias cmdAlloc);
        }
    }

    pub fn drawShadowPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut s) = alias self._shadowShader {
            s:.select ();
        }

        if let Ok (dmut m : _) = alias self._shadowMesh {
            m:.draw (alias cmdAlloc);
        }
    }

    pub fn onQuit (mut self) {
        log::info ("Closing app");
        self._app:.closeActivity ();
        self._app:.quit ();
    }    

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut m) = alias self._mesh {
                m:.dispose ();
                self._mesh = none;
            }

            if let Ok (dmut m) = alias self._shadowMesh {
                m:.dispose ();
                self._shadowMesh = none;
            }

            if let Ok (dmut s) = alias self._composeShader {
                s:.dispose ();
                self._composeShader = none;
            }

            if let Ok (dmut s) = alias self._shadowShader {
                s:.dispose ();
                self._shadowShader = none;
            }

            self:.window:.resetComposePass ();
            if let Ok (dmut ubo) = alias self._cam {
                ubo:.dispose ();
                self._cam = none;
            }

            if let Ok (dmut ubo) = alias self._shadowCam {
                ubo:.dispose ();
                self._shadowCam = none;
            }

            if let Ok (dmut ubo) = alias self._world {
                ubo:.dispose ();
                self._world = none;
            }

            if let Ok (dmut i) = alias self._texture {
                i:.dispose ();
                self._texture = none;
            }
        }
    }
    
}


fn main () {
    {
        let dmut app = copy Application ("res:/config/app.toml");
        app:.openActivity!{&MyActivity} ();
        app:.run ();
        app:.dispose ();
    } catch {
        bd => {
            eprintln (bd);
        }
    }
} 
