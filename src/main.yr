in main;
use std::{io, fs::_, time::_, rand};

mod balder;

use balder::{math::_, node::_, core::{_, driver::_}};
use balder::node::mesh::{indexed, data::ubo};

use vulkan::_;
use sdl2::_;

record ColorVertex {
    pub let mut v_pos : vec3;
    pub let mut v_color : vec3;
    pub self (pos : vec3, color : vec3)
        with v_pos = pos, v_color = color
    {}
}

record UniformValues {
    pub let mut f_color : vec3;
    pub self (color : vec3)
        with f_color = color
    {}
}


class MyActivity over Activity {

    let dmut _sh : (&Shader)? = none;

    let dmut _mesh : (&Mesh)? = none;

    let dmut _ubo : (&UniformBufferObject)? = none;

    let dmut _descSet : (&DescriptorSet)? = none;

    pub self (dmut app : &Application)
        with super (alias app)
    {
        app:.getInputManager ():.connectQuit (&self:.onQuit);
        app:.getInputManager ():.connect (KeyInfo (SDLK_r, KeyEvent::ALL), &self:.redraw);
        self._sh = {
            copy Shader!{ColorVertex, UniformValues}::simplePass (alias app:.getWindow ():.getVulkanDevice (),
                                                                  Path ("./res/shaders/triangle/triangle.vert.spv"),
                                                                  Path ("./res/shaders/triangle/triangle.frag.spv"))
        } catch {
            err => {
                println (err);
                panic;
            }
        }?;

        let points = copy [ColorVertex (makeVec3 (-0.5f, -0.5f, 0.f), makeVec3 (1.0f, 0.0f, 0.0f)),
                           ColorVertex (makeVec3 (0.5f, -0.5f, 0.f), makeVec3 (0.0f, 1.0f, 0.0f)),
                           ColorVertex (makeVec3 (0.5f, 0.5f, 0.f), makeVec3 (0.0f, 0.0f, 1.0f)),
                           ColorVertex (makeVec3 (-0.5f, 0.5f, 0.f), makeVec3 (1.0f, 1.0f, 1.0f))];

        let indices = copy [0u32, 1u32, 2u32, 2u32, 3u32, 0u32];

        self._mesh = (copy IndexedMesh!{ColorVertex, u32} (alias app:.getWindow ():.getVulkanDevice (), points, indices))?;

        {
            let dmut ubo = copy UniformBufferObject!{UniformValues} (app:.getWindow ():.getVulkanDevice ());
            let dmut buf = ubo:.getUniform ("f_color");
            buf:.update (makeVec3 (0.0f, 1.0f, 0.0f));

            if let Ok (dmut s) = alias self._sh {
                let dmut descSet = s:.getAllocator ():.allocate ();
                ubo:.bind (alias descSet);
                self._descSet = (alias descSet)?;
                descSet:.finalize ();
            }

            self._ubo = (alias ubo)?;
        } catch {
            err : _ => {
                println (err);
            }
        }

        {
            app:.getWindow ():.updateDrawing (
                &self:.loadPhase,
                &self:.drawPhase
            );        
        } catch {
            err : _ => {
                println (err);
            }
        }
    }

    pub over onUpdate (mut self, delta : Duration) {
        delta;
    }

    pub fn redraw (mut self, _ : KeyInfo) {
        if let Ok (dmut b) = alias self._ubo {
            b:.getUniform ("f_color"):.update (
                makeVec3 (uniform (0.0f, 1.0f), uniform (0.0f, 1.0f), uniform (0.0f, 1.0f)));
        } catch {
            err : _ => {
                println (err);
            }
        }
    }

    pub fn loadPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut mesh) = alias self._mesh {
            mesh:.register (alias cmdAlloc);
        }
    }

    pub fn drawPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        cmdAlloc;
        if let Ok (dmut s) = alias self._sh {
            s:.select ();
        }

        if let Ok (dmut s) = alias self._descSet {
            s:.select ();
        }

        if let Ok (dmut m : _) = alias self._mesh {
            m:.draw (alias cmdAlloc);
        }
    }
    
    pub fn onQuit (mut self) {
        println ("Closing app");
        self._app:.closeActivity ();
        self._app:.quit ();
    }    

    impl Disposable {
        pub over dispose (mut self) {
            // if let Ok (dmut u) = alias self._ubo {
            //     u:.dispose ();
            //     self._ubo = none;
            // }

            if let Ok (dmut m) = alias self._mesh {
                m:.dispose ();
                self._mesh = none;
            }

            if let Ok (dmut shader) = alias self._sh {
                shader:.dispose ();
                self._sh = none;
            }
        }

    }
    
}


fn main () {
    {
        let dmut app = copy Application (Path ("config/app.toml"));
        app:.openActivity!{&MyActivity} ();
        app:.run ();
        app:.dispose ();
    } catch {
        bd => {
            println (bd);
        }
    }
} 
