in main;
use std::{io, fs::_, time::_, rand, math};

mod balder;

use balder::{math::_, scene::node::_, core::_, interface};
use balder::core::memory::_;
use balder::interface::{_,
                        widget::_,
                        widget::layout::_,
                        widget::button::_,
                        widget::text::_};

use balder::core::{shader::_,
                   application::_,
                   driver::_};

use balder::scene::node::{_, node3D::_};
use balder::scene::node::node3D::camera;

use balder::utils::_;

use vulkan::_;
use sdl2::_;

class MyActivity over Activity {

    let dmut _scene : (&Scene)? = none;
    let dmut _lbl : (&Label)? = none;
    let dmut _cam : (&Camera)? = none;

    let mut _angle : f32 = 0.f;
    let mut _dist : f32 = 2.f;
    
    
    pub self (uid : usize, dmut app : &Application, dmut window : &Window)
        with super (uid, alias app, alias window)
    {}

    over onStart (mut self) {
        self.input:.quit ():.connect (self.box, &self:.onQuit);
        self.input:.mouseWheel ():.connect (self.box, &self:.onWheel);
        
        println ("StyleSheet : ", self.gui:.loadStyleFile ("res:/config/app.style")?);
        println ("GUI : ", self.gui:.loadGUIFile ("res:/config/app.gui")?);

        if let Ok (dmut w : &Scene3DLayout) = self.gui:.find ("scene") {
            self._scene = w:.getScene ();
        }

        if let Ok (dmut l : &Label) = self.gui:.find ("fps") {
            self._lbl = (alias l)?;
        }

        {
            if let Ok (dmut s : &Scene) = alias self._scene {
                self:.createBoxMesh (alias s);
                self._cam = (alias self:.createCam (alias s))?;
                self:.createLight (alias s);
            }
        } catch {
            err => {
                log::error #("Main", "Failed to load mesh", err);
            }
        }
    }

    pub fn redraw (mut self, _ : KeyInfo) {
        self.window:.redrawPipeline ();
    }

    over onUpdate (mut self, _delta_ : Duration) {
        if let Ok (dmut lbl) = alias self._lbl {
            lbl:.setText (std::conv::to!{[c8]} (self.window.getNbFramesLastSecond ()));            
        }

        self._angle += (cast!f32 (_delta_.millis) / 30.f);
        let teta = 45.f;
        let radius = self._dist;
        
        if let Ok (dmut cam) = alias self._cam {
		    // self._angle = (self._angle + cam.position.x) % 360.f;
            let mut pos = cam.position;
            let mut target = makeVec3 (0.f, 0.f, 0.f);

            pos.x = target.x + radius * sin (math::utils::radian (teta)) * sin (math::utils::radian (self._angle));
            pos.y = target.y + radius * cos (math::utils::radian (teta));
            pos.z = target.x + radius * sin (math::utils::radian (teta)) * cos (math::utils::radian (self._angle));
            
            cam.position = pos;
        }
    }

    pub fn onQuit (mut self) {
        log::info #("Main", "Closing app");
        self.app:.close (alias self);
    }

    pub fn onWheel (mut self, _ : i32, _ : i32, _ : i32, w : i32) {
        self._dist -= cast!f32 (w) / 10.f;
    }

    fn createBoxMesh (mut self, dmut scene : &Scene)
        throws BalderError
    {
        let dmut __subject__ = copy SolidObjectModel::fromFile ("subject", scene:.getRootNode (),
                                                                "res:/models/rayman/rayman.obj");        
        
        let dmut ground = copy SolidObjectModel::fromFile ("ground", scene:.getRootNode (),
                                                           "res:/models/cube/cube.obj");
        
        let dmut _wall_1_ = copy SolidObjectModel::fromFile ("wall_1", scene:.getRootNode (),
                                                             "res:/models/cube/cube.obj");
        
        let dmut _wall_2_ = copy SolidObjectModel::fromFile ("wall_1", scene:.getRootNode (),
                                                             "res:/models/cube/cube.obj");    
        
        __subject__.scale *= 3.f;
        ground.position = makeVec3 (0.f, -1.f, 0.f);
        ground.scale = makeVec3 (10.f, 0.2f, 10.f);

        _wall_1_.position = makeVec3 (-25.f, 0.f, 0.f);
        _wall_1_.scale = makeVec3 (0.2f, 5.f, 10.f);
        
        _wall_2_.position = makeVec3 (-0.f, 0.f, -25.f);
        _wall_2_.scale = makeVec3 (10.f, 5.f, 0.2f);
    }

    fn createCam (mut self, dmut scene : &Scene)-> dmut &Camera {
        let dmut cam = copy PerspectiveCamera ("cam", scene:.getRootNode ());
        cam.fov = 90.f;
        cam.position = makeVec3 (-self._dist, self._dist, -self._dist);

        alias cam
    }

    fn createLight (mut self, dmut scene : &Scene) {
        let dmut light = copy Light ("light", scene:.getRootNode ());
        light.position = makeVec3 (-0.3f, -1.0f, -0.2f);        
    }

    // impl Disposable {
    //     pub over dispose (mut self) {
    //         if let Ok (dmut sc) = alias self._scene {
    //             sc:.dispose ();
    //             self._scene = none;
    //         }
    //     }
    // }

}


fn main () {
    {
        let cfg = copy BalderConfig ("res:/config/app.toml");
        let dmut app = copy Application ();
        app:.open!{&MyActivity} (cfg);

        app:.run ();
    } catch {
        bd => {
            eprintln (bd);
        }
    }
} 
