mod main;
import std::io;

import balder::_;
import balder::scene::mesh::vbo;
import std::fs::_;
import std::time::dur;

import std::fs::path;
import vulkan::_;
import std::rand;


struct
| pos : vec3
| color : vec3
 ->  ColorVertex;

struct
| f_color : vec3
 -> UniformValues;
    


class MyActivity over Activity {

    let dmut _sh : (&Shader)? = (dmut (&Shader)?)::__err__;

    let dmut _mesh : (&Mesh)? = (dmut (&Mesh)?)::__err__;

    let dmut _ubo : (&UniformBufferObject)? = (dmut (&UniformBufferObject)?)::__err__;

    let dmut _descSet : (&DescriptorSet)? = (dmut (&DescriptorSet)?)::__err__;

    pub self (dmut app : &Application) with super (alias app) {    
        app:.getInputManager ():.connectQuit (&self:.onQuit);
        app:.getInputManager ():.connect (KeyInfo ( SDLK_r, KeyEvent::ALL ), &self:.redraw);
        self._sh = {
            Shader!{ColorVertex, UniformValues}::simplePass (alias app:.getWindow ():.getVulkanDevice (),
                                                             Path::new ("./res/shaders/triangle/triangle.vert.spv"s8),
                                                             Path::new ("./res/shaders/triangle/triangle.frag.spv"s8))

                
        } catch {
            err : _ => {
                println (err);
                __pragma!panic ();
            }
        }?;

        let points = [ColorVertex (makeVec3 (-0.5f, -0.5f, 0.f), makeVec3 (1.0f, 0.0f, 0.0f)),
                      ColorVertex (makeVec3 (0.5f, -0.5f, 0.f), makeVec3 (0.0f, 1.0f, 0.0f)),
                      ColorVertex (makeVec3 (0.5f, 0.5f, 0.f), makeVec3 (0.0f, 0.0f, 1.0f)),
                      ColorVertex (makeVec3 (-0.5f, 0.5f, 0.f), makeVec3 (1.0f, 1.0f, 1.0f))];

        let indices = [0u16, 1u16, 2u16, 2u16, 3u16, 0u16];


        self._mesh = IndexedMesh::new (alias app:.getWindow ():.getVulkanDevice (), points, indices)?;
        {
            let dmut ubo = UniformBufferObject!{UniformValues}::new (app:.getWindow ():.getVulkanDevice ());
            let dmut buf = ubo:.getUniform ("f_color");
            buf:.update (makeVec3 (1.0f, 0.0f, 0.0f));
            
            match ref self._sh {
                Ok (dmut s : _) => {
                    let dmut descSet = s:.getAllocator ():.allocate ();
                    ubo:.bind (alias descSet);
                    self._descSet = (alias descSet)?;
                    descSet:.finalize ();
                }
            }
            self._ubo = (alias ubo)?;
        } catch {
            err : _ => {
                println (err);                
            }
        }
        
        {
            app:.getWindow ():.updateDrawing (
                &self:.loadPhase,
                &self:.drawPhase
            );        
        } catch {
            err : _ => {
                println (err);
            }
        }
    }

    pub over onUpdate (mut self) {}

    pub def redraw (mut self, _ : KeyInfo) {
        match ref self._ubo {
            Ok (dmut b : _) => {
                b:.getUniform ("f_color"):.update (
                    makeVec3 (uniform (0.0f, 1.0f), uniform (0.0f, 1.0f), uniform (0.0f, 1.0f))
                );
            } catch {
                err : _ => {
                    println (err);
                }
            }
        }            
    }

    pub def loadPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        match ref self._mesh {
            Ok (dmut mesh : _) => {
                mesh:.register (alias cmdAlloc);
            }
        }
    }

    pub def drawPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        match ref self._sh {
            Ok (dmut s : _) => s:.use ();
        }

        match ref self._descSet {
            Ok (dmut s : _) => s:.use ();
        }
        
        match ref self._mesh {
            Ok (dmut m : _) => {
                m:.draw (alias cmdAlloc);
            }
        }
    }
    
    pub def onQuit (mut self) {        
        println ("Closing app");
        self._app:.closeActivity ();
        self._app:.quit ();
    }    

    impl Disposable {
        
        pub over dispose (mut self) {
            match ref self._ubo {
                Ok (dmut u : _) => u:.dispose ();
            }
            
            match ref self._mesh {
                Ok (dmut m : _) => { m:.dispose (); }
            }
            
            match ref self._sh {
                Ok (dmut shader : &Shader)=> { shader:.dispose (); }
            }
        }

    }
    
}


def main () {

    with dmut app = Application::new (Path::new ("config/app.toml"s8)) {
        app:.openActivity!{&MyActivity} ();
        app:.run ();
                
    } catch {
        bd : &BalderError => {
            println (bd);
        }
    }

} 
