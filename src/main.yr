in main;
use std::{io, fs::_, time::_, rand};

mod balder;

use balder::{math::_, node::_, core::_};
use balder::core::{shader::_,
                   application::_, driver::_};

use balder::node::mesh::indexed;
use balder::utils::_;

use vulkan::_;
use sdl2::_;

record ColorVertex {
    pub let mut v_pos : vec3;
    pub let mut v_color : vec3;
    pub let mut v_uv : vec2;
    pub self (pos : vec3, color : vec3, uv : vec2)
        with v_pos = pos, v_color = color, v_uv = uv
    {}
}

record CameraValues {
    pub let mut view = mat4 ();
    pub let mut proj = mat4 ();
    pub self () {}
}

class MyActivity over Activity {

    let dmut _mesh : (&Mesh)? = none;

    let dmut _descSet : (&DescriptorSet)? = none;

    let dmut _cam : (&UniformBufferObject)? = none;
    let dmut _shadowCam : (&UniformBufferObject)? = none;
    let dmut _world : (&UniformBufferObject)? = none;
    let dmut _texture : (&Texture)? = none;


    let dmut _camera = CameraValues ();
    let dmut _shadowCamera = CameraValues ();
    let dmut _model = mat4 ();

    let mut _allAngle = 0.f;

    // let dmut _texture : (&Texture)? = none;

    pub self (dmut app : &Application)
        with super (alias app)
    {
        app:.getInputManager ():.connectQuit (&self:.onQuit);
        app:.getInputManager ():.connect (KeyInfo (SDLK_r, KeyEvent::ALL), &self:.redraw);
        app:.getInputManager ():.connectResize (&self:.onResize);

        let dim = app:.getWindow ().getDimension ();
        self._camera.view = math::utils::lookAt (makeVec3 (0.f, 1.f, 1.f), makeVec3 (0.f, 0.f, 0.f), makeVec3 (0.f, 1.f, 0.f));
        self._camera.proj = math::utils::perspective (radian (90.f), cast!f32 (dim._0) / cast!f32 (dim._1), 0.1f, 10.0f);

        self._shadowCamera.view = self._camera.view;
        self._shadowCamera.proj = math::utils::perspective (radian (90.f), cast!f32 (800) / cast!f32 (800), 0.1f, 10.0f);

        {
            let dmut texture = copy Texture2D (alias app:.getWindow ():.getVulkanDevice (), "images:/texture.jpg");

            self:.window:.addSubpass!{ColorVertex} ("shaders:/white.toml",
                                                    &self:.loadPhase,
                                                    &self:.drawPhase,
                                                    800, 800,
                                                    onlyDepth-> true);

            self:.window:.setComposePass!{ColorVertex} ("shaders:/triangle.toml",
                                                        &self:.loadPhase,
                                                        &self:.drawPhase);

            let dmut cam = copy UniformBufferObject!{CameraValues} (alias app:.getWindow ():.getVulkanDevice ());
            let dmut shadowCam = copy UniformBufferObject!{CameraValues} (alias app:.getWindow ():.getVulkanDevice ());

            self:.window:.getComposeShader ():.setUniform ("camera", alias cam);
            self:.window:.getSubpassShader (0):.setUniform ("camera", alias shadowCam);
            self._cam = (alias cam)?;
            self._shadowCam = (alias shadowCam)?;
            cam:.update (self._camera);
            shadowCam:.update (self._shadowCamera);

            let dmut world = copy UniformBufferObject!{mat4} (alias app:.getWindow ():.getVulkanDevice ());
            self:.window:.getComposeShader ():.setUniform ("world", alias world);
            self:.window:.getSubpassShader (0):.setUniform ("world", alias world);
            self._world = (alias world)?;

            self:.window:.getComposeShader ():.setTexture ("albedo", alias texture);
            self._texture = (alias texture)?;

            if let dmut p : &VulkanDepthSubpass = alias self:.window:.getSubpass (0) {
                self:.window:.getComposeShader ():.setTexture ("depth", p:.getDepth ());
            } else {
                println ("??");
            }
        } catch {
            err => {
                log::error (err);
                panic;
            }
        };

        let points = copy [ColorVertex (makeVec3 (-0.5f, -0.5f, 0.f), makeVec3 (1.0f, 0.0f, 0.0f), makeVec2 (1.f, 0.f)),
                           ColorVertex (makeVec3 (0.5f, -0.5f, 0.f), makeVec3 (0.0f, 1.0f, 0.0f), makeVec2 (0.f, 0.f)),
                           ColorVertex (makeVec3 (0.5f, 0.5f, 0.f), makeVec3 (0.0f, 0.0f, 1.0f), makeVec2 (0.f, 1.f)),
                           ColorVertex (makeVec3 (-0.5f, 0.5f, 0.f), makeVec3 (1.0f, 1.0f, 1.0f), makeVec2 (1.f, 1.f)),

                           ColorVertex (makeVec3 (-0.5f, -0.5f, -0.5f), makeVec3 (1.0f, 0.0f, 0.0f), makeVec2 (0.0f, 0.0f)),
                           ColorVertex (makeVec3 (0.5f, -0.5f, -0.5f), makeVec3 (0.0f, 1.0f, 0.0f), makeVec2 (1.0f, 0.0f)),
                           ColorVertex (makeVec3 (0.5f, 0.5f, -0.5f), makeVec3 (0.0f, 0.0f, 1.0f), makeVec2 (1.0f, 1.0f)),
                           ColorVertex (makeVec3 (-0.5f, 0.5f, -0.5f), makeVec3 (1.0f, 1.0f, 1.0f), makeVec2 (0.0f, 1.0f))];

        let indices : [u32] = copy [0, 1, 2, 2, 3, 0,
                                    4, 5, 6, 6, 7, 4];

        self._mesh = (copy IndexedMesh!{ColorVertex, u32} (alias app:.getWindow ():.getVulkanDevice (), points, indices))?;

        self:.redraw (KeyInfo (SDLK_r, KeyEvent::DOWN));
    }

    pub fn redraw (mut self, _ : KeyInfo) {
        self:.window:.redraw ();
    }

    pub fn onResize (mut self, w : u32, h : u32) {
        println (w, " ", h);
        self._camera.proj = math::utils::perspective (radian (90.f), cast!f32 (w) / cast!f32 (h), 0.1f, 10.0f);
        if let Ok (dmut cam) = alias self._cam {
            cam:.update (self._camera);
        }
    }

    pub over onUpdate (mut self, delta : Duration) {
        self._allAngle += (cast!f32 (delta.allMillis) / 100.f);
        self._allAngle %= 360.f;

        self._model = utils::rotationZ (radian (self._allAngle));
        if let Ok (dmut ubo) = alias self._world {
            ubo:.update (self._model);
        }
    }

    pub fn loadPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut mesh) = alias self._mesh {
            mesh:.register (alias cmdAlloc);
        }
    }

    pub fn drawPhase (mut self, dmut cmdAlloc : &IndirectCommandAllocator) {
        if let Ok (dmut m : _) = alias self._mesh {
            m:.draw (alias cmdAlloc);
        }
    }
    
    pub fn onQuit (mut self) {
        log::info ("Closing app");
        self._app:.closeActivity ();
        self._app:.quit ();
    }    

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut m) = alias self._mesh {
                m:.dispose ();
                self._mesh = none;
            }

            self:.window:.resetComposePass ();
            if let Ok (dmut ubo) = alias self._cam {
                ubo:.dispose ();
                self._cam = none;
            }

            if let Ok (dmut ubo) = alias self._shadowCam {
                ubo:.dispose ();
                self._shadowCam = none;
            }

            if let Ok (dmut ubo) = alias self._world {
                ubo:.dispose ();
                self._world = none;
            }

            if let Ok (dmut i) = alias self._texture {
                i:.dispose ();
                self._texture = none;
            }
        }

    }
    
}


fn main () {
    {
        let dmut app = copy Application ("res:/config/app.toml");
        app:.openActivity!{&MyActivity} ();
        app:.run ();
        app:.dispose ();
    } catch {
        bd => {
            eprintln (bd);
        }
    }
} 
