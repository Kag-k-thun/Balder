in interface;

mod ::loader;
pub mod ::widget;
pub mod ::alignement;
pub mod ::font;

use balder::core::{_, application::_};
use balder::interface::_;
use balder::math::_;

use std::{io, conv, fs::_};
use std::time::_;

use ::sdl2::_;

@final
pub class WidgetManager {

    // The root widget
    let dmut _content : (&Widget)? = none;

    // The application to which the manager is attached
    let dmut _app : &Application;

    // The font manager used to render text to the screen
    let dmut _fontManager : &FontManager;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE INFOS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    prot { // focuses

        // The timer used to check double clicks
        let dmut _clickTimer = Timer ();

        // True if single left click occurred (to detect double clicks)
        let mut _clicked : bool = false;

        // The position of the mouse relative to window size (range [0, 1])
        let mut _mousePosition : vec2 = vec2 ();

        // The widget currently sliding
        let dmut _slideFocus : (&Widget)? = none;

        // The widget receiving text inputs
        let dmut _textFocus : (&Widget)? = none;

        // Widget being left clicked
        let dmut _leftClickFocus : (&Widget)? = none;

        // Widget being right clicked
        let dmut _rightClickFocus : (&Widget)? = none;

        // Widget being middle clicked
        let dmut _middleClickFocus : (&Widget)? = none;

        // Widget being clicked and waiting for a new click event to reset
        let dmut _nextClickFocus : (&Widget)? = none;

        // Widget currently scrolling
        let dmut _scrollFocus : (&Widget)? = none;

        // Widget currently hovered
        let dmut _hoverFocus : (&Widget)? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a widget manager containing nothing
     * */
    pub self (dmut app : &Application)
        with _app = alias app
        , _fontManager = copy FontManager (app:.getWindow ():.getVulkanDevice ())
    {
        app:.getInputManager ():.connect (MouseInfo (SDL_BUTTON_LEFT, KeyEvent::ALL), &self:.onMouseLeftClick);
        app:.getInputManager ():.connect (MouseInfo (SDL_BUTTON_RIGHT, KeyEvent::ALL), &self:.onMouseRightClick);
        app:.getInputManager ():.connect (MouseInfo (SDL_BUTTON_MIDDLE, KeyEvent::ALL), &self:.onMouseMiddleClick);

        app:.getInputManager ():.connectDoubleClick (&self:.onMouseDoubleClick);
        app:.getInputManager ():.connectMotion (&self:.onMouseMotion);
        app:.getInputManager ():.connectWheel (&self:.onMouseWheel);
        app:.getInputManager ():.connectResize (&self:.onWindowResize);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a toml file configuring the widgets
     * */
    pub fn loadFromFile (mut self, path : [c8])
        throws BalderError
    {
        self:.setContent (loader::widgetFromFile (alias self, path));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the root widget of the interface
     * @warning: dispose the old one if any
     * */
    pub fn setContent (mut self, dmut root : &Widget) {
        if let Ok (dmut w) = alias self._content {
            w:.dispose ();
        }

        self._content = (alias root)?;
        self:.updateWidgets ();
    }

    /**
     * Set the widget receiving text input events
     * @params:
     *    - widget: the widget receiving the events (none to reset)
     * */
    pub fn setTextFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut txt) = alias self._textFocus {
            txt:.onLoseTextFocus ();
        }

        self._textFocus = alias widget;
        if widget.hasValue {
            self:.startInputText ();
        }
    }

    /**
     * Set the widget receiving sliding events
     * @params:
     *    - widget: the widget receiving the events (none to reset)
     * */
    pub fn setSlideFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut sld) = alias self._slideFocus {
            sld:.onLoseSlideFocus ();
        }

        self._slideFocus = alias widget;
    }

    /**
     * Set the widget being clicked and receiving click release event
     * */
    pub fn setLeftClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._leftClickFocus {
            c:.onClickLeftEnd ();
        }

        self._leftClickFocus = alias widget;
    }

    /**
     * Set the widget being right clicked and receiving click release event
     * */
    pub fn setRightClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._rightClickFocus {
            c:.onClickRightEnd ();
        }

        self._rightClickFocus = alias widget;
    }

    /**
     * Set the widget being middle clicked and receiving click release event
     * */
    pub fn setMiddleClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._middleClickFocus {
            c:.onClickMiddleEnd ();
        }

        self._middleClickFocus = alias widget;
    }

    /**
     * Set the widget being clicked and waiting for the next click event
     * */
    pub fn setNextClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._nextClickFocus {
            c:.onNextClick ();
        }

        self._nextClickFocus = alias widget;
    }

    /**
     * Set the widget being clicked and waiting for the next click event
     * */
    pub fn setScrollFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._scrollFocus {
            c:.onLoseScrollFocus ();
        }

        self._scrollFocus = alias widget;
    }

    /**
     * Set the widget being hovered
     * */
    pub fn setHoverFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._hoverFocus {
            c:.onLoseHoverFocus ();
        }

        self._hoverFocus = alias widget;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the application containing the widget manager
     * */
    pub fn getApplication (mut self)-> dmut &Application {
        alias self._app
    }


    pub fn getWindow (mut self)-> dmut &Window {
        alias self._app:.getWindow ()
    }

    pub fn getFontManager (mut self)-> dmut &FontManager {
        alias self._fontManager
    }

    pub fn hasScrollFocus (self, w : &Widget)-> bool {
        if let Ok (o) = self._scrollFocus {
            o is w
        } else {
            false
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the layout of widgets is updated
     * */
    pub fn updateWidgets (mut self) {
        if let Ok (dmut root) = alias self._content {
            let dim = self._app:.getWindow ().getDimension ();
            root:.onUpdateSize (makeVec2 (0.f, 0.f), makeVec2 (cast!f32 (dim._0), cast!f32 (dim._1)), 0);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut w) = alias self._content {
                w:.dispose ();
                self._content = none;
            }

            self._fontManager:.dispose ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          WINDOW SLOT          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn onWindowResize (mut self, _ : u32, _ : u32) {
        self:.updateWidgets ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE SLOTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated when the mouse move on the screen
     */
    fn onMouseMotion (mut self, x : i32, y : i32) {
        let dim = self._app:.getWindow ().getDimension ();
        let cursorPos = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._slideFocus {
            let wsize = w.getAbsoluteSize (), wpos = w.getAbsolutePosition ();

            let speed = cursorPos - self._mousePosition;
            let relPos = makeVec2 ((cast!f32 (x) - wpos.x) / wsize.x, (cast!f32 (y) - wpos.y) / wsize.y);
            self._mousePosition = cursorPos;
            w:.onSliding (relPos, speed);
        }

        else if let Ok (dmut r) = alias self._content {
            let dmut old = alias self._hoverFocus;
            self._hoverFocus = none;

            self._mousePosition = cursorPos;
            r:.onHover (self._mousePosition);

            // New focus
            if let Ok (dmut w) = alias self._hoverFocus {
                if let Ok (dmut o) = alias old && w !is o {
                    o:.onLoseHoverFocus ();
                }
            }

        }
    }

    /**
     * Slot activated when the mouse wheel is moved
     */
    fn onMouseWheel (mut self, x : i32, y : i32, amountX : i32, amountY : i32) {
        // Event is not propagated if there is a sliding widget
        if self._slideFocus.hasValue {
            return;
        }

        if let Ok (dmut w) = alias self._scrollFocus {
            let wpos = w.getAbsolutePosition (), wsize = w.getAbsoluteSize ();
            let relPos = makeVec2 ((cast!f32 (x) - wpos.x) / wsize.x, (cast!f32 (y) - wpos.y) / wsize.y);
            w:.onScroll (relPos, amountX, amountY);
        }
    }

    /**
     * Slot activated when the left button of the mouse is clicked
     */
    fn onMouseLeftClick (mut self, x : i32, y : i32, info : MouseInfo) {
        self:.setNextClickFocus (none);

        let dim = self._app:.getWindow ().getDimension ();
        self._mousePosition = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._content {
            if info.type == KeyEvent::DOWN {
                self._clickTimer:.reset ();
                self._clicked = true;
                self:.stopInputText ();
                w:.onClickLeft (self._mousePosition);
            }

            else if info.type == KeyEvent::RELEASE {
                self:.setSlideFocus (none);
                self:.setLeftClickFocus (none);
            }
        }
    }

    /**
     * Method called by the onMouseLeftClick if two clicks happend in less than __DOUBLE_CLICK_SENSIBILITY__
     */
    fn onMouseDoubleClick (mut self, x : i32, y : i32) {
        self:.setNextClickFocus (none);

        if let Ok (dmut w) = alias self._content {
            let wpos = w.getAbsolutePosition (), wsize = w.getAbsoluteSize ();
            let relPos = makeVec2 ((cast!f32 (x) - wpos.x) / wsize.x, (cast!f32 (y) - wpos.y) / wsize.y);

            self._clickTimer:.reset ();
            w:.onDoubleClick (relPos);

            self:.stopInputText ();

        }
    }

    /**
     * Slot activated when the right button of the mouse is clicked
     */
    fn onMouseRightClick (mut self, x : i32, y : i32, info : MouseInfo) {
        self:.setNextClickFocus (none);

        let dim = self._app:.getWindow ().getDimension ();
        self._mousePosition = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._content {
            if info.type == KeyEvent::DOWN {
                w:.onClickRight (self._mousePosition);
            }

            else if info.type == KeyEvent::RELEASE {
                self:.setRightClickFocus (none);
            }
        }
    }

    /**
     * Slot activated when the middle button of the mouse is clicked
     */
    fn onMouseMiddleClick (mut self, x : i32, y : i32, info : MouseInfo) {
        self:.setNextClickFocus (none);

        let dim = self._app:.getWindow ().getDimension ();
        self._mousePosition = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._content {
            if info.type == KeyEvent::DOWN {
                w:.onClickMiddle (self._mousePosition);
            }

            else if info.type == KeyEvent::RELEASE {
                self:.setMiddleClickFocus (none);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          TEXT INPUT          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the input mode
     * */
    fn startInputText (mut self) {
    }

    /**
     * Change the input mode
     * */
    fn stopInputText (mut self) {
        self:.setTextFocus (none);
    }


}
