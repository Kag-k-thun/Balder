in interface;

mod ::loader;
pub mod ::widget;
pub mod ::alignement;
pub mod ::font;
pub mod ::cursor;

use balder::core::{_, application::_};
use balder::interface::_;
use balder::math::_;

use std::{io, conv, fs::_};
use std::time::_;

use ::sdl2::_;

@final
pub class WidgetManager {

    // The root widget
    let dmut _content : (&Widget)? = none;

    // The application to which the manager is attached
    let dmut _app : &Application;

    // The font manager used to render text to the screen
    let dmut _fontManager : &FontManager;

    // The manager of the mouse cursor
    let dmut _cursorManager : &CursorManager;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE INFOS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    prot { // focuses

        // The timer used to check double clicks
        let dmut _clickTimer = Timer ();

        // True if single left click occurred (to detect double clicks)
        let mut _clicked : bool = false;

        // The position of the mouse relative to window size (range [0, 1])
        let mut _mousePosition : vec2 = vec2 ();

        // The widget currently sliding
        let dmut _slideFocus : (&Widget)? = none;

        // The widget receiving text inputs
        let dmut _textFocus : (&Widget)? = none;

        // Widget being left clicked
        let dmut _leftClickFocus : (&Widget)? = none;

        // Widget being right clicked
        let dmut _rightClickFocus : (&Widget)? = none;

        // Widget being middle clicked
        let dmut _middleClickFocus : (&Widget)? = none;

        // Widget being clicked and waiting for a new click event to reset
        let dmut _nextClickFocus : (&Widget)? = none;

        // Widget currently scrolling
        let dmut _scrollFocus : (&Widget)? = none;

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a widget manager containing nothing
     * */
    pub self (dmut app : &Application)
        with _app = alias app
        , _fontManager = copy FontManager (app:.getWindow ():.getVulkanDevice ())
        , _cursorManager = copy CursorManager ()
    {
        app:.getInputManager ():.connect (MouseInfo (SDL_BUTTON_LEFT, KeyEvent::ALL), &self:.onMouseLeftClick);
        app:.getInputManager ():.connect (MouseInfo (SDL_BUTTON_RIGHT, KeyEvent::ALL), &self:.onMouseRightClick);
        app:.getInputManager ():.connect (MouseInfo (SDL_BUTTON_MIDDLE, KeyEvent::ALL), &self:.onMouseMiddleClick);

        app:.getInputManager ():.connectDoubleClick (&self:.onMouseDoubleClick);
        app:.getInputManager ():.connectMotion (&self:.onMouseMotion);
        app:.getInputManager ():.connectWheel (&self:.onMouseWheel);
        app:.getInputManager ():.connectResize (&self:.onWindowResize);

        app:.connectUITick (&self:.onTick);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a toml file configuring the widgets
     * */
    pub fn loadFromFile (mut self, path : [c8])
        throws BalderError
    {
        self:.setContent (loader::widgetFromFile (alias self, path));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the root widget of the interface
     * @warning: dispose the old one if any
     * */
    pub fn setContent (mut self, dmut root : &Widget) {
        if let Ok (dmut w) = alias self._content {
            w:.dispose ();
        }

        self._content = (alias root)?;
        self:.updateWidgets ();
    }

    /**
     * Set the widget receiving text input events
     * @params:
     *    - widget: the widget receiving the events (none to reset)
     * */
    pub fn setTextFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut txt) = alias self._textFocus {
            txt:.onLoseTextFocus ();
        }

        self._textFocus = alias widget;
        if widget.hasValue {
            self:.startInputText ();
        }
    }

    /**
     * Set the widget receiving sliding events
     * @params:
     *    - widget: the widget receiving the events (none to reset)
     * */
    pub fn setSlideFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut sld) = alias self._slideFocus {
            sld:.onLoseSlideFocus ();
        }

        self._slideFocus = alias widget;
    }

    /**
     * Set the widget being clicked and receiving click release event
     * */
    pub fn setLeftClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._leftClickFocus {
            c:.onClickLeftEnd ();
        }

        self._leftClickFocus = alias widget;
    }

    /**
     * Set the widget being right clicked and receiving click release event
     * */
    pub fn setRightClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._rightClickFocus {
            c:.onClickRightEnd ();
        }

        self._rightClickFocus = alias widget;
    }

    /**
     * Set the widget being middle clicked and receiving click release event
     * */
    pub fn setMiddleClickFocus (mut self, dmut widget : (&Widget)?) {
        if let Ok (dmut c) = alias self._middleClickFocus {
            c:.onClickMiddleEnd ();
        }

        self._middleClickFocus = alias widget;
    }

    /**
     * Set the widget being clicked and waiting for the next click event
     * */
    pub fn setNextClickFocus (mut self, dmut widget : (&Widget)?, propagate : bool = true) {
        if propagate {
            if let Ok (dmut c) = alias self._nextClickFocus {
                c:.onNextClick ();
            }
        }

        self._nextClickFocus = alias widget;
    }

    /**
     * Set the widget being clicked and waiting for the next click event
     * */
    pub fn setScrollFocus (mut self, dmut widget : (&Widget)?, propagate : bool = true) {
        if propagate {
            if let Ok (dmut c) = alias self._scrollFocus {
                c:.onLoseScrollFocus ();
            }
        }

        self._scrollFocus = alias widget;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the application containing the widget manager
     * */
    pub fn getApplication (mut self)-> dmut &Application {
        alias self._app
    }

    pub fn getWindow (mut self)-> dmut &Window {
        alias self._app:.getWindow ()
    }

    pub fn getFontManager (mut self)-> dmut &FontManager {
        alias self._fontManager
    }

    pub fn getCursorManager (mut self)-> dmut &CursorManager {
        alias self._cursorManager
    }

    pub fn getScrollFocus (mut self)-> dmut (&Widget)? {
        alias self._scrollFocus
    }

    pub fn getScrollFocus (self)-> (&Widget)? {
        self._scrollFocus
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          TICK          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot emitted at each UI frame update from the activity
     * */
    pub fn onTick (mut self, delta : Duration) {
        if let Ok (dmut w) = alias self._content {
            w:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the layout of widgets is updated
     * */
    pub fn updateWidgets (mut self) {
        if let Ok (dmut root) = alias self._content {
            let dim = self._app:.getWindow ().getDimension ();
            root:.onUpdateSize (makeVec2 (0.f, 0.f), makeVec2 (cast!f32 (dim._0), cast!f32 (dim._1)), 0);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self:.stopInputText ();

            self._app:.getInputManager ():.disconnect (MouseInfo (SDL_BUTTON_LEFT, KeyEvent::ALL), &self:.onMouseLeftClick);
            self._app:.getInputManager ():.disconnect (MouseInfo (SDL_BUTTON_RIGHT, KeyEvent::ALL), &self:.onMouseRightClick);
            self._app:.getInputManager ():.disconnect (MouseInfo (SDL_BUTTON_MIDDLE, KeyEvent::ALL), &self:.onMouseMiddleClick);

            self._app:.getInputManager ():.disconnectDoubleClick (&self:.onMouseDoubleClick);
            self._app:.getInputManager ():.disconnectMotion (&self:.onMouseMotion);
            self._app:.getInputManager ():.disconnectWheel (&self:.onMouseWheel);
            self._app:.getInputManager ():.disconnectResize (&self:.onWindowResize);

            self._app:.disconnectUITick (&self:.onTick);

            if let Ok (dmut w) = alias self._content {
                w:.dispose ();
                self._content = none;
            }

            self._fontManager:.dispose ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          WINDOW SLOT          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn onWindowResize (mut self, _ : u32, _ : u32) {
        self:.updateWidgets ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE SLOTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated when the mouse move on the screen
     */
    fn onMouseMotion (mut self, x : i32, y : i32) {
        let dim = self._app:.getWindow ().getDimension ();
        let cursorPos = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._slideFocus {
            let wsize = w.getAbsoluteSize (), wpos = w.getAbsolutePosition ();

            let speed = cursorPos - self._mousePosition;
            let relPos = makeVec2 ((cast!f32 (x) - wpos.x) / wsize.x, (cast!f32 (y) - wpos.y) / wsize.y);
            self._mousePosition = cursorPos;
            w:.onSliding (relPos, speed);
        }

        else if let Ok (dmut r) = alias self._content {
            self._mousePosition = cursorPos;
            r:.onHover (self._mousePosition);
        }
    }

    /**
     * Slot activated when the mouse wheel is moved
     */
    fn onMouseWheel (mut self, x : i32, y : i32, amountX : i32, amountY : i32) {
        // Event is not propagated if there is a sliding widget
        if self._slideFocus.hasValue {
            return;
        }

        if let Ok (dmut w) = alias self._scrollFocus {
            let wpos = w.getAbsolutePosition (), wsize = w.getAbsoluteSize ();
            let relPos = makeVec2 ((cast!f32 (x) - wpos.x) / wsize.x, (cast!f32 (y) - wpos.y) / wsize.y);
            w:.onScroll (relPos, amountX, amountY);
        }
    }

    /**
     * Slot activated when the left button of the mouse is clicked
     */
    fn onMouseLeftClick (mut self, x : i32, y : i32, info : MouseInfo) {
        let dmut cl = alias self._nextClickFocus;
        self:.setNextClickFocus (none, propagate-> false);

        let dim = self._app:.getWindow ().getDimension ();
        self._mousePosition = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._content {
            if info.type == KeyEvent::DOWN {
                self._clickTimer:.reset ();
                self._clicked = true;
                self:.stopInputText ();
                w:.onClickLeft (self._mousePosition);
            }

            else if info.type == KeyEvent::RELEASE {
                self:.setSlideFocus (none);
                self:.setLeftClickFocus (none);
            }
        }

        if let Ok (dmut old) = alias cl{
            if let Ok (new) = self._nextClickFocus {
                if old !is new {
                    old:.onNextClick ();
                }
            } else old:.onNextClick ();
        }
    }

    /**
     * Method called by the onMouseLeftClick if two clicks happend in less than __DOUBLE_CLICK_SENSIBILITY__
     */
    fn onMouseDoubleClick (mut self, x : i32, y : i32) {
        let dmut cl = alias self._nextClickFocus;
        self:.setNextClickFocus (none, propagate-> false);

        if let Ok (dmut w) = alias self._content {
            let wpos = w.getAbsolutePosition (), wsize = w.getAbsoluteSize ();
            let relPos = makeVec2 ((cast!f32 (x) - wpos.x) / wsize.x, (cast!f32 (y) - wpos.y) / wsize.y);

            self._clickTimer:.reset ();
            w:.onDoubleClick (relPos);

            self:.stopInputText ();
        }

        if let Ok (dmut old) = alias cl{
            if let Ok (new) = self._nextClickFocus {
                if old !is new {
                    old:.onNextClick ();
                }
            } else old:.onNextClick ();
        }
    }

    /**
     * Slot activated when the right button of the mouse is clicked
     */
    fn onMouseRightClick (mut self, x : i32, y : i32, info : MouseInfo) {
        let dmut cl = alias self._nextClickFocus;
        self:.setNextClickFocus (none, propagate-> false);

        let dim = self._app:.getWindow ().getDimension ();
        self._mousePosition = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._content {
            if info.type == KeyEvent::DOWN {
                w:.onClickRight (self._mousePosition);
            }

            else if info.type == KeyEvent::RELEASE {
                self:.setRightClickFocus (none);
            }
        }

        if let Ok (dmut old) = alias cl{
            if let Ok (new) = self._nextClickFocus {
                if old !is new {
                    old:.onNextClick ();
                }
            } else old:.onNextClick ();
        }
    }

    /**
     * Slot activated when the middle button of the mouse is clicked
     */
    fn onMouseMiddleClick (mut self, x : i32, y : i32, info : MouseInfo) {
        let dmut cl = alias self._nextClickFocus;
        self:.setNextClickFocus (none, propagate-> false);

        let dim = self._app:.getWindow ().getDimension ();
        self._mousePosition = makeVec2 (cast!f32 (x) / cast!f32 (dim._0), cast!f32 (y) / cast!f32 (dim._1));

        if let Ok (dmut w) = alias self._content {
            if info.type == KeyEvent::DOWN {
                w:.onClickMiddle (self._mousePosition);
            }

            else if info.type == KeyEvent::RELEASE {
                self:.setMiddleClickFocus (none);
            }
        }

        if let Ok (dmut old) = alias cl{
            if let Ok (new) = self._nextClickFocus {
                if old !is new {
                    old:.onNextClick ();
                }
            } else old:.onNextClick ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXT INPUT SLOTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated in text input mode when text is inputed from keyboard
     * */
    fn onTextInput (mut self, txt : [c8]) {
        if let Ok (dmut r) = alias self._textFocus {
            r:.onTextInput (txt);
        }
    }

    /**
     * Slot activated in text input mode, if the key back suppr is pressed
     */
    fn onTextErase (mut self, k : KeyInfo) {
        if k.type == KeyEvent::DOWN || k.type == KeyEvent::REPEAT {
            if let Ok (dmut r) = alias self._textFocus {
                r:.onTextErase ();
            }
        }
    }

    /**
     * Slot activated in text input mode, if the key forward suppr is pressed
     */
    fn onTextForwardErase (mut self, k : KeyInfo) {
        if (k.type == KeyEvent::DOWN || k.type == KeyEvent::REPEAT) {
            if let Ok (dmut r) = alias self._textFocus {
                r:.onTextForwardErase ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXT MOVE SLOTS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated in text input mode, if the key forward is pressed
     */
    fn onTextForwardMove (mut self, k : KeyInfo) {
        if (k.type == KeyEvent::DOWN || k.type == KeyEvent::REPEAT) {
            if let Ok (dmut r) = alias self._textFocus {
                r:.onTextForwardMove ();
            }
        }
    }

    /**
     * Slot activated in text input mode, if the key backward is pressed
     */
    fn onTextBackwardMove (mut self, k : KeyInfo) {
        if (k.type == KeyEvent::DOWN || k.type == KeyEvent::REPEAT) {
            if let Ok (dmut r) = alias self._textFocus {
                r:.onTextBackwardMove ();
            }
        }
    }

    /**
     * Slot activated in text input mode, if the key LCTRL and right are pressed
     */
    fn onTextForwardMoveWord (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextForwardMoveWord ();
        }
    }

    /**
     * Slot activated in text input mode, if the key LCTRL and left are pressed
     */
    fn onTextBackwardMoveWord (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextBackwardMoveWord ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          TEXT SELECTION SLOTS          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated in text input mode, if the key LSHIFT and right are pressed
     */
    fn onTextSelectionForwardMove (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextSelectionForwardMove ();
        }
    }

    /**
     * Slot activated in text input mode, if the key LSHIFT and left are pressed
     */
    fn onTextSelectionBackwardMove (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextSelectionBackwardMove ();
        }
    }

    /**
     * Slot activated in input text mode, if the LCTRL and a are pressed
     */
    fn onTextSelectionAll (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextSelectionAll ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT COPY/PASTE SLOTS          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated in input text mode, if the LCTRL and c are pressed
     */
    fn onTextCopy (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextCopy ();
        }
    }

    /**
     * Slot activated in input text mode, if the LCTRL and v are pressed
     */
    fn onTextPaste (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextPaste ();
        }
    }

    /**
     * Slot activated in input text mode, if the LCTRL and x are pressed
     */
    fn onTextCut (mut self) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextCut ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT VALIDATION EVENTS          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot activated in input text mode, if ENTER key is pressed
     */
    fn onTextValidate (mut self, _ : KeyInfo) {
        if let Ok (dmut c) = alias self._textFocus {
            c:.onTextValidate ();
            c:.onLoseTextFocus ();
            self._textFocus = none;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT MODE TOGGLE STATE          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the input mode
     * */
    fn startInputText (mut self) {
        let dmut man = self._app:.getInputManager ();
        man:.startInputText ();
        man:.connectTextInput (&self:.onTextInput);

        man:.connect (KeyInfo (SDLK_BACKSPACE, KeyEvent::ALL), &self:.onTextErase);
        man:.connect (KeyInfo (SDLK_DELETE, KeyEvent::ALL), &self:.onTextForwardErase);

        man:.connect (KeyInfo (SDLK_LEFT, KeyEvent::ALL), &self:.onTextBackwardMove);
        man:.connect (KeyInfo (SDLK_RIGHT, KeyEvent::ALL), &self:.onTextForwardMove);
        man:.connect (KeyInfo (SDLK_RETURN, KeyEvent::DOWN), &self:.onTextValidate);

        man:.connect (copy [SDLK_LCTRL, SDLK_RIGHT], &self:.onTextForwardMoveWord);
        man:.connect (copy [SDLK_LCTRL, SDLK_LEFT], &self:.onTextBackwardMoveWord);

        man:.connect (copy [SDLK_LCTRL, SDLK_v], &self:.onTextPaste);
        man:.connect (copy [SDLK_LCTRL, SDLK_c], &self:.onTextCopy);
        man:.connect (copy [SDLK_LCTRL, SDLK_x], &self:.onTextCut);
        man:.connect (copy [SDLK_LCTRL, SDLK_a], &self:.onTextSelectionAll);

        man:.connect (copy [SDLK_LSHIFT, SDLK_RIGHT], &self:.onTextSelectionForwardMove);
        man:.connect (copy [SDLK_LSHIFT, SDLK_LEFT], &self:.onTextSelectionBackwardMove);
    }

    /**
     * Change the input mode
     * */
    fn stopInputText (mut self) {
        self:.setTextFocus (none);

        let dmut man = self._app:.getInputManager ();
        man:.startInputText ();
        man:.disconnectTextInput (&self:.onTextInput);

        man:.disconnect (KeyInfo (SDLK_BACKSPACE, KeyEvent::ALL), &self:.onTextErase);
        man:.disconnect (KeyInfo (SDLK_DELETE, KeyEvent::ALL), &self:.onTextForwardErase);

        man:.disconnect (KeyInfo (SDLK_LEFT, KeyEvent::ALL), &self:.onTextBackwardMove);
        man:.disconnect (KeyInfo (SDLK_RIGHT, KeyEvent::ALL), &self:.onTextForwardMove);
        man:.disconnect (KeyInfo (SDLK_RETURN, KeyEvent::DOWN), &self:.onTextValidate);

        man:.disconnect (copy [SDLK_LCTRL, SDLK_RIGHT], &self:.onTextForwardMoveWord);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_LEFT], &self:.onTextBackwardMoveWord);

        man:.disconnect (copy [SDLK_LCTRL, SDLK_v], &self:.onTextPaste);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_c], &self:.onTextCopy);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_x], &self:.onTextCut);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_a], &self:.onTextSelectionAll);

        man:.disconnect (copy [SDLK_LSHIFT, SDLK_RIGHT], &self:.onTextSelectionForwardMove);
        man:.disconnect (copy [SDLK_LSHIFT, SDLK_LEFT], &self:.onTextSelectionBackwardMove);
    }


}
