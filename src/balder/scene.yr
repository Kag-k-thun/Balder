in scene;

pub mod ::node;
mod ::utils;


use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::utils::_;

use balder::scene::node::node3D::{camera, visual, light, visual::material};
use balder::scene::utils::_;

use ::std::{io, time, time::_, fs::path};

use ::vulkan::core;



/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          SCENE          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * A scene manage objects in a 3D environment
 * It has a camera, lights, and a tree of nodes
 * It manages the composing pipeline
 * */
@final
pub class Scene {
    
    // The window to which the scene is attached
    let dmut _window : &Window;

    // The name of the scene
    let _name : [c8];

    // The width of the generated texture
    let mut _width : u32 = 0;

    // The height of the generated texture
    let mut _height : u32 = 0;

    // The slot emitter, used to trigger signals from scene events
    let dmut _box : &SlotEmitter = copy SlotEmitter ();

    // The association of shaders to loaded nodes
    let dmut _shaderToNode : ShaderNodeScene = ShaderNodeScene ();    

    // The node tree hierarchy of the node
    let dmut _tree : NodeTreeScene = NodeTreeScene ();

    // The deferred rendering textures and subpass
    let dmut _deferred : DeferredRenderScene = DeferredRenderScene ();

    // The compose rendering textures and subpasses
    let dmut _compose : ComposeRenderScene = ComposeRenderScene ();


    prot { // Aspect 

        let dmut _aspectChanged : &Signal!{u32, u32} = copy Signal!{u32, u32} ();
        
        let mut _aspectWidth : u32 = 0;
        
        let mut _aspectHeight : u32 = 0;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new scene (not configured)
     * */
    pub self (dmut window : &Window, name : [c8])
        with _window = alias window
        , _name = name        
    {}                

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the scene and load the basic shaders, and subpasses
     * */
    pub fn configure (mut self, width : u32, height : u32)
        throws BalderError
    {
        log::debug #("Scene", "Configure scene :", width, height);        
        self:.dispose ();
        
        if height != 0 && width != 0 {
            self._width = width;
            self._height = height;
            
            let dmut pipeline = self._window:.getVulkanPipeline ();
            let dname = "deferred_" ~ self._name;
            let cname = "compose_" ~ self._name;

            self._tree:.configure (alias self._window, alias self);            
            self._deferred:.configure (dname, alias self._window, self._width, self._height);
            self._compose:.configure (cname, alias self._window, self._width, self._height, self._deferred);

                    
            let dmut dpass = alias self._deferred.subpass;                         
            let dmut cpass = alias self._compose.subpass;        

            self._shaderToNode:.configure (alias self._window, self._deferred.outputTextures, alias dpass);
            
            dpass:.onDraw ():.connect (&self:.onDeferredDraw);
            cpass:.onDraw ():.connect (&self:.onComposeDraw);
            
            pipeline:.setPassOutput (dname, cname);
                        
            self:.setAspect (width, height);            
        } catch {
            err => {
                log::error #("Scene", "Configuration failed", err);
                throw err;
            }
        }
    }

    /**
     * Change the rendering aspect of the scene, without recomputing the rendering textures
     * */
    pub fn setAspect (mut self, width : u32, height : u32) {
        self._aspectHeight = height;
        self._aspectWidth = width;

        self._aspectChanged:.emit (width, height);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the root node of the scene
     * */
    pub fn getRootNode (mut self)-> dmut &Node {
        alias self._tree.rootNode      
    }

    /**
     * The size of the rendering textures
     * */
    @field
    pub fn width (self)-> u32 {
        self._width
    }

    /**
     * The size of the rendering textures
     * */
    @field
    pub fn height (self)-> u32 {
        self._height
    }

    /**
     * The size of the scene on screen
     * */
    @field
    pub fn aspectWidth (self)-> u32 {
        self._aspectWidth
    }

    /**
     * The size of the scene on screen
     * */
    @field
    pub fn aspectHeight (self)-> u32 {
        self._aspectHeight
    }

    /**
     * @returns: the signal emitted when the size of the scene changes on screen (does not change rendering texture sizes)
     * */
    pub fn aspectChanged (mut self)-> dmut &Signal!{u32, u32} {
        alias self._aspectChanged
    }

    /**
     * @returns: the camera of the scene if there is one camera set in the tree of nodes
     * */
    pub fn getCamera (mut self)-> dmut (&Camera)? {
        alias self._tree.camera
    }

    /**
     * @returns: the window on which the scene is rendered
     * */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the window on which the scene is rendered
     * */
    pub fn getWindow (self)-> &Window {
        self._window
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXTURE RESULTS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the generated position texture of the scene
     * */
    pub fn getPositionTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._deferred.positions
    }

    /**
     * @returns: the generated albedo texture of the scene
     * */
    pub fn getAlbedoTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._deferred.albedo
    }

    /**
     * @returns: the generated material ID texture of the scene
     * */
    pub fn getMaterialIDTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._deferred.materialID
    }

    /**
     * @returns: the generated normal texture of the scene
     * */
    pub fn getNormalTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._deferred.normals
    }

    /**
     * @returns: the generated binormal texture of the scene
     * */
    pub fn getBinormalTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._deferred.binormals
    }

    /**
     * @returns: the generated depth texture of the scene
     * */
    pub fn getDepthTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._deferred.depth
    }

    /**
     * @returns: the generated output texture (composition) of the scene
     * */
    pub fn getOutputTexture (mut self)-> dmut &RefCount!{&Texture} {
        alias self._compose.output
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn onDeferredDraw (mut self) {
        log::debug #("Scene", "Drawing deferred pass scene");
        if !self._tree.camera.hasValue { // nothing to draw if there is no camera
            return;
        }
        
        let dmut subpass = alias self._deferred.subpass;        
        let dmut cmd = copy IndexedDrawCommandAllocator (alias subpass);
        let frame = subpass.getCurrentFrame ();
        
        atomic self {
            self._shaderToNode:.draw (frame, alias cmd);
        }            
    }        
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          COMPOSE SHADER LOOP          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot called when the composition pass is redrawn
     * */
    fn onComposeDraw (mut self) {        
        let dmut pass = alias self._compose.subpass;            
        
        let frame = pass.getCurrentFrame ();                                    
        let cmdV = pass.getDrawingCommandBuffer ();
        
        log::debug #("Scene", "Calling compose compute shader");
        
        let dmut cmd = copy ComputeDispatchCommandAllocator (alias pass);

        let sizes = self._compose.groupSizes;

        {
            cmd:.registerDispatch (groupX-> sizes [0], groupY-> sizes [1], groupZ-> sizes [2]);
            cmd:.finalizeRegister ();
            
            self._compose:.prepareTexture (cmdV, frame);
            self._compose:.select (frame,
                                   self._shaderToNode,                                   
                                   cmdV);
            
            cmd:.dispatchNext ();
            self._compose:.finalizeTexture (cmdV, frame);
        } catch {
            err => {
                log::error #("Scene", "Failed to call compose shader", err);                
            }
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          NODE ATTACHEMENT/REMOVING          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Attach a node in the rendering scene
     * */
    pub fn registerNode (mut self, dmut node : &Node) atomic self {
        self._tree:.register (alias node);            
    }

    /**
     * Detach a node from the rendering scene
     * */
    pub fn removeNode (mut self, dmut node : &Node) atomic self {        
        self._tree:.remove (alias node);        
    }

    /**
     * Trigger when the camera is updated
     * */
    pub fn onCameraUpdate (mut self, dmut cam : &Camera) atomic self {
        self._compose:.setCamera (alias cam);
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SHADERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Register a shader reference that will be used to draw a mesh in the scene
     *
     * */
    pub fn registerShaderRef (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D)-> dmut (&RefCount!{&Shader})
        throws BalderError
    {        
        atomic self {
            return self._shaderToNode:.register (shCfg, alias node);
        }                
    }

    /**
     * Remove a shader reference when a node is detached from the scene
     * */
    pub fn freeShaderRef (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D) {
        atomic self {
            self._shaderToNode:.release (shCfg, alias node);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          MATERIALS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a material to be used in the composition shader
     * */
    pub fn registerMaterialRef (mut self, mat : MaterialConfig)-> u32
        throws BalderError
    {
        self._shaderToNode.materials:.register (mat)
    }

    /**
     * Free a reference to a material
     * */
    pub fn freeMaterialRef (mut self, mat : u32) {
        self._shaderToNode.materials:.release (mat)        
    }    


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          LIGHTS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a light in the composition shader
     * */
    pub fn registerLight (mut self, dmut light : &Light) {
        match light.type {
            LightType::DIRECTION => {
                self._shaderToNode.directionLights:.register (alias light);
                if light.castShadow {
                    self:.addShadowPass (light);
                }                    
                
            }
            LightType::POINT => {
                self._shaderToNode.pointLights:.register (alias light);
            }
            LightType::SPOT => {
                self._shaderToNode.spotLights:.register (alias light);
            }
        }
    }

    /**
     * Update the value of the light at index 'id'
     * */
    pub fn updateLight (mut self, dmut light : &Light) {
        match light.type {
            LightType::DIRECTION => {
                self._shaderToNode.directionLights:.update (alias light);
            }
            LightType::POINT => {
                self._shaderToNode.pointLights:.update (alias light);
            }
            LightType::SPOT => {
                self._shaderToNode.spotLights:.update (alias light);
            }
        }                
    }

    /**
     * Free a reference to a light
     * */
    pub fn freeLight (mut self, dmut light : &Light) {
        match light.type {
            LightType::DIRECTION => {
                self._shaderToNode.directionLights:.release (alias light);
                if light.castShadow {
                    self:.removeShadowPass (light);
                }                    
            }
            LightType::POINT => {
                self._shaderToNode.pointLights:.release (alias light);
            }
            LightType::SPOT => {
                self._shaderToNode.spotLights:.release (alias light);
            }
        }                                
    }


    /**
     * Add a shadow pass to the 
     * */
    fn addShadowPass (mut self, light : &Light) {
        light;
    }

    fn removeShadowPass (mut self, light : &Light) {
        light;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TICKS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Emit the update signal on inner nodes
     * */
    pub fn onTick (mut self, delta : Duration) {
        self._tree:.onTick (delta);        
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            log::debug #("Scene", "dispose scene");
                    
            self._tree:.dispose ();                                            
            self._shaderToNode:.dispose ();
            
            self._deferred:.dispose ();
            self._compose:.dispose ();
            
        }

    }


}
