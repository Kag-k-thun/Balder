in scene;

pub mod ::node;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_};
use balder::scene::node::node3D::visual;

use balder::utils::_;

use std::fs::path;


@final
pub class Scene {

    prot {
        // The window to which the scene is attached
        let dmut _window : &Window;

        // The subpass generating the final scene image
        let dmut _vk : (&VulkanSubpass)? = none;

        // The texture in which the scene is drawn
        let dmut _subpassTextures : [&Texture] = [];

        // The reference to the color texture
        let dmut _color : (&RefCount!{&Texture})? = none;

        // The reference to the depth texture
        let dmut _depth : (&RefCount!{&Texture})? = none;

        // The name of the scene
        let _name : [c8];

        // The width of the generated texture
        let mut _width : u32 = 0;

        // The height of the generated texture
        let mut _height : u32 = 0;

        // The name of the pass
        let mut _passName : [c8] = "";

        // The current subpass id for pass recreation
        let mut _id : usize = 0;

    }

    prot {
        // The list of shaders loaded by the 3D scene
        let dmut _shaders : [[c8] => &RefCount!{&Shader}] = copy [];

        // The shader to mesh association
        let dmut _nodeAssoc : [[c8] => [usize => &VisualInstance3D]] = copy [];

        // The list of meshes casting shadow
        let dmut _shadowMeshes : [usize => &VisualInstance3D] = copy [];

        // The uniq id of the attached visual instances attached to the scene
        let dmut _uniqInstanceIds : usize = 1us;
    }

    prot {
        // The root node of the scene
        let dmut _rootNode : &Node = copy Node ("");

        // The list of nodes in the scene (flattened out)
        let dmut _nodes : [Path => &Node] = copy [];

        // The list of node loaded during drawing phase
        let dmut _nodeToDraw : [[c8] => [usize => &VisualInstance3D]] = copy [];
    }

    prot { // Shadow pass

        // The shadow pass
        let dmut _shadowVK : (&VulkanSubpass)? = none;

        // The shader drawing shadows
        let dmut _shadowShader : (&RefCount!{&Shader})? = none;

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new scene
     * */
    pub self (dmut window : &Window, name : [c8], width : u32, height : u32)
        with _window = alias window
        , _name = name

        throws BalderError
    {
        self:.setDimension (width, height);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the scene and load the basic shaders, and subpasses
     * */
    fn configure (mut self)
        throws BalderError
    {
        if self._height != 0 && self._width != 0 {
            let dmut device = self._window:.getVulkanDevice ();
            let dmut color = copy ColorTexture (alias device, device.getSwapchainFormat (), self._width, self._height, forSubpass-> true);
            let dmut depth = copy DepthTexture (alias device, device.getDepthFormat (), self._width, self._height, forSubpass-> true);

            self._subpassTextures = copy [alias color, alias depth];

            self._color = (alias self._window:.insertResource (alias color))?;
            self._depth = (alias self._window:.insertResource (alias depth))?;

            let dmut _vk_ = copy VulkanSubpass (alias device, self._width, self._height, self._subpassTextures);

            self._id += 1;
            {
                self._passName = std::format::format ("scene_{}_{}", self._name, self._id);
            } catch {
                err => {
                    throw copy BalderError ("Failed to create subpass " ~ err.msg);
                }
            }

            self._window:.addSubpass (name-> self._passName,
                                      loadPhase-> &self:.loadPhase,
                                      drawPhase-> &self:.drawPhase,
                                      cleanPhase-> &self:.cleanPhase,
                                      alias _vk_);
            self._vk = (alias _vk_)?;
        }

    }

    /**
     * Change the dimension of the rendered scene
     * */
    pub fn setDimension (mut self, width : u32, height : u32)
        throws BalderError
    {
        if self._width != width || self._height != height {
            self._width = width;
            self._height = height;

            self:.dispose ();
            self:.configure ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the root node of the scene
     * */
    pub fn getRootNode (mut self)-> dmut &Node {
        alias self._rootNode
    }

    /**
     * @returns: the generated color texture of the scene
     * */
    pub fn getColorTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._color
    }

    /**
     * @returns: the generated depth texture of the scene
     * */
    pub fn getDepthTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._depth
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the indirect command buffer to draw the correct number of triangles
     * */
    fn loadPhase (mut self, dmut cmd : &IndirectCommandAllocator) atomic self {
        for sh, dmut c in alias self._nodeAssoc {
            let dmut lst : [usize => &VisualInstance3D] = copy [];
            for u, dmut v in alias c {
                v:.register (alias cmd);
                lst [u] = alias v;
            }

            self._nodeToDraw [sh] = alias lst;
        }
    }

    /**
     * Draw the visual instances on the output compose texture
     * */
    fn drawPhase (mut self, dmut cmd : &IndirectCommandAllocator) atomic self {
        for s, lst in self._nodeToDraw {
            if let Ok (dmut shO) = alias self._shaders [s] {
                let dmut sh = alias shO:.get ();
                sh.select ();
                for _, c in lst {
                    c.draw (alias sh, alias cmd);
                }
            } catch {
                err => {
                    log::error #("Scene", "Failed to use shader :", s, " ", err);
                }
            }
        }
    }


    fn cleanPhase (mut self) atomic self {
        for _, dmut lst in alias self._nodeToDraw {
            for _, dmut c in alias lst {
                c:.clean ();
            }
        }

        self._nodeToDraw = copy [];
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          NODE ATTACHEMENT/REMOVING          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Attach a node in the rendering scene
     * */
    pub fn attach (mut self, dmut node : &Node) atomic self {
        self._nodes [node.getName ()] = alias node;

        if let Ok (dmut sub) = alias self._vk {
            if let dmut vi : &VisualInstance3D = alias node {
                let dmut uid = self._uniqInstanceIds;
                vi:.setUID (uid);

                self._uniqInstanceIds += 1;

                if vi.castShadow () {
                    self._shadowMeshes [uid] = alias vi;
                }

                let shCfg = vi.material.shaderConfig;
                {
                    if shCfg.name !in self._shaders {
                        let dmut shader = self._window:.loadResource!{&RasterShader} (shCfg.name,
                                                                                      shCfg,
                                                                                      sub.getRenderPass (),
                                                                                      sub.getDimension ()._0,
                                                                                      sub.getDimension ()._1);

                        self._shaders [shCfg.name] = alias shader;
                        vi:.attach (alias shader:.get ());
                    }

                    else if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                        vi:.attach (alias sh:.get ());
                    }

                    if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                        inner [uid] = alias vi;
                    } else {
                        self._nodeAssoc [shCfg.name] = copy [uid => alias vi];
                    }
                } catch {
                    err => {
                        log::error#("Scene", "failed to attach visual instance ", err);
                        self._nodes:.remove (node.getName ());
                    }
                }
            }

            if self._shadowMeshes.len != 0 {
                self:.registerShadowPass ();
            }

            self._window:.redraw ();
        }
    }

    /**
     * Detach a node from the rendering scene
     * */
    pub fn detach (mut self, dmut node : &Node) atomic self {
        self._nodes:.remove (node.getName ());

        if let dmut vi : &VisualInstance3D = alias node {
            let shCfg = vi.material.shaderConfig;

            self._shadowMeshes:.remove (vi.uid);
            if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                inner:.remove (vi.uid);
                if inner.len == 0us {
                    if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                        sh:.dispose ();
                        self._shaders:.remove (shCfg.name);
                    }

                    self._nodeAssoc:.remove (shCfg.name);
                }
            }
        }

        node:.dispose ();
        if self._shadowMeshes.len == 0 {
            self:.removeShadowPass ();
        }

        self._window:.redraw ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          SHADOW PASS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn registerShadowPass (mut self) {
        log::error #("Scene", "TODO");
    }

    fn removeShadowPass (mut self) {
        log::error #("Scene", "TODO");
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            if let Ok (dmut sub) = alias self._vk {
                self._window:.removeSubpass (name-> self._passName)?;
                self._window:.insertBin (alias sub);
                self._vk = none;
            }

            if let Ok (dmut cl) = alias self._color {
                cl:.dispose ();
                self._color = none;
            }

            if let Ok (dmut dp) = alias self._depth {
                dp:.dispose ();
                self._depth = none;
            }

            self._subpassTextures = [];
        }

    }


}
