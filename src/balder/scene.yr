in scene;

pub mod ::node;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::scene::node::node3D::{camera, visual};

use balder::utils::_;

use std::fs::path;
use ::std::time::_;

use std::io;

use ::vulkan::core;

/**
 * Record holding the information of the camera on the scene
 * */
record CameraScene {
    pub let dmut camera : (&Camera)? = none;            
    pub let dmut aspectChanged : &Signal!{u32, u32} = copy Signal!{u32, u32} ();
    pub let mut aspectWidth : u32 = 0;
    pub let mut aspectHeight : u32 = 0;
    pub self () {}
}

/**
 * Record holding the shaders loaded by the scene and associating them to nodes to draw
 * */
record ShaderNodeScene {    
    pub let dmut shaders : [[c8] => &RefCount!{&Shader}] = copy [];
    pub let dmut shadowShader : (&RefCount!{&Shader})? = none;
    
    pub let dmut nodeAssoc : [[c8] => [usize => &VisualInstance3D]] = copy [];
    pub let dmut shadowMeshes : [usize => &VisualInstance3D] = copy [];    

    pub let dmut uniqInstanceIds : usize = 1us;
    
    pub self () {}
}

/**
 * The node tree of the scene
 * */
record NodeTreeScene {
    pub let dmut rootNode : (&Node)? = none;
    pub let dmut nodes : [usize => &Node] = copy [];
    pub self () {}
}


/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          DEFERRED PASS          ==================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * The record holding the data of the deferred textures and subpass
 * */
record DeferredRenderScene {
    pub let dmut position : (&RefCount!{&Texture})? = none;    
    pub let dmut normal : (&RefCount!{&Texture})? = none;
    pub let dmut binormal : (&RefCount!{&Texture})? = none;    
    pub let dmut albedo : (&RefCount!{&Texture})? = none;
    pub let dmut materialID : (&RefCount!{&Texture})? = none;    
    pub let dmut depth : (&RefCount!{&Texture})? = none;
    
    pub let dmut subpassTextures : [&OutputTexture] = [];
    pub let dmut pass : (&DrawSubpass)? = none;
    
    pub self () {}

    pub fn configure (mut self, passName : [c8], dmut win : &Window, width : u32, height : u32)-> dmut &DrawSubpass
        throws BalderError
    {                
        let dmut device = win:.getVulkanDevice ();
        
        let dmut position = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, width, height);        
        let dmut normal = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, width, height);
        let dmut binormal = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, width, height);
        let dmut albedo = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R8G8B8A8_UNORM, width, height);
        let dmut materialID = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R32_UINT, width, height);
        let dmut depth = copy OutputTexture (alias device, device.getDepthFormat (), width, height, depth-> true);
        
        self.subpassTextures = copy [alias position,                                     
                                     alias normal,
                                     alias binormal,
                                     alias albedo,
                                     alias materialID,
                                     alias depth];

        self.position = (alias win:.insertResource (alias position))?;
        self.depth = (alias win:.insertResource (alias depth))?;
        self.normal = (alias win:.insertResource (alias normal))?;
        self.binormal = (alias win:.insertResource (alias binormal))?;
        self.albedo = (alias win:.insertResource (alias albedo))?;
        self.materialID = (alias win:.insertResource (alias materialID))?;

        let dmut pass = copy DrawSubpass::toTextures (alias device, width, height, self.subpassTextures);
        self.pass = (alias pass)?;

        {            
            let dmut pipeline = win:.getVulkanPipeline ();        
            pipeline:.registerSubPass (passName, alias pass);            
        } catch {
            err => {
                log::error #("Scene", "Failed to register deferred subpass", err);                
            }
        }

        alias pass
    }

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut pass) = alias self.pass {
                pass:.dispose ();
                self.pass = none;
            }
            
            if let Ok (dmut cl) = alias self.position {
                cl:.dispose ();
                self.position = none;
            }

            if let Ok (dmut cl) = alias self.normal {
                cl:.dispose ();
                self.normal = none;
            }
            
            if let Ok (dmut cl) = alias self.binormal {
                cl:.dispose ();
                self.binormal = none;
            }

            if let Ok (dmut cl) = alias self.albedo {
                cl:.dispose ();
                self.albedo = none;
            }

            if let Ok (dmut cl) = alias self.materialID {
                cl:.dispose ();
                self.materialID = none;
            }

            if let Ok (dmut dp) = alias self.depth {
                dp:.dispose ();
                self.depth = none;
            }            
            
            self.subpassTextures = [];
        }    
    }    
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ==================================          COMPOSE PASS          ==================================
 * ====================================================================================================
 * ====================================================================================================
 */

record ComposeRenderScene {
    pub let dmut output : (&RefCount!{&Texture})? = none;
    pub let dmut shader : (&RefCount!{&Shader})? = none;
    // pub let dmut pass : (&ComputePass)? = none;

    pub self () {}

    pub fn configure (mut self, dmut win : &Window, width : u32, height : u32)
        throws BalderError
    {
        let dmut device = alias win:.getVulkanDevice ();
        
        let dmut output = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R8G8B8A8_UNORM, width, height);
        self.output = (alias win:.insertResource (alias output))?;
        
        let dmut shader = win:.loadResource!{&ComputeShader} (DefaultShaders::COMPOSE_3D);
        self.shader = (alias shader)?;
    }

    impl Disposable {
        pub over dispose (mut self) {            
            // if let Ok (dmut pass) = alias self.pass {
            //     pass:.dispose ();
            //     self.pass = none;
            // }
            
            if let Ok (dmut output) = alias self.output {
                output:.dispose ();
                self.output = none;
            }

            if let Ok (dmut shader) = alias self.shader {
                shader:.dispose ();
                self.shader = none;
            }
            
        }
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          SCENE          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * A scene manage objects in a 3D environment
 * It has a camera, lights, and a tree of nodes
 * It manages the composing pipeline
 * */
@final
pub class Scene {
    
    // The window to which the scene is attached
    let dmut _window : &Window;

    // The name of the scene
    let _name : [c8];

    // The width of the generated texture
    let mut _width : u32 = 0;

    // The height of the generated texture
    let mut _height : u32 = 0;

    // The slot emitter, used to trigger signals from scene events
    let dmut _box : &SlotEmitter = copy SlotEmitter ();

    // The camera filming the scene
    let dmut _camera : CameraScene = CameraScene ();

    // The association of shaders to loaded nodes
    let dmut _shaderToNode : ShaderNodeScene = ShaderNodeScene ();    

    // The node tree hierarchy of the node
    let dmut _tree : NodeTreeScene = NodeTreeScene ();

    // The deferred rendering textures and subpass
    let dmut _deferred : DeferredRenderScene = DeferredRenderScene ();

    // The compose rendering textures and subpasses
    let dmut _compose : ComposeRenderScene = ComposeRenderScene ();
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new scene (not configured)
     * */
    pub self (dmut window : &Window, name : [c8])
        with _window = alias window
        , _name = name        
    {        
        self._tree.rootNode = (copy root::RootNode (alias self))?;
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the scene and load the basic shaders, and subpasses
     * */
    pub fn configure (mut self, width : u32, height : u32)
        throws BalderError
    {
        self:.dispose ();
        
        if height != 0 && width != 0 {
            self._width = width;
            self._height = height;
            
            let dmut pipeline = self._window:.getVulkanPipeline ();
            let dname = "deferred_" ~ self._name;
            // let cname = "compose_" ~ self._name;
            
            let dmut dpass = self._deferred:.configure (dname, alias self._window, self._width, self._height);
            dpass:.onDraw ():.connect (&self:.onDeferredDraw);
            
            // let dmut cpass = self._compose.configure (alias self._window, self._width, self._height);
            //
            // pipeline:.setPassOutput (dname, cname);

            pipeline:.setPassOutputToSwap (dname);
            
            self:.setAspect (width, height);
        }
    }

    /**
     * Change the rendering aspect of the scene, without recomputing the rendering textures
     * */
    pub fn setAspect (mut self, width : u32, height : u32) {
        self._camera.aspectHeight = height;
        self._camera.aspectWidth = width;

        self._camera.aspectChanged:.emit (width, height);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the root node of the scene
     * */
    pub fn getRootNode (mut self)-> dmut &Node {
        if let Ok (dmut r) = alias self._tree.rootNode {
            return alias r;
        }

        let dmut res = copy root::RootNode (alias self);
        self._tree.rootNode = (alias res)?;

        alias res
    }

    /**
     * The size of the rendering textures
     * */
    @field
    pub fn width (self)-> u32 {
        self._width
    }

    /**
     * The size of the rendering textures
     * */
    @field
    pub fn height (self)-> u32 {
        self._height
    }

    /**
     * The size of the scene on screen
     * */
    @field
    pub fn aspectWidth (self)-> u32 {
        self._camera.aspectWidth
    }

    /**
     * The size of the scene on screen
     * */
    @field
    pub fn aspectHeight (self)-> u32 {
        self._camera.aspectHeight
    }

    /**
     * @returns: the signal emitted when the size of the scene changes on screen (does not change rendering texture sizes)
     * */
    pub fn aspectChanged (mut self)-> dmut &Signal!{u32, u32} {
        alias self._camera.aspectChanged
    }

    /**
     * @returns: the camera of the scene if there is one camera set in the tree of nodes
     * */
    pub fn getCamera (mut self)-> dmut (&Camera)? {
        alias self._camera.camera
    }

    /**
     * @returns: the window on which the scene is rendered
     * */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the window on which the scene is rendered
     * */
    pub fn getWindow (self)-> &Window {
        self._window
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXTURE RESULTS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the generated position texture of the scene
     * */
    pub fn getPositionTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._deferred.position
    }

    /**
     * @returns: the generated albedo texture of the scene
     * */
    pub fn getAlbedoTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._deferred.albedo
    }

    /**
     * @returns: the generated material ID texture of the scene
     * */
    pub fn getMaterialIDTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._deferred.materialID
    }

    /**
     * @returns: the generated normal texture of the scene
     * */
    pub fn getNormalTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._deferred.normal
    }

    /**
     * @returns: the generated binormal texture of the scene
     * */
    pub fn getBinormalTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._deferred.binormal
    }

    /**
     * @returns: the generated depth texture of the scene
     * */
    pub fn getDepthTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._deferred.depth
    }

    /**
     * @returns: the generated output texture (composition) of the scene
     * */
    pub fn getOutputTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._compose.output
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn onDeferredDraw (mut self) {
        log::debug #("Scene", "Drawing deferred pass scene");
        if !self._camera.camera.hasValue { // nothing to draw if there is no camera
            return;
        }
        
        if let Ok (dmut subpass) = alias self._deferred.pass {        
            let dmut cmd = subpass:.createCommandAllocator!{&IndexedDrawCommandAllocator} ();
            atomic self {
                for _, dmut c in alias self._shaderToNode.nodeAssoc {
                    for _, dmut v in alias c { v:.register (alias cmd); }
                }

                {
                    cmd:.finalizeRegister ();
                } catch {
                    err => {
                        log::error #("Scene", "Failed to register nodes to draw", err);
                        return;
                    }
                }

                {
                    for shName, dmut c in alias self._shaderToNode.nodeAssoc {
                        if let Ok (dmut shO) = alias self._shaderToNode.shaders [shName] {
                            let dmut sh = shO:.get ();
                            sh.select (cmd.getCommandBuffer ());
                            
                            for _, v in c { v.draw (alias sh, alias cmd); }
                        }
                    }
                } catch {
                    err => {
                        log::error #("Scene", "Failed to get shaders", err);                        
                    }
                }
            }
        } else {
            log::error #("Scene", "Malformed deferred subpass");
        }        
    }        
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          COMPOSE SHADER LOOP          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn onComposeCall (mut self) {
        log::debug #("Scene", "Calling compose compute shader");
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          NODE ATTACHEMENT/REMOVING          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Attach a node in the rendering scene
     * */
    pub fn registerNode (mut self, dmut node : &Node) atomic self {
        if let Ok (dmut n) = alias self._tree.nodes [node.uid] {
            n:.onExit (alias self);
        }

        self._tree.nodes [node.uid] = alias node;
        node:.onEnter (alias self);

        if let dmut ca : &Camera = alias node {
            if let Ok (ica) = self._camera.camera && ica !is ca {
                log::error #("Scene", "scene has multiple cameras");
            } else {
                self:.onSetCamera (alias ca);
            }
        } else {
            if let dmut vis : &VisualInstance3D = alias node {
                if let Ok (dmut cam) = alias self._camera.camera {
                    vis:.setCamera (alias cam);
                }
            }
        }

        self._window:.redrawPipeline ();
    }

    /**
     * Detach a node from the rendering scene
     * */
    pub fn removeNode (mut self, dmut node : &Node) atomic self {
        if let Ok (dmut n) = alias self._tree.nodes [node.uid] {
            self._tree.nodes:.remove (node.uid);

            if let dmut ca : &Camera = alias node {
                if let Ok (ica) = self._camera.camera && ica is ca {
                    self:.onRemoveCamera ();
                }
            } else {
                n:.onExit (alias self);
            }

            self._window:.redrawPipeline ();
        }
    }

    /**
     * Set the camera of the scene, and apply it to every drawable nodes in the scene
     * */
    fn onSetCamera (mut self, dmut cam : &Camera) {
        self._camera.camera = (alias cam)?;

        for _, dmut n in alias self._tree.nodes {
            if let dmut vis : &VisualInstance3D = alias n {
                vis:.setCamera (alias cam);
            }
        }
    }

    /**
     * Remove the camera of the scene
     * */
    fn onRemoveCamera (mut self) {
        if let Ok (dmut cam) = alias self._camera.camera {
            self._tree.nodes:.remove (cam.uid);

            self._camera.camera = none;
            cam:.onExit (alias self);

            for _, dmut n in alias self._tree.nodes {
                if let dmut vis : &VisualInstance3D = alias n {
                    vis:.removeCamera ();
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          BUFFER RECOMPUTATION          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a shader reference that will be used to draw a mesh in the scene
     *
     * */
    pub fn registerShaderRef (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D)-> dmut (&RefCount!{&Shader})
        throws BalderError
    {
        shCfg;
        
        atomic self {
            let dmut uid = self._shaderToNode.uniqInstanceIds;
            node:.setUID (uid);

            self._shaderToNode.uniqInstanceIds += 1;

            if let Ok (dmut sub) = alias self._deferred.pass {
                {
                    let dmut shader = if let Ok (dmut sh) = alias self._shaderToNode.shaders [shCfg.name] {
                        alias sh
                    } else {
                        let dmut shader = self._window:.loadResource!{&RasterShader} (shCfg.name,
                                                                                      shCfg,
                                                                                      sub.getRenderPass (),
                                                                                      sub.getDimension ()._0,
                                                                                      sub.getDimension ()._1,
                                                                                      self._deferred.subpassTextures);

                        self._shaderToNode.shaders [shCfg.name] = alias shader;
                        alias shader
                    };

                    if let Ok (dmut inner) = alias self._shaderToNode.nodeAssoc [shCfg.name] {
                        inner [uid] = alias node;
                    } else {
                        self._shaderToNode.nodeAssoc [shCfg.name] = copy [uid => alias node];
                    }

                    return alias shader;
                } catch {
                    err => {
                        log::error#("Scene", "failed to attach visual instance ", err);
                        if let Ok (dmut inner) = alias self._shaderToNode.nodeAssoc [shCfg.name] {
                            inner:.remove (uid);
                        }
                    }
                }
            }
        }

        throw copy BalderError ("Failed to register shader reference");
    }

    /**
     * Remove a shader reference when a node is detached from the scene
     * */
    pub fn freeShaderRef (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D) {
        atomic self {
            if let Ok (dmut inner) = alias self._shaderToNode.nodeAssoc [shCfg.name] {
                inner:.remove (node.uid);

                if inner.len == 0us {
                    if let Ok (dmut sh) = alias self._shaderToNode.shaders [shCfg.name] {
                        sh:.dispose ();
                        self._shaderToNode.shaders:.remove (shCfg.name);
                    }

                    self._shaderToNode.nodeAssoc:.remove (shCfg.name);
                }
            }
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TICKS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Emit the update signal on inner nodes
     * */
    pub fn onTick (mut self, delta : Duration) {
        for _, dmut t in alias self._tree.nodes {
            t:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            log::debug #("Scene", "dispose scene");
            
            self:.onRemoveCamera ();

            for _, dmut n in alias self._tree.nodes {
                n:.onExit (alias self);
            }
            self._tree.nodes = copy [];            
            
            if let Ok (dmut r) = alias self._tree.rootNode {
                r:.dispose ();
                self._tree.rootNode = none;
            }
            
            self._deferred:.dispose ();
            self._compose:.dispose ();
            
        }

    }


}
