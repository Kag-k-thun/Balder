in scene;

pub mod ::node;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::scene::node::node3D::{camera, visual};

use balder::utils::_;

use std::fs::path;
use ::std::time::_;

use std::io;

use ::vulkan::core;

@final
pub class Scene {

    prot {
        // The window to which the scene is attached
        let dmut _window : &Window;

        // The subpass generating the final scene image
        let dmut _vk : (&VulkanSubpass)? = none;

        // The texture in which the scene is drawn
        let dmut _subpassTextures : [&OutputTexture] = [];

        // The name of the scene
        let _name : [c8];

        // The width of the generated texture
        let mut _width : u32 = 0;

        // The height of the generated texture
        let mut _height : u32 = 0;

        // The name of the pass
        let mut _passName : [c8] = "";

        // The current subpass id for pass recreation
        let mut _id : usize = 0;

    }

    prot {
        // The list of shaders loaded by the 3D scene
        let dmut _shaders : [[c8] => &RefCount!{&Shader}] = copy [];

        // The shader to mesh association
        let dmut _nodeAssoc : [[c8] => [usize => &VisualInstance3D]] = copy [];

        // The list of meshes casting shadow
        let dmut _shadowMeshes : [usize => &VisualInstance3D] = copy [];

        // The uniq id of the attached visual instances attached to the scene
        let dmut _uniqInstanceIds : usize = 1us;
    }

    prot {
        // The root node of the scene
        let dmut _rootNode : (&Node)? = none;

        // The list of node loaded during drawing phase
        let dmut _nodeToDraw : [[c8] => [usize => &VisualInstance3D]] = copy [];

        // The list of nodes in the scene (flattened out)
        let dmut _nodes : [usize => &Node] = copy [];
    }

    prot { // Shadow pass

        // The shadow pass
        let dmut _shadowVK : (&VulkanSubpass)? = none;

        // The shader drawing shadows
        let dmut _shadowShader : (&RefCount!{&Shader})? = none;

    }

    prot { // Compose pass
        
        // The compute shader used to render the final composition
        let dmut _composeShader : (&RefCount!{&Shader})? = none;
    }
    
    prot { // camera

        let dmut _camera : (&Camera)? = none;

        // Signal emited when aspect of the scene changes
        let dmut _aspectChanged : &Signal!{u32, u32} = copy Signal!{u32, u32} ();

        let mut _aspectWidth : u32 = 0;

        let mut _aspectHeight : u32 = 0;

        // The slot emitter, used to trigger signals from scene events
        let dmut _box : &SlotEmitter = copy SlotEmitter ();
    }

    prot { // Deferred textures

        // The reference to the position texture
        let dmut _position : (&RefCount!{&Texture})? = none;

        // The reference to the normal texture
        let dmut _normal : (&RefCount!{&Texture})? = none;

        // The reference to the albedo texture
        let dmut _albedo : (&RefCount!{&Texture})? = none;

        // The reference to the material index texture
        let dmut _materialID : (&RefCount!{&Texture})? = none;
        
        // The reference to the depth texture
        let dmut _depth : (&RefCount!{&Texture})? = none;

        // The texture in wich the final scene is composed
        let dmut _output : (&RefCount!{&Texture})? = none;
        
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new scene
     * */
    pub self (dmut window : &Window, name : [c8], width : u32, height : u32)
        with _window = alias window
        , _name = name
        , _aspectWidth = width
        , _aspectHeight = height

        throws BalderError
    {
        self:.setDimension (width, height);
        self._rootNode = (copy root::RootNode (alias self))?;
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the scene and load the basic shaders, and subpasses
     * */
    fn configure (mut self)
        throws BalderError
    {
        if self._height != 0 && self._width != 0 {
            let dmut device = self._window:.getVulkanDevice ();
            self:.registerComposeShader ();
            
            let dmut position = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, self._width, self._height);
            let dmut normals = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, self._width, self._height);
            let dmut albedo = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R8G8B8A8_UNORM, self._width, self._height);
            let dmut materialID = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R32_UINT, self._width, self._height);
            let dmut depth = copy OutputTexture (alias device, device.getDepthFormat (), self._width, self._height, depth-> true);

            let dmut compose = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, self._width, self._height);
            
            self._subpassTextures = copy [alias position,
                                          alias normals,
                                          alias albedo,
                                          alias materialID,
                                          alias depth];

            self._position = (alias self._window:.insertResource (alias position))?;
            self._depth = (alias self._window:.insertResource (alias depth))?;
            self._normal = (alias self._window:.insertResource (alias normals))?;
            self._albedo = (alias self._window:.insertResource (alias albedo))?;
            self._materialID = (alias self._window:.insertResource (alias materialID))?;
            self._output = (alias self._window:.insertResource (alias compose))?;
            
            let dmut _vk_ = copy VulkanSubpass (alias device, self._width, self._height, self._subpassTextures);
            self._id += 1;
            {
                self._passName = std::format::format ("scene_{}_{}", self._name, self._id);
            } catch {
                err => {
                    throw copy BalderError ("Failed to create subpass " ~ err.msg);
                }
            }

            self._window:.addSubpass (name-> self._passName,
                                      loadPhase-> &self:.loadPhase,
                                      drawPhase-> &self:.drawPhase,
                                      cleanPhase-> &self:.cleanPhase,
                                      alias _vk_);


            // let dmut _vkC_ = copy VulkanComputeSubpass (alias device, compose);
            // self._window:.addComputeSubpass (name-> self._passName ~ "_c", compute-> &self:.composePhase);
            // self._window:.addSubpassDependency (self._passName ~ "_c", self._passName);
            
            self._vk = (alias _vk_)?;
            // self._vkC = (alias _vkC_)?;
        }

    }

    /**
     * Change the dimension of the rendered scene
     * */
    pub fn setDimension (mut self, width : u32, height : u32)
        throws BalderError
    {
        if self._width != width || self._height != height {
            self._width = width;
            self._height = height;

            self:.dispose ();
            self:.configure ();
        }
    }

    /**
     * Change the rendering aspect of the scene, without recomputing the rendering textures
     * */
    pub fn setAspect (mut self, width : u32, height : u32) {
        self._aspectHeight = height;
        self._aspectWidth = width;

        self._aspectChanged:.emit (width, height);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the root node of the scene
     * */
    pub fn getRootNode (mut self)-> dmut &Node {
        if let Ok (dmut r) = alias self._rootNode {
            return alias r;
        }

        let dmut res = copy root::RootNode (alias self);
        self._rootNode = (alias res)?;

        alias res
    }

    /**
     * The size of the rendering textures
     * */
    @field
    pub fn width (self)-> u32 {
        self._width
    }

    /**
     * The size of the rendering textures
     * */
    @field
    pub fn height (self)-> u32 {
        self._height
    }

    /**
     * The size of the scene on screen
     * */
    @field
    pub fn aspectWidth (self)-> u32 {
        self._aspectWidth
    }

    /**
     * The size of the scene on screen
     * */
    @field
    pub fn aspectHeight (self)-> u32 {
        self._aspectHeight
    }

    /**
     * @returns: the signal emitted when the size of the scene changes on screen (does not change rendering texture sizes)
     * */
    pub fn aspectChanged (mut self)-> dmut &Signal!{u32, u32} {
        alias self._aspectChanged
    }

    /**
     * @returns: the camera of the scene if there is one camera set in the tree of nodes
     * */
    pub fn getCamera (mut self)-> dmut (&Camera)? {
        alias self._camera
    }

    /**
     * @returns: the window on which the scene is rendered
     * */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the window on which the scene is rendered
     * */
    pub fn getWindow (self)-> &Window {
        self._window
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXTURE RESULTS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the generated position texture of the scene
     * */
    pub fn getPositionTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._position
    }

    /**
     * @returns: the generated albedo texture of the scene
     * */
    pub fn getAlbedoTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._albedo
    }

    /**
     * @returns: the generated material ID texture of the scene
     * */
    pub fn getMaterialIDTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._materialID
    }

    /**
     * @returns: the generated normal texture of the scene
     * */
    pub fn getNormalTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._normal
    }

    /**
     * @returns: the generated depth texture of the scene
     * */
    pub fn getDepthTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._depth
    }

    /**
     * @returns: the generated output texture (composition) of the scene
     * */
    pub fn getOutputTexture (mut self)-> dmut (&RefCount!{&Texture})? {
        alias self._output
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the indirect command buffer to draw the correct number of triangles
     * */
    fn loadPhase (mut self, dmut cmd : &IndexedDrawCommandAllocator) atomic self {
        if !self._camera.hasValue { // nothing to draw if there is no camera
            return;
        }

        for sh, dmut c in alias self._nodeAssoc {
            let dmut lst : [usize => &VisualInstance3D] = copy [];
            for u, dmut v in alias c {
                v:.register (alias cmd);
                lst [u] = alias v;
            }

            self._nodeToDraw [sh] = alias lst;
        }
    }

    /**
     * Draw the visual instances on the output compose texture
     * */
    fn drawPhase (mut self, dmut cmd : &IndexedDrawCommandAllocator) atomic self {
        for s, lst in self._nodeToDraw {
            if let Ok (dmut shO) = alias self._shaders [s] {
                let dmut sh = alias shO:.get ();
                sh.select ();
                for _, c in lst {
                    c.draw (alias sh, alias cmd);
                }
            } catch {
                err => {
                    log::error #("Scene", "Failed to use shader :", s, " ", err);
                }
            }
        }
    }

    fn cleanPhase (mut self) atomic self {
        for _, dmut lst in alias self._nodeToDraw {
            for _, dmut c in alias lst {
                c:.clean ();
            }
        }

        self._nodeToDraw = copy [];
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          NODE ATTACHEMENT/REMOVING          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Attach a node in the rendering scene
     * */
    pub fn registerNode (mut self, dmut node : &Node) atomic self {
        if let Ok (dmut n) = alias self._nodes [node.uid] {
            n:.onExit (alias self);
        }

        self._nodes [node.uid] = alias node;
        node:.onEnter (alias self);

        if let dmut ca : &Camera = alias node {
            if let Ok (ica) = self._camera && ica !is ca {
                log::error #("Scene", "scene has multiple cameras");
            } else {
                self:.onSetCamera (alias ca);
            }
        } else {
            if let dmut vis : &VisualInstance3D = alias node {
                if let Ok (dmut cam) = alias self._camera {
                    vis:.setCamera (alias cam);
                }
            }
        }

        self._window:.redraw ();
    }

    /**
     * Detach a node from the rendering scene
     * */
    pub fn removeNode (mut self, dmut node : &Node) atomic self {
        if let Ok (dmut n) = alias self._nodes [node.uid] {
            self._nodes:.remove (node.uid);

            if let dmut ca : &Camera = alias node {
                if let Ok (ica) = self._camera && ica is ca {
                    self:.onRemoveCamera ();
                }
            } else {
                n:.onExit (alias self);
            }

            self._window:.redraw ();
        }
    }

    /**
     * Set the camera of the scene, and apply it to every drawable nodes in the scene
     * */
    fn onSetCamera (mut self, dmut cam : &Camera) {
        self._camera = (alias cam)?;

        for _, dmut n in alias self._nodes {
            if let dmut vis : &VisualInstance3D = alias n {
                vis:.setCamera (alias cam);
            }
        }
    }

    /**
     * Remove the camera of the scene
     * */
    fn onRemoveCamera (mut self) {
        if let Ok (dmut cam) = alias self._camera {
            self._nodes:.remove (cam.uid);

            self._camera = none;
            cam:.onExit (alias self);

            for _, dmut n in alias self._nodes {
                if let dmut vis : &VisualInstance3D = alias n {
                    vis:.removeCamera ();
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          BUFFER RECOMPUTATION          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a shader reference that will be used to draw a mesh in the scene
     *
     * */
    pub fn registerShaderRef (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D)-> dmut (&RefCount!{&Shader})
        throws BalderError
    {
        atomic self {
            let dmut uid = self._uniqInstanceIds;
            node:.setUID (uid);

            self._uniqInstanceIds += 1;

            if let Ok (dmut sub) = alias self._vk {
                {
                    let dmut shader = if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                        alias sh
                    } else {
                        let dmut shader = self._window:.loadResource!{&RasterShader} (shCfg.name,
                                                                                      shCfg,
                                                                                      sub.getRenderPass (),
                                                                                      sub.getDimension ()._0,
                                                                                      sub.getDimension ()._1,
                                                                                      self._subpassTextures);

                        self._shaders [shCfg.name] = alias shader;
                        alias shader
                    };

                    if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                        inner [uid] = alias node;
                    } else {
                        self._nodeAssoc [shCfg.name] = copy [uid => alias node];
                    }

                    return alias shader;
                } catch {
                    err => {
                        log::error#("Scene", "failed to attach visual instance ", err);
                        if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                            inner:.remove (uid);
                        }
                    }
                }
            }
        }

        throw copy BalderError ("Failed to register shader reference");
    }

    /**
     * Remove a shader reference when a node is detached from the scene
     * */
    pub fn freeShaderRef (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D) {
        atomic self {
            if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                inner:.remove (node.uid);

                if inner.len == 0us {
                    if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                        sh:.dispose ();
                        self._shaders:.remove (shCfg.name);
                    }

                    self._nodeAssoc:.remove (shCfg.name);
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          SHADOW PASS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn registerShadowPass (mut self) {
        log::error #("Scene", "TODO");
    }

    fn removeShadowPass (mut self) {
        log::error #("Scene", "TODO");
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ============================          CONFIGURE COMPOSE SHADER          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the final composition shader used to render the materials of the deferred shading
     * */
    fn registerComposeShader (mut self)
        throws BalderError
    {
        if let Ok (dmut c) = alias self._composeShader {
            self._window:.insertBin (alias c);
            self._composeShader = none;
        }
        
        let dmut shader = self._window:.loadResource!{&ComputeShader} (DefaultShaders::COMPOSE_3D);
        self._composeShader = (alias shader)?;
    }
    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TICKS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Emit the update signal on inner nodes
     * */
    pub fn onTick (mut self, delta : Duration) {
        for _, dmut t in alias self._nodes {
            t:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            self:.onRemoveCamera ();
            for _, dmut n in alias self._nodes {
                n:.onExit (alias self);
            }
            self._nodes = copy [];

            if let Ok (dmut sub) = alias self._vk {
                self._window:.removeSubpass (name-> self._passName)?;
                self._window:.insertBin (alias sub);
                self._vk = none;
            }

            if let Ok (dmut cl) = alias self._position {
                self._window:.insertBin (alias cl);
                self._position = none;
            }

            if let Ok (dmut cl) = alias self._normal {
                self._window:.insertBin (alias cl);
                self._normal = none;
            }

            if let Ok (dmut cl) = alias self._albedo {
                self._window:.insertBin (alias cl);
                self._albedo = none;
            }

            if let Ok (dmut cl) = alias self._materialID {
                self._window:.insertBin (alias cl);
                self._materialID = none;
            }

            if let Ok (dmut dp) = alias self._depth {
                self._window:.insertBin (alias dp);
                self._depth = none;
            }

            if let Ok (dmut out) = alias self._output {
                self._window:.insertBin (alias out);
                self._output = none;
            }
            
            if let Ok (dmut r) = alias self._rootNode {
                r:.dispose ();
                self._rootNode = none;
            }

            if let Ok (dmut c) = alias self._composeShader {
                self._window:.insertBin (alias c);
                self._composeShader = none;
            }
            
            self._subpassTextures = [];
        }

    }


}
