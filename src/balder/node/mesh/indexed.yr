in indexed;

use balder::core::{_, shader::_, driver::_};
use balder::node::_;
use balder::math::_;

/**
 * Mesh with two buffers, one for vertices, and one for indices
 */
pub class IndexedMesh over Mesh {

    // The buffer containing the indices of the mesh
    let dmut _ibo : &IndexBufferObject;

    // The buffer containing the vertices of the mesh
    let dmut _vbo : &VertexBufferObject;
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    prot self (dmut ibo : &IndexBufferObject, dmut vbo : &VertexBufferObject)
        with _ibo = alias ibo
        , _vbo = alias vbo
    {}

    /**
     * Create a new indexed mesh
     * @params:
     *    - device: the device used to allocate and render the mesh
     *    - indices: the indices of the points forming the mesh
     */
    pub self  (dmut device : &VulkanDevice,
               indices : [u32],
               positions : [vec3],
               normals : [vec3] = [],
               colors : [vec3] = [],
               textureUVs : [vec2] = [])

        with self (copy IndexBufferObject!{u32} (alias device, indices),
                   copy VertexBufferObject (alias device,
                                            cast!u32 (positions.len),
                                            compactVertices (positions-> positions,
                                                             normals-> normals,
                                                             colors-> colors,
                                                             textureUVs-> textureUVs)))
        throws BalderError
    {}


    /**
     * Create a new indexed mesh
     * @params:
     *    - device: the device used to allocate and render the mesh
     *    - indices: the indices of the points forming the mesh
     */
    pub self  (dmut device : &VulkanDevice,
               indices : [u16],
               positions : [vec3],
               normals : [vec3] = [],
               colors : [vec3] = [],
               textureUVs : [vec2] = [])

        with self (copy IndexBufferObject!{u16} (alias device, indices),
                   copy VertexBufferObject (alias device,
                                            cast!u32 (positions.len),
                                            compactVertices (positions-> positions,
                                                             normals-> normals,
                                                             colors-> colors,
                                                             textureUVs-> textureUVs)))
        throws BalderError
    {}

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the mesh using the command allocator
     * @assume: the command allocator is in load mode
     * @params:
     *    - cmd: the command allocator in which the mesh has to be registered
     */
    pub over register (mut self, dmut cmd : &IndirectCommandAllocator) {
        cmd:.registerIndexedObject (self._ibo.getNbPoints ());
    }

    /**
     * Draw the mesh using the command allocator
     * @assume: the command allocator is in draw mode
     * @params:
     *    - cmd: the command allocator in which the mesh has to be drawn
     */
    pub over draw (mut self, dmut cmd : &IndirectCommandAllocator) {
        self._vbo:.select ();
        self._ibo:.select ();

        cmd:.drawNextIndexed ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._vbo:.dispose ();
            self._ibo:.dispose ();
        }
    }

}

fn compactVertices (positions : [vec3],  normals : [vec3], colors : [vec3], textureUVs : [vec2])-> [f32] {
    let mut size = positions.len * 3;
    if normals.len   == positions.len { size += (normals.len * 3); }
    if colors.len    == positions.len { size += (colors.len * 3); }
    if textureUVs.len == positions.len { size += (textureUVs.len * 2); }


    let dmut result = copy [0.f ; size];
    let mut current = 0us;
    for i in 0 .. positions.len {
        result [current] = positions [i].x;
        result [current + 1] = positions [i].y;
        result [current + 2] = positions [i].z;
        current += 3;

        if normals.len   == positions.len {
            result [current] = normals [i].x;
            result [current + 1] = normals [i].y;
            result [current + 2] = normals [i].z;
            current += 3;
        }

        if colors.len   == positions.len {
            result [current] = colors [i].x;
            result [current + 1] = colors [i].y;
            result [current + 2] = colors [i].z;
            current += 3;
        }

        if textureUVs.len   == positions.len {
            result [current] = textureUVs [i].x;
            result [current + 1] = textureUVs [i].y;
            current += 2;
        }
    }

    result
}
