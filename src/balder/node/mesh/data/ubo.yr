in ubo;

use balder::core::{error, dispose, driver::_};
use vulkan::_;

/**
 * Ancestor of all uniform buffers
 */
@abstract
pub class UniformBufferObject over Node {

    // The buffers containing the uniform values
    let mut _uniformBuffers : [[c8] => dmut &Buffer] = copy [];

    // let dmut _uniformTextures = HashMap!{[c32], dmut &Texture2D}::new ();

    /**
     * Create an empty ubo
     */
    prot self () {}

    /**
     * @returns: true iif the ubo has a buffer named 'name'
     */
    @final
    pub fn hasUniform (self, name : [c8])-> bool {
        name in self._uniformBuffers
    }

    /**
     * Bind the uniform buffers to a descriptor set
     * @params:
     *    - desc: the descriptor set to bind
     */
    @final
    pub fn bind (mut self, dmut desc : &DescriptorSet)
        throws BalderError
    {
        for i, dmut buf in alias self._uniformBuffers {
            desc:.bind (i, alias buf);
        }
    }
   
    /**
     * @returns: the buffer associated to the value 'name'
     */
    @final
    pub fn getUniform (mut self, name : [c8])-> dmut &Buffer
        throws BalderError
    {
        if let Ok (dmut buf) = alias self._uniformBuffers [name] {
            return alias buf;
        }

        throw copy BalderError ("Uniform buffer has no uniform field named '"s8 ~ name ~ "'"s8);
    }
    
    impl Disposable {
        pub over dispose (mut self) {
            for _, dmut uni in alias self._uniformBuffers {
                uni:.dispose ();
            }

            self._uniformBuffers = copy [];
        }
    }
    
}

/**
 * @template:
 *      - T: the structure describing the material
 */
pub class UniformBufferObject {record T} over UniformBufferObject {

    /**
     * Create a material and all its buffers
     */
    pub self (dmut device : &VulkanDevice)
        throws BalderError
    {
        let infos = __pragma!field_infos (T);
        cte for i in 0us .. infos.len {
            let type = getDescriptorType!{__pragma!field_type (T, infos [i].name)} ();
            cte if (type == VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) {
                let dmut buf = device:.getMemoryAllocator ():.allocBuffer (
                    cast!u64 ((__pragma!field_type (T, infos [i].name))::size),
                    cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |
                              VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT),
                    cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));
                
                self._uniformBuffers [infos [i].name] = alias buf;
            } else {
                cte assert (false, "Unknwon uniform type");
            }
        }
    }
    
}
