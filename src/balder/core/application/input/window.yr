in window;

use ::sdl2::_;

use balder::core::application::input::_;

use std::{io, conv};
use std::{concurrency::signal, time::_};

/**
 * All events associated to a given window
 * */
pub class WindowInputSignals {

    pub let uid = 0u32;

    // The list of key event that trigger signals
    let dmut _keys : [KeyInfo => Signal!{KeyInfo}] = copy [];

    // The list of key combinations that trigger signals
    let dmut _combinations : [[SDL_Keycode] => Signal!{()}] = copy [];

    // The list of mouse events that trigger signals
    let dmut _mouse : [MouseInfo => Signal!{i32, i32, MouseInfo}] = copy [];

    // The signal emitted when a double click is sent
    let dmut _doubleClick = Signal!{i32, i32} ();

    // The signal connected to a mouse motion
    let mut _motion = Signal!{i32, i32} ();

    // THe signal connected to the wheel motion (scrolling)
    let mut _wheel = Signal!{i32, i32, i32, i32} ();

    // The signal connected to the quit event of the window
    let mut _quit = Signal!{()} ();

    // Signal emitted when the input manager in text input mode and text is edited
    let mut _textEdit = Signal!{[c8], u32, u32} ();

    // Signal emitted when the input manager in text input mode and text is written
    let mut _textInput = Signal!{[c8]} ();

    prot { // window events

        // Signal emitted when the window is resized
        let mut _resize = Signal!{u32, u32} ();

        // Signal emitted when the position of the window is updated
        let mut _moved = Signal!{u32, u32} ();

        // Signal emitted when the window is exposed
        let mut _exposed = Signal!{()} ();

        // Signal emitted when the window is hidden
        let mut _hidden = Signal!{bool} ();

        // Signal emitted when the window is minimized/maximized/or restored
        let mut _maxMinRest = Signal!{SDL_WindowEventID} ();

        // Signal emitted when the mouse is entering or leaving the window
        let mut _mouseFocus = Signal!{bool} ();

        // Signal emitted when the window gain or lose keyboard focus
        let mut _keyboardFocus = Signal!{bool} ();

    }

    // List of keys currently down on the keyboard
    let dmut _isDown : [SDL_Keycode => ()] = copy [];

    // True iif the window has the keyboard focus
    let mut _hasKeyboardFocus : bool = false;

    // True if the window has the keyboard focus and is currently in text edit mode
    let mut _isTextInput = false;

    // The timestamp of the last left click
    let mut _lastClick = 0u32;

    // The amount of time between two clicks to be considered a double click in milliseconds
    let mut _doubleClickSensivity = 300u32;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (uid : u32)
        with uid = uid
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          CONNECT/DISCONNECT          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect a key event to a slot.
     * @params:
     *    - key: the keyinfo that triggers the signal
     *    - f: the closure called when the keyinfo `key` happens
     */
    pub fn connect (mut self, key : KeyInfo, f : dg (KeyInfo)-> void) {
        if let Ok (dmut lst) = alias self._keys [key] {
            lst:.connect (f);
        } else {
            let mut sig = Signal!{KeyInfo} ();
            sig:.connect (f);
            self._keys [key] = alias sig;
        }
    }

    /**
     * Disconnect a slot from key event.
     * @params:
     *    - key: the keyinfo to disconnect
     *    - f: the function that will no longer be called when `key` happens
     */
    pub fn disconnect (mut self, key : KeyInfo, f : dg (KeyInfo)-> void) {
        if let Ok (dmut lst) = alias self._keys [key] {
            lst:.disconnect (f);
            if lst.len == 0 {
                self._keys:.remove (key);
            }
        }
    }

    /**
     * Connect a mouse event to a slot.
     * @params:
     *    - mouse: the mouse event to connect to a slot
     *    - f: the function called when the event `mouse` happens, dg (x, y, mouse state)
     */
    pub fn connect (mut self, mouse : MouseInfo, f : dg (i32, i32, MouseInfo)-> void) {
        if let Ok (dmut lst) = alias self._mouse [mouse] {
            lst:.connect (f)
        } else {
            let mut sig = Signal!{i32, i32, MouseInfo} ();
            sig:.connect (f);
            self._mouse [mouse] = alias sig;
        }
    }

    /**
     * Disconnect a slot from a mouse event.
     * @params:
     *    - mouse: the mouse event to disconnect
     *    - f: the slot that will no longer be called
     */
    pub fn disconnect (mut self, mouse : MouseInfo, f : dg (i32, i32, MouseInfo)-> void) {
        if let Ok (dmut lst) = alias self._mouse [mouse] {
            lst:.disconnect (f);
            if lst.len == 0 {
                self._mouse:.remove (mouse);
            }
        }
    }

    /**
     * Connect the double click event
     * */
    pub fn connectDoubleClick (mut self, f : dg (i32, i32)-> void) {
        self._doubleClick:.connect (f);
    }

    /**
     * Disconnect the double click event
     * */
    pub fn disconnectDoubleClick (mut self, f : dg (i32, i32)-> void) {
        self._doubleClick:.connect (f);
    }

    /**
     * Connect a combination event.
     * @params:
     *    - keys: the list of keys that have to be pressed down at the same time to trigger the slot event
     *    - f: the slot to call when all the keys of the combination are pressed down
     */
    pub fn connect (mut self, keys : [SDL_Keycode], f : dg ()-> void) {
        if let Ok (dmut lst) = alias self._combinations [keys] {
            lst:.connect (f);
        } else {
            let mut sig = Signal!{()} ();
            sig:.connect (f);
            self._combinations [keys] = alias sig;
        }
    }

    /**
     * Disconnect a slot from a combination event.
     * @params:
     *    - keys: a combination of keys that when all pressed down trigger a signal
     *    - f: the slot that will no longer be called when the combination happens
     */
    pub fn disconnect (mut self, keys : [SDL_Keycode], f : dg ()-> void) {
        if let Ok (dmut lst) = alias self._combinations [keys] {
            lst:.disconnect (f);
            if lst.len == 0 {
                self._combinations:.remove (keys);
            }
        }
    }

    /**
     * Connect the mouse motion event to a slot.
     * @params:
     *  - f : a function that takes the x and y coordinates of the mouse, and that will be called each time the mouse if moved
     */
    pub fn connectMotion (mut self, f : dg (i32, i32)-> void) {
        self._motion:.connect (f);
    }

    /**
     * Disconnect a slot from the mouse motion event.
     */
    pub fn disconnectMotion (mut self, f : dg (i32, i32)-> void) {
        self._motion:.disconnect (f);
    }

    /**
     * Connect the mouse wheel event to a slot (scrolling event).
     * @params:
     *  - f : a function that takes the x and y coordinates of the mouse, and the amount scrolled along x and y axises
     */
    pub fn connectWheel (mut self, f : dg (i32, i32, i32, i32)-> void) {
        self._wheel:.connect (f);
    }

    /**
     * Disconnect a slot from the mouse wheel event.
     */
    pub fn disconnectWheel (mut self, f : dg (i32, i32, i32, i32)-> void) {
        self._wheel:.disconnect (f);
    }

    /**
     * Connect the text input signal
     */
    pub fn connectTextInput (mut self, d : dg ([c8])-> void) {
        self._textInput:.connect (d);
    }

    /**
     * Disonnect the text input signal
     */
    pub fn disconnectTextInput (mut self, d : dg ([c8])-> void) {
        self._textInput:.disconnect (d);
    }

    /**
     * Connect the text edit signal
     */
    pub fn connectTextEdit (mut self, d : dg ([c8], u32, u32)-> void) {
        self._textEdit:.connect (d);
    }

    /**
     * Disconnect the text edit signal
     */
    pub fn disconnectTextEdit (mut self, d : dg ([c8], u32, u32)-> void) {
        self._textEdit:.disconnect (d);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ========================          CONNECT/DISCONNECT WINDOW EVENTS          ========================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect the signal emitted when the closing event of the application is triggered (red button of the window for example).
     */
    pub fn connectQuit (mut self, f : dg ()-> void) {
        self._quit:.connect (f);
    }

    /**
     * Disconnect the signal emitted when the window is closed
     */
    pub fn disconnectQuit (mut self, f : dg ()-> void) {
        self._quit:.disconnect (f);
    }

    /**
     * Connect the signal emitted when the window is resized
     * @params:
     *   - f: a slot taking the new size of the window in parameter
     */
    pub fn connectResize (mut self, f : dg (u32, u32)-> void) {
        self._resize:.connect (f);
    }

    /**
     * Disconnect the signal emitted when the window is resized
     */
    pub fn disconnectResize (mut self, f : dg (u32, u32)-> void) {
        self._resize:.disconnect (f);
    }

    /**
     * Connect the signal emitted when the window is moved on screen
     * * @params:
     *   - f: a slot taking the new position of the window in parameter
     */
    pub fn connectMoved (mut self, f : dg (u32, u32)-> void) {
        self._moved:.connect (f);
    }

    /**
     * Disconnect the signal emitted when the window is moved on screen
     */
    pub fn disconnectMoved (mut self, f : dg (u32, u32)-> void) {
        self._moved:.disconnect (f);
    }


    /**
     * Connect the signal emitted when the application is exposed
     */
    pub fn connectExpose (mut self, f : dg ()-> void) {
        self._exposed:.connect (f);
    }

    /**
     * Disconnect the signal emitted when the application is exited
     */
    pub fn disconnectExpose (mut self, f : dg ()-> void) {
        self._exposed:.disconnect (f);
    }

    /**
     * Connect the signal emitted when the application is minimized
     * @params:
     *    - f: the slot taking true iif the window is displayed
     */
    pub fn connectHideShow (mut self, f : dg (bool)-> void) {
        self._hidden:.connect (f);
    }

    /**
     * Disconnect the signal emitted when the application is minimized
     * @params:
     *    - f: the slot taking true iif the window is displayed
     */
    pub fn disconnectHideShow (mut self, f : dg (bool)-> void) {
        self._hidden:.disconnect (f);
    }

    /**
     * Connect the signal when the window is minimized, maximized or restored
     * @params:
     *    - f: a slot taking SDL_WINDOWEVENT_MINIMIZED iif the window is minimized, SDL_WINDOWEVENT_MAXIMIZED if maximized, and SDL_WINDOWEVENT_RESTORE if restored to configured size
     * */
    pub fn connectMinMaxRestore (mut self, f : dg (SDL_WindowEventID)-> void) {
        self._maxMinRest:.connect (f);
    }

    /**
     * Disconnect the signal when the window is minimized, maximized or restored
     * */
    pub fn disconnectMinMaxRestore (mut self, f : dg (SDL_WindowEventID)-> void) {
        self._maxMinRest:.disconnect (f);
    }

    /**
     * Connect the signal when the mouse is entering or leaving the window
     * @params:
     *    - f: a slot taking true iif the mouse is in the window
     * */
    pub fn connectMouseFocus (mut self, f : dg (bool)-> void) {
        self._mouseFocus:.connect (f);
    }

    /**
     * Disconnect the signal when the mouse is entering or leaving the window
     * */
    pub fn disconnectMouseFocus (mut self, f : dg (bool)-> void) {
        self._mouseFocus:.disconnect (f);
    }

    /**
     * Connect the signal when the window is gaining or losing keyboard focus
     * @params:
     *    - f: a slot taking true iif the mouse is in the window
     * */
    pub fn connectKeyboardFocus (mut self, f : dg (bool)-> void) {
        self._keyboardFocus:.connect (f);
    }

    /**
     * Disconnect the signal when the mouse is entering or leaving the window
     * */
    pub fn disconnectKeyboardFocus (mut self, f : dg (bool)-> void) {
        self._keyboardFocus:.disconnect (f);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          INPUT TEXT TOGGLE          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Enter input text mode
     */
    pub fn startInputText (mut self) {
        if self._hasKeyboardFocus {
            SDL_StartTextInput ();
            self._isTextInput = true;
        }
    }

    /**
     * Exit input text mode
     */
    pub fn stopInputText (mut self) {
        if self._hasKeyboardFocus {
            SDL_StopTextInput ();
            self._isTextInput = false;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          EMIT          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Manage an event of type SDL_KEYDOWN
     */
    pub fn manageKeyDown (mut self, e : SDL_Event) {
        let key = e.key.keysym.sym;
        let kind = if key !in self._isDown {
            self._isDown [key] = ();
            KeyEvent::DOWN
        } else {
            KeyEvent::REPEAT
        };

        let emitted = self.emitCombinations ();
        if !emitted {
            if let Ok (x) = self._keys [KeyInfo (key, kind)] {
                x.emit (KeyInfo (key, kind));
            } else if let Ok (x) = self._keys [KeyInfo (key, KeyEvent::ALL)] {
                x.emit (KeyInfo (key, kind));
            }
        }
    }

    /**
     * Manage an event of type SDL_KEYUP
     */
    pub fn manageKeyUp (mut self, e : SDL_Event) {
        let key = e.key.keysym.sym;
        self._isDown:.remove (key);

        if let Ok (x) = self._keys [KeyInfo (key, KeyEvent::RELEASE)] {
            x.emit (KeyInfo (key, KeyEvent::RELEASE));
        } else if let Ok (x) = self._keys [KeyInfo (key, KeyEvent::ALL)] {
            x.emit (KeyInfo (key, KeyEvent::RELEASE));
        }
    }

    /**
     * Manage an event of type SDL_MOUSEBUTTONDOWN
     */
    pub fn manageMouseButtonDown (mut self, e : SDL_Event) {
        let button = e.button.button;

        if button == SDL_BUTTON_LEFT {
            let diff = e.common.timestamp - self._lastClick;
            self._lastClick = e.common.timestamp;

            if e.button.clicks != 1 && diff <= self._doubleClickSensivity {
                self._doubleClick.emit (e.button.x, e.button.y);
                return;
            }
        }

        if let Ok (x) = self._mouse [MouseInfo (button, KeyEvent::DOWN)] {
            x.emit (e.button.x, e.button.y, MouseInfo(button, KeyEvent::DOWN));
        } else if let Ok (x) = self._mouse [MouseInfo (button, KeyEvent::ALL)] {
            x.emit (e.button.x, e.button.y, MouseInfo (button, KeyEvent::DOWN));
        }
    }

    /**
     * Manage an event of type SDL_MOUSEBUTTONUP
     */
    pub fn manageMouseButtonUp (self, e : SDL_Event) {
        let button = e.button.button;
        if let Ok (x) = self._mouse [MouseInfo (button, KeyEvent::RELEASE)] {
            x.emit (e.button.x, e.button.y, MouseInfo(button, KeyEvent::RELEASE));
        } else if let Ok (x) = self._mouse [MouseInfo (button, KeyEvent::ALL)] {
            x.emit (e.button.x, e.button.y, MouseInfo (button, KeyEvent::RELEASE));
        }
    }

    /**
     * Emit the signal for a SDL_MOUSEMOTION event
     */
    pub fn manageMouseMotion (self, e : SDL_Event) {
        self._motion.emit (e.button.x, e.button.y);
    }

    /**
     * Emit the signal for a SDL_MOUSEWHEEL event
     */
    pub fn manageMouseWheel (self, e : SDL_Event) {
        let mut x = 0, mut y = 0;
        SDL_GetMouseState (alias &x, alias &y);

        self._wheel.emit (x, y, e.wheel.x, e.wheel.y);
    }

    /**
     * Manage the event of type SDL_WINDOWEVENT
     */
    pub fn manageWindowEvent (mut self, e : SDL_Event) {
        match e.window.event {
            SDL_WindowEventID::SDL_WINDOWEVENT_RESIZED => {
                self._resize.emit (cast!u32 (e.window.data1), cast!u32 (e.window.data2));
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_SIZE_CHANGED => {
                self._resize.emit (cast!u32 (e.window.data1), cast!u32 (e.window.data2));
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_MOVED => {
                self._moved.emit (cast!u32 (e.window.data1), cast!u32 (e.window.data2));
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_EXPOSED => {
                self._exposed.emit ();
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_HIDDEN => {
                self._hidden.emit (false);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_SHOWN => {
                self._hidden.emit (true);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_MINIMIZED => {
                self._maxMinRest.emit (SDL_WindowEventID::SDL_WINDOWEVENT_MINIMIZED);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_MAXIMIZED => {
                self._maxMinRest.emit (SDL_WindowEventID::SDL_WINDOWEVENT_MAXIMIZED);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_RESTORED => {
                self._maxMinRest.emit (SDL_WindowEventID::SDL_WINDOWEVENT_RESTORED);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_FOCUS_GAINED => {
                self._hasKeyboardFocus = true;
                self._keyboardFocus.emit (true);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_FOCUS_LOST => {
                self._hasKeyboardFocus = false;
                self._keyboardFocus.emit (false);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_ENTER => {
                self._mouseFocus.emit (true);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_LEAVE => {
                self._mouseFocus.emit (false);
            }
            SDL_WindowEventID::SDL_WINDOWEVENT_CLOSE => {
                self._quit.emit ();
            }
        }
    }

    /**
     * Manage event of type SDL_TEXTINPUT
     */
    pub fn manageTextEdit (self, e : SDL_Event) {
        unsafe {
            self._textEdit.emit (std::conv::fromStringZ (e.edit.text.ptr), cast!u32 (e.edit.start), cast!u32 (e.edit.length));
        }
    }

    /**
     * Manage event of type SDL_TEXTEDIT
     */
    pub fn manageTextInput (self, e : SDL_Event) {
        unsafe {
            self._textInput.emit (std::conv::fromStringZ (e.text.text.ptr));
        }
    }

    /**
     * Emit the quit signal
     * */
    pub fn emitQuit (self) {
        self._quit.emit ();
    }

    /**
     * Check wether all keys of a combination are pressed
     * @returns: true if at least one signal has been emitted
     * */
    fn emitCombinations (self)-> bool {
        let mut emitted = false;

        for ks, x in self._combinations {
            let mut todo = true;
            for k in ks if (k !in self._isDown) {
                todo = false;
                break;
            }

            if todo { x.emit (); emitted = true; }
        }

        emitted
    }

}
