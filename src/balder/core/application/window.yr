/**
 * @authors: Emile Cadorel
 */
in window;

mod ::pass;

use balder::core::{_, driver::_, application::_, application::window::_};
use balder::utils::log;

use vulkan::_;
use std::{io, time::_, config::_};

use ::core::concurrency::sync::semaphore;

use sdl2::_;


/**
 * Class managing a window and vulkan devices to enable 3D rendering
 * @example:
 * ===
 * // Create an empty window
 * with dmut win = Window::new () {
 * 
 *    // Configure the window
 *    win:.configure (conf);
 * 
 *    // show the window to the screen
 *    win:.show ();
 *
 * } // window are disposable
 * ===
 */
pub class Window {

    // the width of the window
    let mut _w : u32 = 0;

    // The height of the window
    let mut _h : u32 = 0;

    // The name (displayed on the window bar) of the window
    let mut _name : [c8] = "";

    // The sdl handler of the window
    prot let dmut _sdlWindow : *SDL_Window = null;

    // The surface for vulkan presenting
    prot let dmut _vkSurface : VkSurfaceKHR = null;

    // Vulkan instance
    prot let dmut _vkInstance : &VulkanInstance = copy VulkanInstance ();

    // The device used for rendering
    prot let dmut _vkDevice : &VulkanDevice = copy VulkanDevice ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    // The thread running the rendering loop
    prot let dmut _renderingTh : (future-> void)? = none;

    // Set to 0 when the frames have to be redrawn
    prot let mut _redrawing = false;

    // The pass for final composition
    prot let mut _composePass : DrawPass = DrawPass ();

    prot let dmut _subpasses : [DrawPass] = [];

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          THREAD          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    // True if the window is rendering
    prot let mut _isRunning : bool = false;

    // The timer of frame duration
    prot let dmut _frameTimer = Timer ();

    // The timer of a second, for nb frame per second computation
    prot let dmut _secondTimer = Timer ();

    // The duration of a frame in ms, by fnault 60 frame per seconds
    prot let mut _frameDuration : Duration = dur::millis (16u64) + dur::micros (666u64);

    /// The number of frame in the current second
    prot let mut _nbFrame : u32 = 0;

    /// The number of frame rendered during the last second
    prot let mut _lastNbFrame : u32 = 0;

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create an empty window
     */
    pub self () {}

    /**
     * Configure the window to use vulkan for 3D rendering
     * @params: 
     *    - config: the configuration of the window
     *    - resizable: true iif the window should be resizable 
     * @throws:
     *    - &BalderError: if the configuration failed
     */
    pub fn configureVulkan (mut self, config : &Config, fps : u32, resizable : bool = false)
        throws BalderError
    {
        if (SDL_Init (SDL_INIT_EVERYTHING) < 0) {
            throw copy BalderError ("Failed to init SDL2");
        }

        if (TTF_Init () < 0) {
            throw copy BalderError ("Failed to init ttf");
        }

	    self._sdlWindow = SDL_CreateWindow (
	        std::conv::toStringZ (self._name),
	        cast!i32 (SDL_WINDOWPOS_UNDEFINED),
	        cast!i32 (SDL_WINDOWPOS_UNDEFINED),
	        cast!i32 (self._w),
	        cast!i32 (self._h),
	        if (resizable) {
                SDL_WindowFlags::SDL_WINDOW_VULKAN |
                SDL_WindowFlags::SDL_WINDOW_RESIZABLE
            }
            else {
                SDL_WindowFlags::SDL_WINDOW_VULKAN
            });

        if (self._sdlWindow == null) {
            throw copy BalderError ("Failed to create window");
        }
        
        self._vkInstance:.configure (alias self, config);

        SDL_Vulkan_CreateSurface (self._sdlWindow, self._vkInstance:.getHandle (), alias &self._vkSurface);
        if (self._vkSurface == null) {
            throw copy BalderError ("Failed to create vulkan surface");
        }
        
        self._vkDevice:.configure (alias self, config);
        SDL_HideWindow (alias self._sdlWindow);

        self._frameDuration = dur::seconds (1) / cast!u64 (fps);

        // Draw empty screen, to configure default command buffers
        self:.resetComposePass ();
        self._redrawing = true;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  SETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Change the dimension of the window
     * @params:
     *    - w: the width of the window
     *    - h: the height of the window
     */
    pub fn setDimension (mut self, w : u32, h : u32) {
        self._w = w;
        self._h = h;
        if (self._sdlWindow != null) {
            SDL_SetWindowSize (alias self._sdlWindow, cast!i32 (self._w), cast!i32 (self._h));
        }
    }

    /**
     * Change the name of the window
     * @params:
     *    - name: the name to put on the window title bar
     */
    pub fn setName (mut self, name : [c8]) {
        self._name = name;
        if (self._sdlWindow != null) {
            SDL_SetWindowTitle (alias self._sdlWindow, std::conv::toStringZ (self._name));
        }
    }

    pub fn onResize (mut self, w : u32, h : u32) {
        self._vkDevice:.windowResize ();
        self._w = w;
        self._h = h;
        log::debug ("Window resize ", w, " ", h);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  GETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns:
     *   - .0: the width of the window
     *   - .1: the height of the window
     */
    pub fn getDimension (self)-> (u32, u32) {
        (cast!u32 (self._w), cast!u32 (self._h))
    }

    /**
     * @returns: the name of the window
     */
    pub fn getName (self)-> [c8] {
        self._name
    }

    /**
     * @returns: the handle of the sdl window
     */
    pub fn getSDLHandle (mut self)-> dmut *SDL_Window {
        alias self._sdlWindow
    }

    /**
     * @returns: the surface on which vulkan can render, to render on the window
     */
    pub fn getVulkanSurface (mut self)-> dmut VkSurfaceKHR {
        alias self._vkSurface
    }

    /**
     * @returns: The instance of vulkan used by the window
     */
    pub fn getVulkanInstance (mut self)-> dmut &VulkanInstance {
        alias self._vkInstance
    }

    /**
     * @returns: The device used by the window to render
     */
    pub fn getVulkanDevice (mut self)-> dmut &VulkanDevice {
        alias self._vkDevice
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   USAGE  ===============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Show the window on the screen
     */
    pub fn show (mut self) {
        if (self._sdlWindow != null) {
            SDL_ShowWindow (alias self._sdlWindow);
        }
    }

    /**
     * Hide the window on the screen
     */
    pub fn hide (mut self) {
        if (self._sdlWindow != null) {
            SDL_ShowWindow (alias self._sdlWindow);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          START/STOP DRAWING THREAD          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Launch the thread that draws on the window at a given framerate
     */
    pub fn startRendering (mut self) {
        if let Err () = self._renderingTh && !self._isRunning {
            self._isRunning = true;
            self._renderingTh = (spawn self:.renderingThread ())?;
        }
    }

    /**
     * Kill the rendering thread
     * */
    pub fn killRendering (mut self) {
        self._isRunning = false;
        if let Ok (th) = self._renderingTh {
            th.value; // join thread
            self._renderingTh = none;
        }
        log::debug ("Thread killed");
        self:.waitIdle ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMPOSITION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Clear all screen drawings
     */
    pub fn resetComposePass (mut self) {
        self._redrawing = true;
        if let Ok (dmut sh) = alias self._composePass.shader {
            sh:.dispose ();
            self._composePass.shader = none;
        }

        self._composePass.loadPhase = &emptyLoad;
        self._composePass.drawPhase = &emptyDraw;
    }

    /**
     * Update the elements that are drawn to the window screen
     * @params:
     *     - shader: the shader used to draw the pass
     *     - loadPhase: a callback closure for the loading phase
     *     - drawPhase: a callback closure for the drawing phase
     */
    pub fn setComposePass {record IN} (mut self,
                                       shaderFile : [c8],
                                       loadPhase : dg (dmut &IndirectCommandAllocator)-> void,
                                       drawPhase : dg (dmut &IndirectCommandAllocator)-> void)
        throws BalderError
    {
        self._redrawing = true;
        if let Ok (dmut sh) = alias self._composePass.shader {
            sh:.dispose ();
            self._composePass.shader = none;
        }

        let dmut shader = copy ComposeShader!{IN} (alias self._vkDevice, shaderFile);
        self._composePass.shader = (alias shader)?;

        self._composePass.loadPhase = loadPhase;
        self._composePass.drawPhase = drawPhase;
    }

    /**
     * @returns: the composition shader of the window
     * */
    pub fn getComposeShader (mut self)-> dmut &Shader
        throws BalderError
    {
        if let Ok (dmut sh) = alias self._composePass.shader {
            return alias sh;
        }

        throw copy BalderError ("No composition shader defined");
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          SUBPASSES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a sub pass in the drawing pipeline that will be executed before the composition pass
     * @params:
     *    - name: the name of the subpass
     *    - shaderFile: the name of the shader file to compile for the subpass
     *    - loadPhase: a callback closure for the loading phase
     *    - drawPhase: a callback closure for the drawing phase
     * */
    pub fn addSubpass {record IN} (mut self,
                                   shaderFile : [c8],
                                   loadPhase : dg (dmut &IndirectCommandAllocator)-> void,
                                   drawPhase : dg (dmut &IndirectCommandAllocator)-> void,
                                   width : u32, height : u32, onlyDepth : bool = false)
        throws BalderError
    {
        self._redrawing = true;

        let dmut vkSub = if onlyDepth {
            copy VulkanDepthSubpass (alias self._vkDevice, width, height)
        } else {
            copy VulkanColorSubpass (alias self._vkDevice, width, height)
        };

        let dmut shader = copy SubpassShader!{IN} (alias self._vkDevice, shaderFile, vkSub);

        let mut subpass = DrawPass ();
        subpass.shader = (alias shader)?;
        subpass.loadPhase = loadPhase;
        subpass.drawPhase = drawPhase;
        subpass.pass = (alias vkSub)?;

        self._subpasses ~= [alias subpass];
    }

    /**
     * @returns: the shader of a registered subpass
     * */
    pub fn getSubpassShader (mut self, index : usize)-> dmut &Shader
        throws BalderError
    {
        if index >= self._subpasses.len {
            throw copy BalderError ("Subpass index error");
        }

        if let Ok (dmut sh) = alias self._subpasses [index].shader {
            return alias sh;
        }

        throw copy BalderError ("No shader is defined for subpass");
    }

    /**
     * @returns: the content of a vulkan subpass
     * */
    pub fn getSubpass (mut self, index : usize)-> dmut &VulkanSubpass
        throws BalderError
    {
        if index >= self._subpasses.len {
            throw copy BalderError ("Subpass index error");
        }

        if let Ok (dmut vk) = alias self._subpasses [index].pass {
            return alias vk;
        }

        throw copy BalderError ("No rendering output frame is defined for subpass");
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==========================================   RENDERING UTILS  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Force the redrawing of the scene (updating index command buffers)
     * */
    pub fn redraw (mut self) {
        self._redrawing = true;
    }

    /**
     * Content of the rendering thread, updating the window at a given framerate
     */
    fn renderingThread (mut self) {
        self._secondTimer:.reset ();
        self._frameTimer:.reset ();

        while self._isRunning {
            if self._redrawing {
                self:.performRedraw ();
                self._redrawing = false;
            }

            else {
                let image = self:.startPass ();
                if (image >= 0) {
                    self:.presentPass (image);
                } else {
                    self._redrawing = true;
                }// else swap chain recreation

                if (self._vkDevice.needResize ()) {
                    self._redrawing = true;
                }

                self:.waitFrame ();
            }
        }

        log::debug ("Quit thread loop");
    }

    /**
     * Redraw the frames
     * */
    fn performRedraw (mut self) {
        let dmut newAllocs = self:.performReload ();

        if (self._vkDevice.needResize ()) {
            self._vkDevice:.recreateSwapchain (self:.getVulkanSurface ());
        } catch {
            err => println ("Fail swap chain recreation : ", err);
        }

        let mut frames = 0u32;
        while frames < self._vkDevice.getSwapchainNbFrames () && self._isRunning {
            let image = self:.startPass ();
            log::info ("Redraw frame : ", image);
            self._vkDevice:.clearCommandBuffer ();
            if (image >= 0) {
                self._vkDevice:.startRecording ();

                self:.drawSubpasses (alias newAllocs);

                self._vkDevice:.startRenderPass (cast!u32 (image));
                newAllocs [0]:.startRecording ();

                if let Ok (dmut sh) = alias self._composePass.shader {
                    sh:.select ();
                    self._composePass.drawPhase (alias newAllocs [0]);
                }

                self._vkDevice:.stopRenderPass ();
                self._vkDevice:.stopRecording ();

                self:.presentPass (image);
                frames += 1;
            } // else swap chain recreation

            self:.waitFrame ();
        }

        for i, dmut z in alias self._subpasses {
            if let Ok (dmut all) = alias z.cmdAlloc {
                all:.dispose ();
            }

            self._subpasses [i].cmdAlloc = (alias newAllocs [i + 1])?;
        }

        if let Ok (dmut all) = alias self._composePass.cmdAlloc {
            all:.dispose ();
        }

        self._composePass.cmdAlloc = (alias newAllocs [0])?;
    }

    fn performReload (mut self)-> dmut [&IndirectCommandAllocator] {
        let dmut cmds = copy [copy IndirectCommandAllocator (alias self._vkDevice) for _ in 0 .. (self._subpasses.len + 1)];
        for i, _ in self._subpasses {
            self._subpasses [i].loadPhase (alias cmds [i + 1]);
            {
                cmds [i + 1]:.finalizeLoading ();
            }?;
        }

        self._composePass.loadPhase (alias cmds [0]);
        {
            cmds [0]:.finalizeLoading ();
        }?;

        alias cmds
    }

    fn drawSubpasses (mut self, dmut newAllocs : [&IndirectCommandAllocator]) {
        for i, dmut z in alias self._subpasses {
            if let Ok (dmut vk) = alias z.pass {
                vk:.startRenderPass ();
                newAllocs [i + 1]:.startRecording ();
                if let Ok (dmut sh) = alias z.shader {
                    sh:.select ();
                    z.drawPhase (alias newAllocs [i + 1]);
                }
                self._vkDevice:.stopRenderPass ();
            }
        }
    }

    /**
     * Wait until the next frame should be drawn.
     * @info: update the frame count.
     */
    fn waitFrame (mut self) {
        self._nbFrame += 1u32;

        if (self._secondTimer.timeSinceStart () >= dur::seconds (1u64)) {
            self._secondTimer:.reset ();
            self._lastNbFrame = self._nbFrame;
            self._nbFrame = 0u32;

            let oldName = self._name;
            self:.setName (self._name ~ " FPS : "  ~ std::conv::to!{[c8]} (self._lastNbFrame));
            self._name = oldName;
        }

        let tick = self._frameTimer.timeSinceStart ();
        if (self._frameDuration > tick) {
            let x = Instant::now ();
            let r = self._frameDuration - tick - dur::micros (1u64);
            sleep (r);

            let z = (Instant::now () - x) - r;
            self._frameTimer:.reset (z);
        } else {
            let z = tick - self._frameDuration;
            self._frameTimer:.reset (z);
        }
    }

    /**
     * Start a new vulkan rendering pass
     */
    fn startPass (mut self)-> i32 {
        self._vkDevice:.waitPreviousFrame ();
        let image = self._vkDevice:.acquireNextImage ();

        image
    }

    /**
     * Present the pass that was rendered on the GPU
     */
    fn presentPass (mut self, image : i32) {
        self._vkDevice:.presentScreen (cast!u32 (image));
    }

    /**
     * Wait for all window subcommand to be idle
     */
    fn waitIdle (mut self) {
        self._vkDevice:.waitIdle ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================  DISPOSING  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Clear all the subpasses of the rendering
     * */
    pub fn clearSubpasses (mut self) {
        for i, _ in self._subpasses {
            self._subpasses [i]:.dispose ();
        }

        self._subpasses = [];
    }
    
    impl Disposable {
        pub over dispose (mut self) {
            self:.killRendering ();

            self:.resetComposePass ();
            self:.clearSubpasses ();
            self._composePass:.dispose ();

            self._vkDevice:.disposeSwapchain ();
            self:.disposeSurface ();            
            
            self._vkDevice:.dispose ();
            self._vkInstance:.dispose ();
            
            if (self._sdlWindow != null) {
                SDL_DestroyWindow  (self._sdlWindow);
                self._sdlWindow = null;
            }
        }
    }

    /**
     * Dispose the surface of the window, so it can be recreated for example
     * @info: when window is resized, the surface must be recreated for example
     */
    fn disposeSurface (mut self) {
        if (self._vkSurface != null) {
            vkDestroySurfaceKHR (self._vkInstance:.getHandle (), self._vkSurface, null);
            self._vkSurface = null;
        }
    }
    
    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }

}
