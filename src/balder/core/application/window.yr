/**
 * @authors: Emile Cadorel
 */
in window;

use balder::core::{_, driver::_, application::_};
use balder::utils::log;

use vulkan::_;
use std::{io, time::_, config::_};

use ::core::concurrency::sync::semaphore;

use sdl2::_;


/**
 * Empty indirect command buffer loading
 */
prv fn emptyLoad (dmut _ : &IndirectCommandAllocator) {}

/**
 * Empty indirect command buffer drawing
     */
prv fn emptyDraw (dmut _ : &IndirectCommandAllocator) {}


/**
 * Class managing a window and vulkan devices to enable 3D rendering
 * @example:
 * ===
 * // Create an empty window
 * with dmut win = Window::new () {
 * 
 *    // Configure the window
 *    win:.configure (conf);
 * 
 *    // show the window to the screen
 *    win:.show ();
 *
 * } // window are disposable
 * ===
 */
pub class Window {

    // the width of the window
    let mut _w : u32 = 0;

    // The height of the window
    let mut _h : u32 = 0;

    // The name (displayed on the window bar) of the window
    let mut _name : [c8] = "";

    // The sdl handler of the window
    prot let dmut _sdlWindow : *SDL_Window = null;

    // The surface for vulkan presenting
    prot let dmut _vkSurface : VkSurfaceKHR = null;

    // Vulkan instance
    prot let dmut _vkInstance : &VulkanInstance = copy VulkanInstance ();

    // The device used for rendering
    prot let dmut _vkDevice : &VulkanDevice = copy VulkanDevice ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    // The thread running the rendering loop
    prot let dmut _renderingTh : (future-> void)? = none;

    // The command allocator used to allocate the indirect command buffer, and draw with it
    prot let dmut _cmdAlloc : (&IndirectCommandAllocator)? = none;

    // Set to 0 when the frames have to be redrawn
    prot let mut _redrawing = 0u32;

    // The delegate used to upload the buffers
    prot let mut _loadPhase : dg (dmut &IndirectCommandAllocator)-> void = &emptyLoad;

    // The delegate used to list the draw command to store
    prot let mut _drawPhase : dg (dmut &IndirectCommandAllocator)-> void = &emptyDraw;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          THREAD          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    // True if the window is rendering
    prot let mut _isRunning : bool = false;

    // The timer of frame duration
    prot let dmut _frameTimer = Timer ();

    // The timer of a second, for nb frame per second computation
    prot let dmut _secondTimer = Timer ();

    // The duration of a frame in ms, by fnault 60 frame per seconds
    prot let mut _frameDuration : Duration = dur::millis (16u64) + dur::micros (666u64);

    /// The number of frame in the current second
    prot let mut _nbFrame : u32 = 0;

    /// The number of frame rendered during the last second
    prot let mut _lastNbFrame : u32 = 0;

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create an empty window
     */
    pub self () {}

    /**
     * Configure the window to use vulkan for 3D rendering
     * @params: 
     *    - config: the configuration of the window
     *    - resizable: true iif the window should be resizable 
     * @throws:
     *    - &BalderError: if the configuration failed
     */
    pub fn configureVulkan (mut self, config : &Config, fps : u32, resizable : bool = false)
        throws BalderError
    {
        if (SDL_Init (SDL_INIT_EVERYTHING) < 0) {
            throw copy BalderError ("Failed to init SDL2");
        }

        if (TTF_Init () < 0) {
            throw copy BalderError ("Failed to init ttf");
        }

	    self._sdlWindow = SDL_CreateWindow (
	        std::conv::toStringZ (self._name),
	        cast!i32 (SDL_WINDOWPOS_UNDEFINED),
	        cast!i32 (SDL_WINDOWPOS_UNDEFINED),
	        cast!i32 (self._w),
	        cast!i32 (self._h),
	        if (resizable) {
                SDL_WindowFlags::SDL_WINDOW_VULKAN |
                SDL_WindowFlags::SDL_WINDOW_RESIZABLE
            }
            else {
                SDL_WindowFlags::SDL_WINDOW_VULKAN
            });

        if (self._sdlWindow == null) {
            throw copy BalderError ("Failed to create window");
        }
        
        self._vkInstance:.configure (alias self, config);

        SDL_Vulkan_CreateSurface (self._sdlWindow, self._vkInstance:.getHandle (), alias &self._vkSurface);
        if (self._vkSurface == null) {
            throw copy BalderError ("Failed to create vulkan surface");
        }
        
        self._vkDevice:.configure (alias self, config);
        SDL_HideWindow (alias self._sdlWindow);

        self._frameDuration = dur::seconds (1) / cast!u64 (fps);

        self._cmdAlloc = alias (copy IndirectCommandAllocator (alias self._vkDevice))?;

        // Draw empty screen, to configure default command buffers
        self:.resetDrawing ();
        self._redrawing = 0;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  SETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Change the dimension of the window
     * @params:
     *    - w: the width of the window
     *    - h: the height of the window
     */
    pub fn setDimension (mut self, w : u32, h : u32) {
        self._w = w;
        self._h = h;
        if (self._sdlWindow != null) {
            SDL_SetWindowSize (alias self._sdlWindow, cast!i32 (self._w), cast!i32 (self._h));
        }
    }

    /**
     * Change the name of the window
     * @params:
     *    - name: the name to put on the window title bar
     */
    pub fn setName (mut self, name : [c8]) {
        self._name = name;
        if (self._sdlWindow != null) {
            SDL_SetWindowTitle (alias self._sdlWindow, std::conv::toStringZ (self._name));
        }
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  GETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns:
     *   - .0: the width of the window
     *   - .1: the height of the window
     */
    pub fn getDimension (self)-> (u32, u32) {
        (self._w, self._h)
    }

    /**
     * @returns: the name of the window
     */
    pub fn getName (self)-> [c8] {
        self._name
    }

    /**
     * @returns: the handle of the sdl window
     */
    pub fn getSDLHandle (mut self)-> dmut *SDL_Window {
        alias self._sdlWindow
    }

    /**
     * @returns: the surface on which vulkan can render, to render on the window
     */
    pub fn getVulkanSurface (mut self)-> dmut VkSurfaceKHR {
        alias self._vkSurface
    }

    /**
     * @returns: The instance of vulkan used by the window
     */
    pub fn getVulkanInstance (mut self)-> dmut &VulkanInstance {
        alias self._vkInstance
    }

    /**
     * @returns: The device used by the window to render
     */
    pub fn getVulkanDevice (mut self)-> dmut &VulkanDevice {
        alias self._vkDevice
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   USAGE  ===============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Show the window on the screen
     */
    pub fn show (mut self) {
        if (self._sdlWindow != null) {
            SDL_ShowWindow (alias self._sdlWindow);
        }
    }

    /**
     * Hide the window on the screen
     */
    pub fn hide (mut self) {
        if (self._sdlWindow != null) {
            SDL_ShowWindow (alias self._sdlWindow);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          START/STOP DRAWING THREAD          ============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Launch the thread that draws on the window at a given framerate
     */
    pub fn startRendering (mut self) {
        if let Err () = self._renderingTh && !self._isRunning {
            self._isRunning = true;
            self._renderingTh = (spawn self:.renderingThread ())?;
        }
    }

    /**
     * Kill the rendering thread
     * */
    pub fn killRendering (mut self) {
        self._isRunning = false;
        if let Ok (th) = self._renderingTh {
            th.value; // join thread
            self._renderingTh = none;
        }
        log::debug ("Thread killed");
    }

    /**
     * Clear all screen drawings
     */
    pub fn resetDrawing (mut self) {
        self:.updateDrawing (
            &emptyLoad,
            &emptyDraw);
    }

    /**
     * Update the elements that are drawn to the window screen
     * @params:
     *     - loadPhase: a callback closure for the loading phase
     *     - drawPhase: a callback closure for the drawing phase
     * @info: the command allocator is correctly set for both phases. This function can be called before the window start its rendering threads, and is thread safe.
     * @warning:
     * 1. This function interrupts the screen drawing for the duration of the redrawing
     *     The loading phase should be used to inform the command allocator of the meshes that are already loaded to buffers, but not for the real loading of the scene
     * 2. loading and drawing should be made in the same order (load mesh 1 then 2, draw mesh 1 then 2, but not load mesh 1 and 2, draw mesh 2 and 1)
     */
    pub fn updateDrawing (mut self, loadPhase : dg (dmut &IndirectCommandAllocator)-> void, drawPhase : dg (dmut &IndirectCommandAllocator)-> void) {
        self._redrawing = 0u32;
        self._loadPhase = loadPhase;
        self._drawPhase = drawPhase;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==========================================   RENDERING UTILS  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Content of the rendering thread, updating the window at a given framerate
     */
    fn renderingThread (mut self) {
        self._secondTimer:.reset ();
        self._frameTimer:.reset ();

        while self._isRunning {
            if self._redrawing == 0 {
                self:.redraw ();
            }

            else {
                let image = self:.startPass ();
                self:.presentPass (image);

                self:.waitFrame ();
            }
        }

        log::debug ("Quit thread loop");
    }

    /**
     * Redraw the frames
     * */
    fn redraw (mut self) {
        if let Ok (dmut all) = alias self._cmdAlloc {
            all:.dispose ();
        }

        let dmut newAlloc = copy IndirectCommandAllocator (alias self._vkDevice);
        self._loadPhase (alias newAlloc);
        {
            newAlloc:.finalizeLoading ();
        } catch {
            _ => {
                log::error ("Failed to reload");
                return;
            }
        }

        while self._redrawing < self._vkDevice.getSwapchainNbFrames () && self._isRunning {
            self._vkDevice:.clearCommandBuffer ();
            newAlloc:.startRecording ();
            let image = self:.startPass ();
            if (image >= 0) {
                self._vkDevice:.startRecording ();
                self._vkDevice:.startRenderPass (cast!u32 (image));

                self._drawPhase (alias newAlloc);

                self._vkDevice:.stopRenderPass ();
                self._vkDevice:.stopRecording ();

                self:.presentPass (image);
                self._redrawing += 1;
            }

            self:.waitFrame ();
        }

        self._cmdAlloc = (alias newAlloc)?;
    }

    /**
     * Wait until the next frame should be drawn.
     * @info: update the frame count.
     */
    fn waitFrame (mut self) {
        self._nbFrame += 1u32;

        if (self._secondTimer.timeSinceStart () >= dur::seconds (1u64)) {
            self._secondTimer:.reset ();
            self._lastNbFrame = self._nbFrame;
            self._nbFrame = 0u32;

            let oldName = self._name;
            self:.setName (self._name ~ " FPS : "  ~ std::conv::to!{[c8]} (self._lastNbFrame));
            self._name = oldName;
        }

        let tick = self._frameTimer.timeSinceStart ();
        if (self._frameDuration > tick) {
            let x = Instant::now ();
            let r = self._frameDuration - tick - dur::micros (1u64);
            sleep (r);

            let z = (Instant::now () - x) - r;
            self._frameTimer:.reset (z);
        } else {
            let z = tick - self._frameDuration;
            self._frameTimer:.reset (z);
        }
    }

    /**
     * Start a new vulkan rendering pass
     */
    fn startPass (mut self)-> i32 {
        self._vkDevice:.waitPreviousFrame ();
        let image = self._vkDevice:.acquireNextImage ();

        image
    }

    /**
     * Present the pass that was rendered on the GPU
     */
    fn presentPass (mut self, image : i32) {
        self._vkDevice:.presentScreen (cast!u32 (image));
    }

    /**
     * Wait for all window subcommand to be idle
     */
    fn waitIdle (mut self) {
        self._vkDevice:.waitIdle ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================  DISPOSING  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    
    impl Disposable {
        pub over dispose (mut self) {
            self:.killRendering ();

            if let Ok (dmut cmd) = alias self._cmdAlloc {
                cmd:.dispose ();
                self._cmdAlloc = none;
            }
            
            self._vkDevice:.disposeSwapchain ();
            self:.disposeSurface ();            
            
            self._vkDevice:.dispose ();
            self._vkInstance:.dispose ();
            
            if (self._sdlWindow != null) {
                SDL_DestroyWindow  (self._sdlWindow);
                self._sdlWindow = null;
            }
        }
    }

    /**
     * Dispose the surface of the window, so it can be recreated for example
     * @info: when window is resized, the surface must be recreated for example
     */
    fn disposeSurface (mut self) {
        if (self._vkSurface != null) {
            vkDestroySurfaceKHR (self._vkInstance:.getHandle (), self._vkSurface, null);
            self._vkSurface = null;
        }
    }
    
    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }

}
