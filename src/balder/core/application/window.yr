/**
 * @authors: Emile Cadorel
 */
in window;

use balder::core::{_,
                   driver::_,
                   memory::_,
                   application::_};

use balder::utils::log;

use std::{io, time::_, config::_};

use ::core::concurrency::sync::{mutex, semaphore};

use ::vulkan::core;
use ::sdl2::_;


// Boolean set to false when a window is created
lazy dmut __FIRST_WINDOW__ = copy [true];

/**
 * Class managing a window and vulkan devices to enable 3D rendering
 */
pub class Window {

    prot { // context

        // the width of the window
        let mut _w : u32 = 0;

        // The height of the window
        let mut _h : u32 = 0;

        // The name (displayed on the window bar) of the window
        let mut _name : [c8] = "";

        // The application containing the window
        let dmut _app : &Application;

        // The sdl handler of the window
        let dmut _sdlWindow : *SDL_Window = null;

        // The surface for vulkan presenting
        let dmut _vkSurface : VkSurfaceKHR = null;

        // Vulkan instance
        let dmut _vkInstance : &VulkanInstance = copy VulkanInstance ();

        // The device used for rendering
        let dmut _vkDevice : &VulkanDevice = copy VulkanDevice ();

        // The resource manager to load resource from files
        let dmut _loader : (&ResourceManager)? = none;

        // The drawing pipeline of the window
        let dmut _pipeline : (&VulkanPipeline)? = none;

    }

    prot { // drawing

        // Mutex locked when starting/killing rendering thread
        let dmut _startStopMutex : &Mutex = copy Mutex ();

        // The thread running the rendering loop
        let dmut _renderingTh : (future-> void)? = none;

        // True iif must wait frame on redrawing
        let mut _mustWaitFrameRedraw : bool = true;

    }

    prot { // thread
        // True if the window is rendering
        let mut _isRunning : bool = false;

        // The timer of frame duration
        let dmut _frameTimer : Timer = Timer ();

        // The timer of a second, for nb frame per second computation
        let dmut _secondTimer : Timer = Timer ();

        // Semaphore used to wait for the next frame
        let dmut _frameSemaphore : &Semaphore = copy Semaphore ();

        // The duration of a frame in ms, by fnault 60 frame per seconds
        let mut _frameDuration : Duration = dur::millis (16u64) + dur::micros (666u64);

        // If true, wait frames by triggers instead of timed
        let mut _interactive : bool = false;

        // The number of frame in the current second
        let mut _nbFrame : u32 = 0;

        // The number of frame rendered during the last second
        let mut _lastNbFrame : u32 = 0;

        // The mailbox to receive signals
        let dmut _box : &SlotEmitter = copy SlotEmitter ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create an empty window
     */
    pub self (dmut app : &Application)
        with _app = alias app
    {}

    /**
     * Configure the window to use vulkan for 3D rendering
     * @params: 
     *    - config: the configuration of the window
     *    - resizable: true iif the window should be resizable 
     * @throws:
     *    - &BalderError: if the configuration failed
     */
    pub fn configureVulkan (mut self, cfg : &BalderConfig)
        throws BalderError
    {
        atomic {
            if __FIRST_WINDOW__ [0] {
                if (SDL_Init (SDL_INIT_EVERYTHING) < 0) {
                    throw copy BalderError ("Failed to init SDL2");
                }

                if (TTF_Init () < 0) {
                    throw copy BalderError ("Failed to init ttf");
                }
                __FIRST_WINDOW__ [0] = false;
            }
        }

	    self._sdlWindow = SDL_CreateWindow (
	        std::conv::toStringZ (self._name),
	        cast!i32 (SDL_WINDOWPOS_UNDEFINED),
	        cast!i32 (SDL_WINDOWPOS_UNDEFINED),
	        cast!i32 (self._w),
	        cast!i32 (self._h),
	        if (cfg.window.resizable) {
                SDL_WindowFlags::SDL_WINDOW_VULKAN |
                SDL_WindowFlags::SDL_WINDOW_RESIZABLE
            }
            else {
                SDL_WindowFlags::SDL_WINDOW_VULKAN
            });

        if (self._sdlWindow == null) {
            throw copy BalderError ("Failed to create window");
        }
        
        self._vkInstance:.configure (alias self, cfg);

        SDL_Vulkan_CreateSurface (self._sdlWindow, self._vkInstance:.getHandle (), alias &self._vkSurface);
        if (self._vkSurface == null) {
            throw copy BalderError ("Failed to create vulkan surface");
        }
        
        self._vkDevice:.configure (alias self, cfg);
        self:.hide ();

        if cfg.timer.interactive {
            self._interactive = true;
            self._frameDuration = dur::minutes (1);
        } else {
            self._interactive = false;
            if cfg.timer.fps == 0 {
                log::error #("Window", "Fps must be a positive number");
                throw copy BalderError ("Invalid fps configuration");
            }

            self._frameDuration = dur::seconds (1) / cast!{u64} (cfg.timer.fps);
        }

        // Draw empty screen, to configure default command buffers                
        self:.configureRenderPipeline ();
    }

    /**
     * Connecting the basic input event slots for the window
     * */
    pub fn configureInputEvents (mut self) {
        let dmut input = self:.getInputManager ();

        input:.windowResized ():.connect (alias self._box, &self:.onResize);
        input:.windowExposed ():.connect (alias self._app:.getRootSlotEmitter (), &self:.onExpose);
    }

    /**
     * Configure the rendering pipeline of the window
     * */
    fn configureRenderPipeline (mut self) {
        let dmut pipeline = copy VulkanPipeline (alias self._vkDevice);
        self._pipeline = (alias pipeline)?;        
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  SETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Change the dimension of the window
     * @params:
     *    - w: the width of the window
     *    - h: the height of the window
     */
    pub fn setDimension (mut self, w : u32, h : u32) {
        self._w = w;
        self._h = h;
        if (self._sdlWindow != null) {
            SDL_SetWindowSize (alias self._sdlWindow, cast!i32 (self._w), cast!i32 (self._h));
        }
    }

    /**
     * Change the name of the window
     * @params:
     *    - name: the name to put on the window title bar
     */
    pub fn setName (mut self, name : [c8]) {
        self._name = name;
        if (self._sdlWindow != null) {
            SDL_SetWindowTitle (alias self._sdlWindow, std::conv::toStringZ (self._name));
        }
    }

    /**
     * Slot called when the window is resized
     * */
    pub fn onResize (mut self, w : u32, h : u32) {
        self._vkDevice:.windowResize ();

        self._w = w;
        self._h = h;
        self:.forceFrame ();
    }

    /**
     * Slot called when the window is exposed
     * */
    pub fn onExpose (mut self) {
        self:.forceFrame ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  GETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns:
     *   - .0: the width of the window
     *   - .1: the height of the window
     */
    pub fn getDimension (self)-> (u32, u32) {
        if self._sdlWindow != null {
            let mut w = 0, mut h = 0;
            SDL_GetWindowSize (self._sdlWindow, alias &w, alias &h);
            return (cast!u32 (w), cast!u32 (h));
        }

        (cast!u32 (self._w), cast!u32 (self._h))
    }

    /**
     * @returns: the name of the window
     */
    pub fn getName (self)-> [c8] {
        self._name
    }

    /**
     * @returns: the number of frame drawn last second
     * */
    pub fn getNbFramesLastSecond (self)-> u32 {
        self._lastNbFrame
    }

    /**
     * @returns: the handle of the sdl window
     */
    pub fn getSDLHandle (mut self)-> dmut *SDL_Window {
        alias self._sdlWindow
    }

    /**
     * @returns: the surface on which vulkan can render, to render on the window
     */
    pub fn getVulkanSurface (mut self)-> dmut VkSurfaceKHR {
        alias self._vkSurface
    }

    /**
     * @returns: The instance of vulkan used by the window
     */
    pub fn getVulkanInstance (mut self)-> dmut &VulkanInstance {
        alias self._vkInstance
    }

    /**
     * @returns: The device used by the window to render
     */
    pub fn getVulkanDevice (mut self)-> dmut &VulkanDevice {
        alias self._vkDevice
    }

    /**
     * @returns: the rendering pipeline of the window
     * */
    pub fn getVulkanPipeline (mut self)-> dmut &VulkanPipeline {
        if let Ok (dmut pipe) = alias self._pipeline {
            return alias pipe;
        }

        log::error #("Window", "Window configuration is uncomplete");
        panic;
    }
    
    /**
     * @returns: the garbage bin that is cleaned after a redraw
     * */
    pub fn getGarbageBin {T impl Disposable} (mut self)-> dmut &IResourceBin {
        if let Ok (dmut pipe) = alias self._pipeline {
            return alias pipe:.getBin ():.get!{&ResourceBin!{T}} ();            
        }

        log::error #("Window", "malformed window");
        panic;        
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          RESOURCES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Insert an element in the garbage bin
     * */
    pub fn insertBin {T impl Disposable} (mut self, dmut obj : T) {
        if let Ok (dmut pipe) = alias self._pipeline {
            let dmut bin = alias pipe:.getBin ():.get!{&ResourceBin!{T}} ();
            bin:.insert (alias obj);
        } else {
            log::error #("Window", "malformed window");
            panic;
        }
    }

    /**
     * Load a resource from a file
     * @params:
     *    - path: the path of the file to load (project path are accepted)
     * */
    pub fn loadResource {T} (mut self, path : [c8])-> dmut &(RefCount!{__pragma!root_super (T)})
        throws BalderError
    {
        if let Ok (dmut ld) = alias self._loader {
            let dmut loader = ld:.get!{T} ();
            return loader:.load!{T} (path);
        } else {
            let dmut ld = copy ResourceManager (alias self);

            let dmut loader = ld:.get!{T} ();
            let dmut ret = alias loader:.load!{T} (path);

            self._loader = (alias ld)?;

            alias ret
        }
    }

    /**
     * Insert a managed resource loaded from an external loader
     * @params:
     *    - path: the path of the file to load (project path are accepted)
     * */
    pub fn insertResource {T} (mut self, dmut rec : T)-> dmut &(RefCount!{__pragma!root_super (T)}) {
        if let Ok (dmut ld) = alias self._loader {
            let dmut loader = ld:.get!{T} ();
            return loader:.insert!{T} (alias rec);
        } else {
            let dmut ld = copy ResourceManager (alias self);

            let dmut loader = ld:.get!{T} ();
            let dmut ret = alias loader:.insert!{T} (alias rec);

            self._loader = (alias ld)?;

            alias ret
        }
    }

    /**
     * Load a resource from a file
     * @params:
     *    - path: the path of the file to load (project path are accepted)
     * */
    pub fn loadResource {T, P...} (mut self, path : [c8], params : P)-> dmut &(RefCount!{__pragma!root_super (T)})
        throws BalderError
    {
        if let Ok (dmut ld) = alias self._loader {
            let dmut loader = ld:.get!{T} ();
            return loader:.load!{T} (path, expand params);
        } else {
            let dmut ld = copy ResourceManager (alias self);

            let dmut loader = ld:.get!{T} ();
            let dmut ret = alias loader:.load!{T} (path, expand params);

            self._loader = (alias ld)?;

            alias ret
        }
    }

    /**
     * Load a resource from a file
     * @params:
     *    - path: the path of the file to load (project path are accepted)
     * */
    pub fn emptyResource {T} (mut self)-> dmut &(RefCount!{__pragma!root_super (T)}) {
        if let Ok (dmut ld) = alias self._loader {
            let dmut loader = ld:.get!{T} ();
            return loader:.empty ();
        } else {
            let dmut ld = copy ResourceManager (alias self);

            let dmut loader = ld:.get!{T} ();
            let dmut ret = loader:.empty ();

            self._loader = (alias ld)?;

            alias ret
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          APPLICATION GETTERS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the input manager of the window
     * */
    pub fn getInputManager (mut self)-> dmut &WindowInputSignals {
        if self._sdlWindow != null {
            return self._app:.getInputManager ():.getWindowSignals (SDL_GetWindowID (self._sdlWindow));
        }

        log::error #("Window", "malformed window");
        panic;
    }

    /**
     * @returns: the application to which the window is attached
     * */
    pub fn getApplication (mut self)-> dmut &Application {
        alias self._app
    }

    /**
     * @returns: the application to which the window is attached
     * */
    pub fn getApplication (self)-> &Application {
        self._app
    }

    /**
     * @returns: the slot emitter of the window. Signal emitted in that box are executed by the window thread
     * */
    pub fn getSlotEmitter (mut self)-> dmut &SlotEmitter {
        alias self._box
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   USAGE  ===============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Show the window on the screen
     */
    pub fn show (mut self) {
        if (self._sdlWindow != null) {
            SDL_ShowWindow (alias self._sdlWindow);

            if !self._renderingTh.hasValue {
                self:.startRendering ();
            }
        }
    }

    /**
     * Hide the window on the screen
     */
    pub fn hide (mut self) {
        if (self._sdlWindow != null) {
            SDL_HideWindow (alias self._sdlWindow);

            if self._renderingTh.hasValue {
                self:.killRendering ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===========================          START/STOP DRAWING THREAD          ============================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Launch the thread that draws on the window at a given framerate
     */
    fn startRendering (mut self) {
        {
            self._startStopMutex:.lock ();
            if let Err () = self._renderingTh && !self._isRunning {
                self._isRunning = true;
                self._renderingTh = (spawn self:.renderingThread ())?;
            }

            log::debug #("Window", "Thread launched");
        } exit {
            self._startStopMutex:.unlock ();
        }
    }

    /**
     * Kill the rendering thread
     * */
    fn killRendering (mut self) {
        {
            self._startStopMutex:.lock ();
            self._isRunning = false;
            self:.forceFrame ();

            if let Ok (th) = self._renderingTh {
                th.value; // join thread
                self._renderingTh = none;
            }

            log::debug #("Window", "Thread killed");
        } exit {
            self._startStopMutex:.unlock ();
        }
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==========================================   RENDERING UTILS  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Force the pipeline to recompute all drawing commands
     * */
    pub fn redrawPipeline (mut self) {
        if let Ok (dmut pipe) = alias self._pipeline {
            pipe:.forceRedraw ();
        }
    }

    /**
     * Reset the drawing pipeline, removing every subpasses     
     * */
    pub fn resetDrawingPipeline (mut self) {
        log::debug #("Window", "Reset drawing pipeline");
        
        let isStarted = self._isRunning;
        self:.killRendering ();

        if let Ok (dmut pipe) = alias self._pipeline {
            pipe:.dispose ();
        }

        if isStarted {
            self:.startRendering ();
        }
    }
    
    /**
     * Content of the rendering thread, updating the window at a given framerate
     */
    fn renderingThread (mut self) {
        self._box:.clear ();

        self._secondTimer:.reset ();
        self._frameTimer:.reset ();

        log::debug #("Window", "start rendering thread");

        while self._isRunning {
            {
                self._box:.emit ();
                let image = self:.startFrame ();
                
                if (image >= 0) {
                    self:.submitFrame ();                                            
                    self:.presentFrame (image);
                } else {                    
                    if let Ok (dmut pipe) = alias self._pipeline {
                        pipe:.forceRedraw ();
                    }                                        
                } 
                
                self:.waitFrame (false);
            }
        }

        self:.waitIdle ();
        log::debug #("Window", "Quit thread loop");
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TIMER          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Wait until the next frame should be drawn.
     * @info: update the frame count.
     */
    fn waitFrame (mut self, redraw : bool) {
        if !self._isRunning { return; }

        if self._interactive {
            self:.waitInteractive (redraw);
        } else {
            self:.waitTimed ();
        }
    }

    /**
     * Interactive wait of the next frame
     * */
    fn waitInteractive (mut self, redraw : bool) {
        // In redraw interactive will redraw every swapchain frames in one go
        if redraw {
            return;
        }

        // Semaphore posted in previous frame
        if !self._mustWaitFrameRedraw {
            self._mustWaitFrameRedraw = true;
            return;
        }

        if !self._frameSemaphore:.wait (timeout-> self._frameDuration) {
            // semaphore not posted, timeout
            self._mustWaitFrameRedraw = true;
        } else {
            // semaphore posted
            self._mustWaitFrameRedraw = false;
        }
    }

    /**
     * Timed wait of the next frame
     * */
    fn waitTimed (mut self) {
        self._nbFrame += 1u32;

        if (self._secondTimer.timeSinceStart () >= dur::seconds (1u64)) {
            self._secondTimer:.reset ();
            self._lastNbFrame = self._nbFrame;
            self._nbFrame = 0u32;

            let oldName = self._name;
            self._name = oldName;
        }

        let tick = self._frameTimer.timeSinceStart ();
        if (self._frameDuration > tick) {
            let x = Instant::now ();
            let r = self._frameDuration - tick - dur::micros (1u64);
            sleep (r);

            let z = (Instant::now () - x) - r;
            self._frameTimer:.reset (z);
        } else {
            let z = tick - self._frameDuration;
            self._frameTimer:.reset (z);
        }
    }

    /**
     * Change the mode of frame waiting from timer to interactive
     * @warning: it will happen in the next frame
     * */
    pub fn setInteractiveWait (mut self) {
        if !self._interactive {
            self._interactive = true;
            self._mustWaitFrameRedraw = false;
        }
    }

    /**
     * Change the mode of frame waiting from interactive to timer
     * */
    pub fn setTimedWait (mut self) {
        if self._interactive {
            self._interactive = false;
            self._frameSemaphore:.post ();
        }
    }

    /**
     * Force the next frame to be drawn as soon as possible
     * @info: only works in interactive mode
     * */
    pub fn forceFrame (mut self) {
        if self._interactive {
            self._frameSemaphore:.post ();
        }
    }

    /**
     * @returns: true iif the window is in interactive mode rendering (false if in timer mode)
     * */
    pub fn isInteractive (self)-> bool {
        self._interactive
    }

    /**
     * @returns: the number of frames that were drawn during last second
     * */
    pub fn getNbFrameLastSecond (self)-> u32 {
        self._nbFrame
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          RENDER PASS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Start a new vulkan rendering pass
     */
    fn startFrame (mut self)-> i32 {
        return if let Ok (dmut pipe) = alias self._pipeline {                        
            pipe:.waitPreviousFrame ();
            let image = self._vkDevice:.acquireNextImage ();
            
            self._vkDevice:.getMemoryAllocator ():.commitDynamicBuffers ();
            
            image
        } else {
            -1
        };    
    }

    /**
     * Submit the drawing queues
     * */
    fn submitFrame (mut self) {
        if let Ok (dmut pipe) = alias self._pipeline {
            pipe:.submitFrame ();
        }
    }
    
    /**
     * Present the pass that was rendered on the GPU
     */
    fn presentFrame (mut self, image : i32) {        
        self._vkDevice:.presentScreen (cast!u32 (image));
    }

    /**
     * Wait for all window subcommand to be idle
     */
    fn waitIdle (mut self) {
        self._vkDevice:.waitIdle ();
    }
            
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================  DISPOSING  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    
    impl Disposable {
        pub over dispose (mut self) {
            self:.killRendering ();                    
            
            if let Ok (dmut pipe) = alias self._pipeline {
                pipe:.dispose ();
                self._pipeline = none;
            }
            
            self._vkDevice:.disposeSwapchain ();
            self:.disposeSurface ();            
            
            self._vkDevice:.dispose ();
            self._vkInstance:.dispose ();
                    
            if (self._sdlWindow != null) {
                SDL_DestroyWindow  (self._sdlWindow);
                self._sdlWindow = null;
            }
        }
    }

    /**
     * Dispose the surface of the window, so it can be recreated for example
     * @info: when window is resized, the surface must be recreated for example
     */
    fn disposeSurface (mut self) {
        if (self._vkSurface != null) {
            vkDestroySurfaceKHR (self._vkInstance:.getHandle (), self._vkSurface, null);
            self._vkSurface = null;
        }
    }
    
    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }

}
