in shape;

use balder::math::_;
use balder::core::{_,
                   shader::_,
                   application::_,
                   driver::_,
                   config::_};


@final
pub class Shape {

    pub let uid : usize;

    let dmut _context : &ShapeDrawer;
    let mut _currentRotation : f32 = 0.f;

    let dmut _ubo : &UniformBufferObject;
    let dmut _descSet : &DescriptorSet;

    let _vbo : &VertexBufferObject;
    let _ibo : &IndexBufferObject;

    let mut _texture : (&Texture)? = none;
    let mut _hidden : bool = false;
    let mut _outOfBound : bool = false;

    pub self (uid : usize, dmut drawer : &ShapeDrawer, dmut shader : &Shader, vbo : &VertexBufferObject,  ibo : &IndexBufferObject, texture : (&Texture)?)
        with uid = uid
        , _context = alias drawer
        , _descSet = shader:.allocateDescriptorSet ()
        , _ubo = copy UniformBufferObject (alias shader:.getDevice (), 64)
        , _texture = texture
        , _vbo = vbo
        , _ibo = ibo
        throws BalderError
    {
        self._descSet:.setUniform (UniformNames::WORLD, self._ubo);
        if let Ok (tex) = texture {
            self._descSet:.setTexture (TextureKind::ALBEDO, tex);
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the dimension of the window in which the shape is drawn
     * */
    pub fn setWindowDimension (mut self, dim : vec2) {
        self._ubo:.setData (0, dim);
        let pos = self._ubo.getData!{vec2} (8);
        let size = self._ubo.getData!{vec2} (16);

        let outOfBound = (pos.x + size.x < 0.f || pos.x > dim.x || pos.y + size.y < 0.f || pos.y > dim.y);
        if (outOfBound != self._outOfBound) {
            self._outOfBound = outOfBound;
            self._context:.redraw ();
        }
    }

    /**
     * Change the position of the shape in the window (in pixels, (0,0) being top left corner)
     * */
    pub fn setPosition (mut self, pos : vec2) {
        self._ubo:.setData (8, pos);

        let dim = self._ubo.getData!{vec2} (0);
        let size = self._ubo.getData!{vec2} (16);

        let outOfBound = (pos.x + size.x < 0.f || pos.x > dim.x || pos.y + size.y < 0.f || pos.y > dim.y);
        if (outOfBound != self._outOfBound) {
            self._outOfBound = outOfBound;
            self._context:.redraw ();
        }
    }

    /**
     * Change the size of the shape in the window (in pixels)
     */
    pub fn setSize (mut self, size : vec2) {
        self._ubo:.setData (16, size);

        let dim = self._ubo.getData!{vec2} (0);
        let pos = self._ubo.getData!{vec2} (8);

        let outOfBound = (pos.x + size.x < 0.f || pos.x > dim.x || pos.y + size.y < 0.f || pos.y > dim.y);
        if (outOfBound != self._outOfBound) {
            self._outOfBound = outOfBound;
            self._context:.redraw ();
        }
    }

    /**
     * Change the roundeness of the corner of the shape
     */
    pub fn setRadius (mut self, v : f32) {
        self._ubo:.setData (24, v);
    }

    /**
     * Change the roundeness of the corner of the shape
     */
    pub fn setLevel (mut self, v : u32) {
        self._ubo:.setData (28, v);
    }

    /**
     * Change the color of the shape
     */
    pub fn setColor (mut self, v : vec4) {
        self._ubo:.setData (32, v);
    }

    /**
     * Change the rotation of the shape
     */
    pub fn setRotation (mut self, v : f32) {
        self._currentRotation = v % 360.f;
        let m = math::utils::rotationZ2 (radian (v % 360.f));

        self._ubo:.setData (48, makeVec4 (m.a1, m.b1, m.a2, m.b2));
    }

    /**
     * Change the texture of the shape
     * */
    pub fn setTexture (mut self, tex : (&Texture)?) {
        self._texture = tex;
        self._context:.redraw ();
    }

    /**
     * Hide the shape in the next drawing
     * */
    pub fn hide (mut self) {
        if !self._hidden {
            self._hidden = true;
            self._context:.redraw ();
        }
    }

    /**
     * Show the shape in the next drawing
     * */
    pub fn show (mut self) {
        if self._hidden {
            self._hidden = false;
            self._context:.redraw ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the current rotation state of the shape
     * */
    @field
    pub fn rotation (self)-> f32 {
        self._currentRotation
    }

    /**
     * @returns: the texture displayed by the shape
     * */
    pub fn getTexture (self)-> (&Texture)? {
        self._texture
    }

    /**
     * @returns: true iif the shape is hidden (and therefore must not be drawn)
     * */
    pub fn isHidden (self)-> bool {
        self._hidden || self._outOfBound
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the drawing in the current draw iteration
     * */
    pub fn register (mut self, dmut cmd : &IndirectCommandAllocator) {
        cmd:.registerIndexedObject (self._ibo.getNbPoints ());
        if let Ok (tex) = self._texture {
            self._descSet:.setTexture (TextureKind::ALBEDO, tex)?;
        }
    }

    /**
     * Draw the shape
     * @assume: already registered and at correct index
     * */
    pub fn draw (self, dmut _ : &Shader, dmut cmd : &IndirectCommandAllocator) {
        self._descSet.select ();
        self._vbo.select ();
        self._ibo.select ();

        cmd:.drawNextIndexed ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            let dmut bin = self._context:.getWindow ():.getGarbageBin ();
            bin:.insert (alias self._descSet);
            bin:.insert (alias self._ubo);
        }
    }


}
