in texture;

use balder::math::_;
use balder::core::{_, driver::_, shader::_, config::_};

pub record TextureUniform {
    pub let mut dimension : vec2 = makeVec2 (1024.f, 768.f);
    pub let mut translation : vec2 = makeVec2 (0.f, 0.f);
    pub let mut scale : vec2 = makeVec2 (1.f, 1.f);
    pub let mut rotation : mat2 = mat2 ();

    pub self () {}
}

pub class TextureShape {

    pub let uid : usize;

    let dmut _textureUBO : &UniformBufferObject;
    let dmut _texture : &Texture;
    let dmut _descSet : &DescriptorSet;

    let dmut _vbo : &VertexBufferObject;
    let dmut _ibo : &IndexBufferObject;

    let dmut _uniform : TextureUniform = TextureUniform ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (uid : usize, dmut shader : &Shader, dmut vbo : &VertexBufferObject, dmut ibo : &IndexBufferObject, dmut texture : &Texture)
        with uid = uid
        , _vbo = alias vbo
        , _ibo = alias ibo
        , _texture = alias texture
        , _textureUBO = copy UniformBufferObject!{TextureUniform} (alias shader:.getDevice ())
        , _descSet = shader:.allocateDescriptorSet ()
        throws BalderError
    {
        self._descSet:.setUniform (UniformNames::WORLD, self._textureUBO);
        self._descSet:.setTexture (TextureKind::ALBEDO, self._texture);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn register (self, dmut cmd : &IndirectCommandAllocator) {
        cmd:.registerIndexedObject (self._ibo.getNbPoints ());
    }

    pub fn draw (self, dmut _ : &Shader, dmut cmd : &IndirectCommandAllocator) {
        self._descSet.select ();
        self._vbo.select ();
        self._ibo.select ();

        cmd:.drawNextIndexed ();
    }

    /**
     * Update the values in the uniform buffer object of the shape
     * */
    fn updateUBO (mut self) {
        self._textureUBO:.update (self._uniform);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the texture displayed by the shape
     * */
    @field
    pub fn texture (self)-> &Texture {
        self._texture
    }

    /**
     * @returns: the texture displayed by the shape
     * */
    @field
    pub fn texture (mut self)-> dmut &Texture {
        alias self._texture
    }

    /**
     * @returns: the position of the shape on the screen in pixels (relative to top left corner)
     * */
    @field
    pub fn position (self)-> vec2 {
        self._uniform.translation
    }

    /**
     * @returns: the size of the shape on the screen in pixels (relative to its center)
     * */
    @field
    pub fn size (self)-> vec2 {
        self._uniform.translation
    }

    /**
     * @returns: the rotation of the shape on the screen (in degrees)
     * */
    @field
    pub fn angle (self)-> f32 {
        math::utils::angleZ2 (self._uniform.rotation)
    }

    /**
     * Set the position of the shape on the screen (in pixels, relative to top left corner)
     * */
    pub fn setPosition (mut self, pos : vec2) {
        self._uniform.translation = pos;
        self:.updateUBO ();
    }

    /**
     * Set the size of the shape on the screen (in pixels, relative to its center)
     * */
    pub fn setSize (mut self, pos : vec2) {
        self._uniform.translation = pos;
        self:.updateUBO ();
    }

    /**
     * Set the rotation angle of the shape in radians (around its center)
     * */
    pub fn setAngle (mut self, angle : f32) {
        self._uniform.rotation = math::utils::rotationZ2 (angle);
        self:.updateUBO ();
    }

    /**
     * Set the texture displayed by the shape
     * */
    pub fn setTexture (mut self, dmut tex : &Texture) {
        self._texture = alias tex;
    }

    /**
     * Set the dimension of the window to scale the widget accordingly
     * */
    pub fn setWindowDimension (mut self, dim : vec2) {
        self._uniform.dimension = dim;
        self:.updateUBO ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._textureUBO:.dispose ();
            self._descSet:.dispose ();
        }
    }

}
