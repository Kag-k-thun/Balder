in device;


use balder::core::{_,
                   driver::_,
                   memory::_,
                   application::_,
                   shader::texture};

use balder::utils::log;

use ::vulkan::core;
use ::sdl2::_;

use std::{io, conv, time::_};

/**
 * A vulkan device used to manage vulkan rendering tools
 */
pub class VulkanDevice {

    // The pointer to the window holding the device
    let dmut _win : (&Window)? = none;
    
    // The vulkan instance used to configure vulkan lib
    let dmut _instance : &VulkanInstance = copy VulkanInstance ();

    prot {
        
        // The logical device handle of vulkan
        let dmut _device : VkDevice = null;
        
        // The graphics queue
        let dmut _graphicsQueue : VkQueue = null;

        // The transfer queue
        let dmut _transferQueue : VkQueue = null;

        // The present queue
        let dmut _presentQueue : VkQueue = null;

        // The queue for compute shaders
        let dmut _computeQueue : VkQueue = null;
        
        // let mut _waitPipelineStage : u32 = 0u32;

    }

    prot {    
        // The handle of the physical device of vulkan
        let dmut _physicalDevice : VkPhysicalDevice = null;
        
        // The name of the physical device in use
        let mut _physicalDeviceName : [c8] = "";

        // The indices for graphics and present 
        let mut _physicalDeviceFamilyIndices : [u32] = [];

    }    

    prot {

        // The swap chain of the window
        let dmut _swapChain : (&SwapChain)? = none;

        // True when the window was resized and the swap chain needs to be recreated
        let mut _resizingWindow : bool = false;
        
    }

    prot {
        
        // The command pool of the device used for drawing
        let dmut _drawPool : VkCommandPool = null;

        // The command pool used for single time commands
        let dmut _memoryPool : VkCommandPool = null;

        // The memory allocator
        let dmut _allocator : (&MemoryAllocator)? = none;

        // The allocator used to allocate descriptor sets
        let dmut _descPool : (&DescriptorAllocator)? = none;

        // The index of the frame being drawn
        let mut _currentFrame : u32 = 0u32;

    }
    
    prot { // Sync        
        
        // Semaphore used to signal when an image is ready
        let dmut _imageAvailableSem : [VkSemaphore] = [];

    }
    
    prot {
        // The context configuration
        let mut _cfg : &BalderConfig = copy BalderConfig::default ();

        // The list of extension required by the vulkan device
        let mut _requiredExtensions : [[c8] => mut ()] = copy [];

        // The number of nanoseconds per ticks
        let mut _nsPerTicks : f32 = 0.0f;
    }

    prot {
        
        // The transfer pass of the device 
        let dmut _transferPass : (&VulkanTransferPass)? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @params: 
     *    - app: the application holding the vulkan device
     */
    pub self () {}

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CONFIGURE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Configure the device using a given configuration
     * @params: 
     *    - config: the configuration to use for the device
     */
    pub fn configure (mut self, dmut win : &Window, cfg : &BalderConfig)
        throws BalderError
    {
        self:.dispose ();

        atomic self {
            self._win = (alias win)?;
            self._instance = alias win:.getVulkanInstance ();

            self._cfg = cfg;
            self._requiredExtensions [VK_KHR_SWAPCHAIN_EXTENSION_NAME] = ();

            self:.selectPhysicalDevice (alias win);
            self:.createLogicalDevice (alias win);

            // allocators
            self:.createMemoryAllocator ();
            self:.createDescriptorAllocator ();
            self:.createCommandPools ();
            
            // buffer images
            self:.createSwapchain (alias win);                        
            self:.createSyncObjects ();
            self:.createTransferPass ();
        }

        log::debug #("Device", "Device configured");
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================   GETTERS  ===========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the configuration of the device
     * */
    pub fn getConfiguration (self)-> &BalderConfig {
        self._cfg
    }

    /**
     * @returns: the number of nanoseconds per ticks
     * */
    pub fn getNsPerTicks (self)-> f32 {
        self._nsPerTicks
    }

    /**
     * @returns: the vulkan handle of the physical device (might be null)
     */
    pub fn getPhysicalDeviceHandle (self)-> VkPhysicalDevice {
        self._physicalDevice
    }

    /**
     * @returns: the handle of the logical device (can be null)
     */
    pub fn getDeviceHandle (self)-> VkDevice {
        self._device
    }

    /**
     * @returns: the window to which the device is attached
     * */
    pub fn getWindow (mut self)-> dmut &Window {
        if let Ok (dmut win) = alias self._win {
            return alias win;
        }

        log::error #("VulkanDevice", "no window on device");
        panic;
    }

    /**
     * @returns: the window to which the device is attached
     * */
    pub fn getWindow (self)-> &Window {
        if let Ok (win) = self._win {
            return win;
        }

        log::error #("VulkanDevice", "no window on device");
        panic;
    }

    /**
     * @returns: the pass used to send transfer commands to the device
     * */
    pub fn getTransferPass (mut self)-> dmut &VulkanTransferPass {
        if let Ok (dmut trn) = alias self._transferPass {
            return alias trn;
        }

        log::error #("VulkanDevice", "Transfer pass configuration failed");
        panic;        
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          SWAPCHAIN GETTERS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the swap chain used to render to screen
     * */
    pub fn getSwapchain (mut self)-> dmut &SwapChain {
        if let Ok (dmut swp) = alias self._swapChain {
            return alias swp;
        }

        log::error #("VulkanDevice", "Swap chain configuration failed");
        panic;
    }
    
    /**
     * @returns: the depth format of the selected device
     * */
    pub fn getDepthFormat (self)-> VkFormat {
        if let Ok (swp) = self._swapChain {
            return swp.depthFormat;
        }

        panic;
    }

    /**
     * @returns: the indices of the queue family used by the physical device (basically graphics and present)
     */
    pub fn getPhysicalDeviceFamilyIndices (self)-> [u32] {
        self._physicalDeviceFamilyIndices
    }

    /**
     * @returns: the number of uniq family indices
     */
    pub fn getPhysicalDeviceFamilyIndiceCounts (self)-> u32 {
        let mut res = 0u32;

        for i in 1 .. self._physicalDeviceFamilyIndices.len {
            let mut j = 0us;
            while j < i {
                if self._physicalDeviceFamilyIndices [i] == self._physicalDeviceFamilyIndices [j] {
                    break;
                }

                j += 1;
            }

            if i == j {
                res += 1;
            }
        }

        res
    }

    /**
     * @returns: the maximum number of samples that can be attached to an image
     * */
    pub fn getMaxSampleCounts (self)-> VkSampleCountFlagBits {
        let dmut properties = VkPhysicalDeviceProperties ();
        vkGetPhysicalDeviceProperties (self._physicalDevice, alias &properties);

        let count = properties.limits.framebufferColorSampleCounts & properties.limits.framebufferDepthSampleCounts;
        if (count & VkSampleCountFlagBits::VK_SAMPLE_COUNT_64_BIT) != 0 { return VkSampleCountFlagBits::VK_SAMPLE_COUNT_64_BIT };
        if (count & VkSampleCountFlagBits::VK_SAMPLE_COUNT_32_BIT) != 0 { return VkSampleCountFlagBits::VK_SAMPLE_COUNT_32_BIT };
        if (count & VkSampleCountFlagBits::VK_SAMPLE_COUNT_16_BIT) != 0 { return VkSampleCountFlagBits::VK_SAMPLE_COUNT_16_BIT };
        if (count & VkSampleCountFlagBits::VK_SAMPLE_COUNT_8_BIT) != 0 { return VkSampleCountFlagBits::VK_SAMPLE_COUNT_8_BIT };
        if (count & VkSampleCountFlagBits::VK_SAMPLE_COUNT_4_BIT) != 0 { return VkSampleCountFlagBits::VK_SAMPLE_COUNT_4_BIT };
        if (count & VkSampleCountFlagBits::VK_SAMPLE_COUNT_2_BIT) != 0 { return VkSampleCountFlagBits::VK_SAMPLE_COUNT_2_BIT };

        VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          COMMAND AND QUEUES          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the command pool used to create command buffers
     */
    pub fn getDrawCommandPool (self)-> VkCommandPool {
        self._drawPool
    }

    /**
     * @returns: the command pool used to create command buffers
     */
    pub fn getTransferCommandPool (self)-> VkCommandPool {
        self._memoryPool
    }

    /**
     * @returns: the graphics queue of the device
     */
    pub fn getGraphicsQueue (self)-> VkQueue {
        self._graphicsQueue
    }

    /**
     * @returns: the graphics queue of the device
     */
    pub fn getComputeQueue (self)-> VkQueue {
        self._computeQueue
    }


    /**
     * @returns: the graphics queue of the device
     */
    pub fn getTransferQueue (self)-> VkQueue {
        self._transferQueue
    }

    /**
     * @returns: the present queue of the device
     * */
    pub fn getPresentQueue (self)-> VkQueue {
        self._presentQueue
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          GETTER ALLOCATORS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the vma allocator of the device
     */
    pub fn getMemoryAllocator (mut self)-> dmut &MemoryAllocator {
        if let Ok (dmut a) = alias self._allocator {
            return alias a;
        }

        panic;
    }

    /**
     * @returns: the allocator for descriptor sets
     * */
    pub fn getDescriptorAllocator (mut self)-> dmut &DescriptorAllocator {
        if let Ok (dmut a) = alias self._descPool {
            return alias a;
        }

        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==========================          SYNCHRONIZATION AND DRAWING          ===========================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the index of the frame being drawn (on which command are sent)
     */
    pub fn getCurrentFrameIndex (self)-> u32 {
        self._currentFrame
    }

    /**
     * @returns: the number of frames in the swap chain
     */
    pub fn getNbFrames (self)-> u32 {
        cast!u32 (self._imageAvailableSem.len)
    }

    /**
     * @returns: true iif the swapchain is outdated
     * */
    pub fn needResize (self)-> bool {
        self._resizingWindow
    }

    /**
     * @returns: the semaphore to wait for the present image to be available
     * */
    pub fn getImageAvailableSemaphores (self)-> [VkSemaphore] {
        self._imageAvailableSem
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================   USAGE  =============================================
     * ======================================================================================================
     * ======================================================================================================
     */
        
    /**
     * Wait for the device to be idle
     */
    pub fn waitIdle (mut self) {
        if self._device != null {
            vkDeviceWaitIdle (self._device);
        }
    }

    /**
     * The window size changed so we need to inform the device
     */
    pub fn windowResize (mut self) {
        self._resizingWindow = true;
    }

    /**
     * Wait for an image to be available for rendering, and return its index
     * @returns:
     *    - .0: the image index
     *    - .1: true iif the image index is different from current frame, and therefore fences have to be awaited again
     */
    pub fn acquireNextImage (mut self)-> i32 {
        if let Ok (swp) = self._swapChain {
            use std::time::_;
            
            let mut imageIndex = 0u32;
            let result = vkAcquireNextImageKHR (self._device, swp.chain, u64::max, self._imageAvailableSem [self._currentFrame], null, alias &imageIndex);
            if (result == VkResult::VK_ERROR_OUT_OF_DATE_KHR) {
                self._resizingWindow = true;
                return -1;                
            }
            else if (result != VkResult::VK_SUCCESS && result != VkResult::VK_SUBOPTIMAL_KHR) {
                self._resizingWindow = true;
                return -1;
            } 

            return cast!i32 (imageIndex);                        
        }

        return -1;
    }

    /**
     * Wait the inflight frame to be rendered and present it to the window surface
     */
    pub fn presentScreen (mut self, image : u32)-> VkResult {
        if let Ok (swp) = self._swapChain {
            atomic self {                
                let r = swp.present (image, self._currentFrame);
                if (r == VkResult::VK_ERROR_OUT_OF_DATE_KHR || r == VkResult::VK_SUBOPTIMAL_KHR) {
                    self._resizingWindow = true;
                } else if (r != VkResult::VK_SUCCESS) {
                    log::error #("Device", "Error present screen queue present : ", self._currentFrame, " ", image);
                    return r;
                }
                
                self._currentFrame = (self._currentFrame + 1u32) % cast!u32 (swp.nbFrames);
                return VkResult::VK_SUCCESS;
            }
        }

        VkResult::VK_ERROR_UNKNOWN
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   MEM ALLOCATOR  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the memory allocator used to allocated memory buffers
     * */
    prv fn createMemoryAllocator (mut self) {
        self._allocator = (copy MemoryAllocator (alias self))?;
    }

    /**
     * Create the memory allocator used to allocate descriptor pool and sets
     * */
    prv fn createDescriptorAllocator (mut self) {
        self._descPool = (copy DescriptorAllocator (alias self))?;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   COMMAND POOL  =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create a command pool for the device used to instantiate command buffers on the graphic queue
     */
    prv fn createCommandPools (mut self)
        throws BalderError
    {
        {
            let mut poolInfo = VkCommandPoolCreateInfo ();
            poolInfo.sType            = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
            poolInfo.flags            = cast!u32 (VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
            poolInfo.queueFamilyIndex = self._physicalDeviceFamilyIndices [1];

            if (vkCreateCommandPool (self._device, &poolInfo, null, alias &self._drawPool) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create the draw pool");
            }
        }

        {
            let mut poolInfo = VkCommandPoolCreateInfo ();
            poolInfo.sType            = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
            poolInfo.flags            = cast!u32 (VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
            poolInfo.queueFamilyIndex = self._physicalDeviceFamilyIndices [2];

            if (vkCreateCommandPool (self._device, &poolInfo, null, alias &self._memoryPool) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create the memory pool");
            }
        }
    }
    
    /**
     * Create the synchronization object used to synchronize frame rendering and pregsenting
     */
    prv fn createSyncObjects (mut self)
        throws BalderError
    {        
        self._imageAvailableSem     = copy [null ; self:.getSwapchain ().nbFrames];
        
        for i in 0 .. self._imageAvailableSem.len {
            let mut semInfo = VkSemaphoreCreateInfo ();
            semInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
            
            if (vkCreateSemaphore (self._device, &semInfo, null, alias &self._imageAvailableSem [i]) != VkResult::VK_SUCCESS) {            
                throw copy BalderError ("Failed to create available semaphore");
            }            
        }        
    }

    /**
     * Create the pass containing the transfer commands
     * */
    prv fn createTransferPass (mut self)
        throws BalderError
    {
        let dmut trn = copy VulkanTransferPass (alias self, self._imageAvailableSem);
        self._transferPass = (alias trn)?;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   SWAP CHAIN  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the swapchain of the device
     * */
    fn createSwapchain (mut self, dmut win : &Window)
        throws BalderError
    {
        let dmut swp = copy SwapChain (alias self);        
        self._swapChain = (alias swp)?;

        swp:.configure (alias win, self._cfg);
    }

    /**
     * Recreate the swapchain that became obsolete
     */
    pub fn recreateSwapchain (mut self)
        throws BalderError
    {
        vkDeviceWaitIdle (self._device);

        atomic self {
            if let Ok (dmut swp) = alias self._swapChain {
                if let Ok (dmut win) = alias self._win {
                    swp:.reconfigure (alias win, self._cfg);
                    self._currentFrame = 0;
                } else {
                    throw copy BalderError ("Malformed device");
                }                        
            } else {
                throw copy BalderError ("Malformed device");
            }
        }

        self._resizingWindow = false;
        log::debug #("Device", "Recreated swap chain");
    }

    /**
     * Dispose the swap chain and its components
     */
    pub fn disposeSwapchain (mut self) {
        if let Ok (dmut swp) = alias self._swapChain {
            swp:.dispose ();
            self._swapChain = none;
        }
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===========================================   LOGICAL DEVICE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the logical device to attach to the selected physical device to render things
     */
    fn createLogicalDevice (mut self, dmut _ : &Window)
        throws BalderError
    {
        let mut priority = 1.0f;

        let mut uniq : [u32 => mut ()] = copy [];
        let mut v : [mut VkDeviceQueueCreateInfo] = [];

        for i in self._physicalDeviceFamilyIndices {
            if (i !in uniq) {
                let mut queue = VkDeviceQueueCreateInfo ();
                queue.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
                queue.queueFamilyIndex = i;
                queue.queueCount = 1u32;
                queue.pQueuePriorities = &priority;

                v ~= [queue];
                uniq [i] = ();
            }
        }

        let mut queueCreateInfos = v;
        let mut logFeatures = VkPhysicalDeviceFeatures ();
        if self._cfg.vulkan.anisotropy {
            logFeatures.samplerAnisotropy = VK_TRUE;
        }

        logFeatures.geometryShader = VK_TRUE;

        let mut extensions = copy [std::conv::toStringZ (i) for i in self._requiredExtensions];

        let mut createInfo = VkDeviceCreateInfo ();
        createInfo.sType                   = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        createInfo.pQueueCreateInfos       = queueCreateInfos.ptr;
        createInfo.queueCreateInfoCount    = cast!u32 (queueCreateInfos.len);
        createInfo.pEnabledFeatures        = &logFeatures;
        createInfo.enabledExtensionCount   = cast!u32 (extensions.len);
        createInfo.ppEnabledExtensionNames = extensions.ptr;

        if (vkCreateDevice (self._physicalDevice, &createInfo, null, alias &self._device) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create logical device");
        }

        vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [0], 0u32, alias &self._graphicsQueue);        
        vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [1], 0u32, alias &self._presentQueue);
        vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [2], 0u32, alias &self._transferQueue);
        vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [3], 0u32, alias &self._computeQueue);

        if (self._graphicsQueue == null) throw copy BalderError ("Failed to retreive graphics queue");
        if (self._computeQueue == null) throw copy BalderError ("Failed to retreive compute queue");
        if (self._presentQueue == null) throw copy BalderError ("Failed to retreive present queue");
        if (self._transferQueue == null) throw copy BalderError ("Failed to retreive transfer queue");

        log::debug #("Device", "Created logical device");
    }

    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===========================================   PHYSICAL DEVICE  =======================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * List all available devices and select the best one for rendering
     */
    fn selectPhysicalDevice (mut self, dmut win : &Window)
        throws BalderError
    {
        let mut deviceCount = 0u32;
        if (self._instance:.getHandle () == null) throw copy BalderError ("Invalid vulkan instance");

        vkEnumeratePhysicalDevices (self._instance:.getHandle (), alias &deviceCount, null);
        if (deviceCount == 0u32) throw copy BalderError ("No available devices");

        let dmut devices : [VkPhysicalDevice] = copy [null ; deviceCount];
        vkEnumeratePhysicalDevices (self._instance:.getHandle (), alias &deviceCount, alias devices.ptr);

        let mut maxScore = 0;
        for i in 0u32 .. deviceCount {
            let (name, score, fam, nsTicks) = self.ratePhysicalDevice (win:.getVulkanSurface (), devices [i]);
            if (maxScore <= score) {
                self._physicalDevice = alias devices [i];
                self._physicalDeviceName = name;
                self._physicalDeviceFamilyIndices = fam;
                self._nsPerTicks = nsTicks;
                maxScore = score;
            }
        }
        
        if (self._physicalDevice == null) throw copy BalderError ("No suitable device found");
        log::debug #("Device", "Selected physical device : ", self._physicalDeviceName);
    }

    /**
     * @returns: a score for the physical device, -1 if the device is not suitable
     */
    fn ratePhysicalDevice (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> ([c8], i32, [u32], f32) {
        let dmut properties = VkPhysicalDeviceProperties ();
        let dmut features = VkPhysicalDeviceFeatures ();
        let dmut memProperties = VkPhysicalDeviceMemoryProperties ();

        vkGetPhysicalDeviceProperties (device, alias &properties);
        vkGetPhysicalDeviceFeatures (device, alias &features);
        vkGetPhysicalDeviceMemoryProperties (device, alias &memProperties);

        let name = unsafe {
            fromStringZ (properties.deviceName.ptr)
        };
        
        if (features.geometryShader == 0u32) return ("", -1, [], 0.0f);

        let family = self.findQueueFamily (surface, device);
        if (!family._0) return ("", -1, [], 0.0f);
        if (!self.checkDeviceExtensionSupport (device)) return ("", -1, [], 0.0);

        let mut formatCount = 0u32;
        vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, null);
        if formatCount == 0 return ("", -1, [], 0.0f);

        let mut presentCount = 0u32;
        vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, null);
        if presentCount == 0 return ("", -1, [], 0.0f);

        let mut score = cast!i32 (properties.limits.maxImageDimension2D);

        if properties.deviceType == VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU {
            score += 1000;
        }

        if properties.deviceType == VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU {
            score += 2000;
        }

        if self._cfg.vulkan.device != "" {
            if name == self._cfg.vulkan.device {
                score = 1;
            } else score = 0;
        }

        log::debug #("Device", "Rating physical device : ", name, " = ", score);
        (name, score, copy [family._1, family._2, family._3, family._4], properties.limits.timestampPeriod)
    }

    /**
     * Find the indices of the queue family (graphics, present and transfer)
     */
    fn findQueueFamily (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> (bool, u32, u32, u32, u32) {
        let mut gr = 0u32, mut pr = 0u32, mut tr = 0u32, mut cp = 0u32;
        let mut foundGr = false, mut foundPr = false, mut foundTr = false, mut foundCp = false;

        let mut queueFamilyCount = 0u32;
        vkGetPhysicalDeviceQueueFamilyProperties (device, alias &queueFamilyCount, null);

        if (queueFamilyCount != 0u32) {
            let dmut queueFamilies = copy [VkQueueFamilyProperties () ; queueFamilyCount];
            vkGetPhysicalDeviceQueueFamilyProperties (device, alias &queueFamilyCount, alias queueFamilies.ptr);

            for i, q in queueFamilies {
                if (q.queueFlags & cast!u32 (VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT) != 0u32) {
                    gr = cast!u32 (i);
                    foundGr = true;
                }

                if (q.queueFlags & cast!u32 (VkQueueFlagBits::VK_QUEUE_COMPUTE_BIT) != 0u32) {
                    cp = cast!u32 (i);
                    foundCp = true;
                }
                
                if (q.queueFlags & cast!u32 (VkQueueFlagBits::VK_QUEUE_TRANSFER_BIT) != 0u32) {
                    tr = cast!u32 (i);
                    foundTr = true;
                }

                let mut presentSupport = VK_FALSE;
                vkGetPhysicalDeviceSurfaceSupportKHR (device, cast!u32 (i), surface, alias &presentSupport);
                if (presentSupport != VK_FALSE) {
                    pr = cast!u32 (i);
                    foundPr = true;
                }

                if (foundPr && foundGr && foundTr && foundCp) break;
            }
        }

        return (foundGr && foundPr && foundTr && foundCp, gr, pr, tr, cp);
    }

    /**
     * @returns: true if the physical device has the correct extension for the balder engine to work, false otherwise
     */
    fn checkDeviceExtensionSupport (self, device : VkPhysicalDevice)-> bool {
        let mut extensionCount = 0u32;
        vkEnumerateDeviceExtensionProperties (device, null, alias &extensionCount, null);

        if (extensionCount != 0u32) {
            let dmut availableExtensions = copy [VkExtensionProperties () ; extensionCount];
            vkEnumerateDeviceExtensionProperties (device, null, alias &extensionCount, alias availableExtensions.ptr);

            let dmut required = copy self._requiredExtensions;
            for a in availableExtensions {
                unsafe {
                    required:.remove (fromStringZ (a.extensionName.ptr));
                }
            }

            return required.len == 0us;
        }

        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            atomic self {
                self._requiredExtensions = copy [];
                self._win = none;

                // No need to destroy the command buffers, they are managed by the pool
                if (self._drawPool != null) {
                    vkDestroyCommandPool (self._device, self._drawPool, null);
                    self._drawPool = null;                    
                }

                if self._memoryPool != null {
                    vkDestroyCommandPool (self._device, self._memoryPool, null);
                    self._memoryPool = null;
                }

                self:.disposeSwapchain ();

                if let Ok (dmut trn) = alias self._transferPass {
                    trn:.dispose ();
                    self._transferPass = none;
                }
                
                if let Ok (dmut a) = alias self._allocator {
                    a:.dispose ();
                    self._allocator = none;
                }

                if let Ok (dmut d) = alias self._descPool {
                    d:.dispose ();
                    self._descPool = none;
                }


                for i in 0 .. self._imageAvailableSem.len {                    
                    // We dispose the three elements at the same time, they are always constructed and used together
                    vkDestroySemaphore (self._device, self._imageAvailableSem [i], null);                    
                }
                
                self._imageAvailableSem = [];
                
                if (self._device != null) {
                    vkDestroyDevice (self._device, null);
                    self._device = null;
                    self._graphicsQueue = null;
                    self._presentQueue = null;
                    self._computeQueue = null;
                    self._transferQueue = null;

                    log::debug #("Device", "Disposing device");
                }

                self._physicalDevice = null;
                self._physicalDeviceName = "";
                self._physicalDeviceFamilyIndices = [];
            }
        }
    }

}
