in device;

use vulkan::_;
use balder::core::{_, driver::_, memory::_, application::_};
use balder::utils::log;
use sdl2::_;

use std::{io, conv, config::_, time::_};


record SwapChainDetail {
    pub let mut capabilities : VkSurfaceCapabilitiesKHR;
    pub let mut formats : [VkSurfaceFormatKHR];
    pub let mut presents : [VkPresentModeKHR];

    pub self ()
        with capabilities = VkSurfaceCapabilitiesKHR ()
        , formats = []
        , presents = []
    {}

    pub self (capabilities : VkSurfaceCapabilitiesKHR, formats : [VkSurfaceFormatKHR], presents : [VkPresentModeKHR])
        with capabilities = capabilities
        , formats = formats
        , presents = presents
    {}
}

/**
 * A vulkan device used to manage vulkan rendering tools
 */
pub class VulkanDevice {

    // The pointer to the window holding the device
    let dmut _win : (&Window)? = none;
    
    // The vulkan instance used to configure vulkan lib
    let dmut _instance : &VulkanInstance = copy VulkanInstance ();

    prot {
        
        // The logical device handle of vulkan
        let dmut _device : VkDevice = null;
        
        // The graphics queue
        let dmut _graphicsQueue : VkQueue = null;

        // The present queue
        let dmut _presentQueue : VkQueue = null;
        
    }

    prot {    
        // The handle of the physical device of vulkan
        let dmut _physicalDevice : VkPhysicalDevice = null;
        
        // The name of the physical device in use
        let mut _physicalDeviceName = "";

        // The indices for graphics and present 
        let mut _physicalDeviceFamilyIndices : [u32] = [];

        // The detail of the capabilities of the swap chain of the physical device
        let mut _physicalDeviceSwapChainDetail = SwapChainDetail ();
    }    

    prot {

        // The size of the swap chain
        let mut _swapChainExtent = VkExtent2D ();

        // The format of the swap chain
        let mut _swapChainFormat = VkFormat::VK_FORMAT_MAX_ENUM;

        // The swap chain of the device to render, and display using different images
        let dmut _swapChain : VkSwapchainKHR = null;

        // The image attached to the swap chain
        let dmut _swapChainImages : [VkImage] = [];
        
        // The view of the images attach to each frame of the swap chain
        let dmut _swapChainImageViews : [VkImageView] = [];

        // The framebuffers attached to the image view of the swap chain
        let dmut _swapChainFramebuffers : [VkFramebuffer] = [];

        // True when the window was resized and the swap chain needs to be recreated
        let mut _resizingWindow = false;
        
    }

    prot {

        // The render pass of the device
        let dmut _renderPass : VkRenderPass = null;

        // The color used when clearing an image of the swap chain;
        let dmut _clearColor : [VkClearValue] = [];

        // The begin info used when begining the render pass
        let dmut _renderPassBeginInfo : VkRenderPassBeginInfo = VkRenderPassBeginInfo ();

    }

    prot {
        
        // The command pool of the device
        let dmut _commandPool : VkCommandPool = null;

        // The command buffer for recording (one per frame in flight)
        let dmut _commandBuffers : [VkCommandBuffer] = [];

        // The number of image in the swapchain
        let mut _imageCount = 0u32;
        
        // The fences to synchronize inflight frames
        let dmut _inFlightFences : [VkFence] = [];

        // Semaphore used to signal when an image is ready
        let dmut _imageAvailableSem : [VkSemaphore] = [];

        // Semaphore used to signal that an image is finished rendering
        let dmut _renderFinishedSem : [VkSemaphore] = [];
        
        // The memory allocator
        let dmut _allocator : (&MemoryAllocator)? = none;

        // The allocator used to allocate descriptor sets
        let dmut _descPool : (&DescriptorAllocator)? = none;

        // The index of the frame being drawn
        let mut _currentFrame = 0u32;

    }
    
    prot {
        // The configuration of the device
        let mut _config : &Config = copy Dict ();

        // The list of extension required by the vulkan device
        let mut _requiredExtensions : [[c8] => mut ()] = copy [];
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * @params: 
     *    - app: the application holding the vulkan device
     */
    pub self () {}

    /**
     * Configure the device using a given configuration
     * @params: 
     *    - config: the configuration to use for the device
     */
    pub fn configure (mut self, dmut win : &Window, config : &Config)
        throws BalderError
    {
        self:.dispose ();

        atomic self {
            self._win = (alias win)?;
            self._instance = alias win:.getVulkanInstance ();

            self._config = config;
            self._requiredExtensions [VK_KHR_SWAPCHAIN_EXTENSION_NAME] = ();

            self:.selectPhysicalDevice (alias win);
            self:.createLogicalDevice (alias win);
            self:.createSwapchain (alias win);
            self:.createImageViews (alias win);
            self:.createRenderPass (alias win);
            self:.createFramebuffers (alias win);
            self:.createCommandPool (alias win);
            self:.createCommandBuffers (alias win);
            self:.createSyncObjects ();
            self:.createMemoryAllocator ();
            self:.createDescriptorAllocator ();
        }

        log::info ("Device configured");
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================   GETTERS  ===========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the vulkan handle of the physical device (might be null)
     */
    pub fn getPhysicalDeviceHandle (mut self)-> dmut VkPhysicalDevice {
        alias self._physicalDevice
    }

    /**
     * @returns: the handle of the logical device (can be null)
     */
    pub fn getDeviceHandle (mut self)-> dmut VkDevice {
        alias self._device
    }

    /**
     * @returns: the extent of the current swap chain
     */
    pub fn getSwapchainExtent (self)-> VkExtent2D {
        self._swapChainExtent
    }

    /**
     * @returns: the format used by the current swapchain
     */
    pub fn getSwapchainFormat (self)-> VkFormat {
        self._swapChainFormat
    }

    /**
     * @returns: the vulkan handle of the render pass
     */
    pub fn getRenderPass (mut self)-> dmut VkRenderPass {
        alias self._renderPass
    }

    /**
     * @returns: the command buffer of the rendering frame
     */
    pub fn getCommandBuffer (mut self)-> dmut VkCommandBuffer {
        alias self._commandBuffers [self._currentFrame]
    }

    pub fn getSwapchainNbFrames (self)-> u32 {
        cast!u32 (self._swapChainFramebuffers.len)
    }

    /**
     * @returns: the command pool used to create command buffers
     */
    pub fn getCommandPool (mut self)-> dmut VkCommandPool {
        alias self._commandPool
    }

    /**
     * @returns: the graphics queue of the device
     */
    pub fn getGraphicsQueue (mut self)-> dmut VkQueue {
        alias self._graphicsQueue
    }

    /**
     * @returns: the vma allocator of the device
     */
    pub fn getMemoryAllocator (mut self)-> dmut &MemoryAllocator {
        if let Ok (dmut a) = alias self._allocator {
            return alias a;
        }

        panic;
    }

    /**
     * @returns: the allocator for descriptor sets
     * */
    pub fn getDescriptorAllocator (mut self)-> dmut &DescriptorAllocator {
        if let Ok (dmut a) = alias self._descPool {
            return alias a;
        }

        panic;
    }

    /**
     * @returns: the index of the frame being drawn (on which command are sent)
     */
    pub fn getCurrentFrameIndex (self)-> u32 {
        self._currentFrame
    }

    /**
     * Change the current frame index
     * @assume: i < self.getSwapchainNbFrames ()
     */
    pub fn setCurrentFrameIndex (mut self, i : u32) {
        self._currentFrame = i;
    }

    /**
     * Reset the command buffers
     */
    pub fn clearCommandBuffer (mut self) {
        vkResetCommandBuffer (self._commandBuffers [self._currentFrame], 0u32);
    }

    /**
     * @returns: the indices of the queue family used by the physical device (basically graphics and present)
     */
    pub fn getPhysicalDeviceFamilyIndices (self)-> [u32] {
        self._physicalDeviceFamilyIndices
    }

    /**
     * @returns: the number of uniq family indices
     */
    pub fn getPhysicalDeviceFamilyIndiceCounts (self)-> u32 {
        if (self._physicalDeviceFamilyIndices [0] == self._physicalDeviceFamilyIndices [1]) {
            1u32
        } else 2u32
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================   USAGE  =============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Wait for the previous frame to be finished rendering
     */
    pub fn waitPreviousFrame (mut self) {
        vkWaitForFences (self._device, 1u32, &self._inFlightFences [self._currentFrame], VK_TRUE, u64::max);
    }

    /**
     * Wait for the device to be idle
     */
    pub fn waitIdle (mut self) {
        vkDeviceWaitIdle (self._device);
    }

    /**
     * The window size changed so we need to inform the device
     */
    pub fn windowResize (mut self) {
        self._resizingWindow = true;
    }

    /**
     * @returns: true iif the swapchain is outdated
     * */
    pub fn needResize (self)-> bool {
        self._resizingWindow
    }

    /**
     * Wait for an image to be available for rendering, and return its index
     */
    pub fn acquireNextImage (mut self)-> i32 {
        use std::time::_;

        let mut imageIndex = 0u32;

        let result = vkAcquireNextImageKHR (self._device, self._swapChain, u64::max, self._imageAvailableSem [self._currentFrame], null, alias &imageIndex);
        if (result == VkResult::VK_ERROR_OUT_OF_DATE_KHR) {
            self._resizingWindow = true;
            return -1;
        }
        else if (result != VkResult::VK_SUCCESS && result != VkResult::VK_SUBOPTIMAL_KHR) {
            self._resizingWindow = true;
            return -1;
        }

        vkResetFences (self._device, 1u32, &self._inFlightFences [self._currentFrame]);

        return cast!i32 (imageIndex);
    }

    /**
     * Start the recording of drawing
     */
    pub fn startRecording (mut self)-> VkResult {
        let mut cmdBegin = VkCommandBufferBeginInfo ();
        cmdBegin.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

        vkBeginCommandBuffer (self._commandBuffers [self._currentFrame], &cmdBegin)
    }

    /**
     * Stop the recording of drawing
     * @assume the recording was started
     */
    pub fn stopRecording (mut self)-> VkResult {
        vkEndCommandBuffer (self._commandBuffers [self._currentFrame])
    }

    /**
     * Start a the render pass
     * @params:
     *    - imageIndex: the index of the image to use for rendering
     * @assume: imageIndex was acquired with self:.acquireNextImage ()
     */
    pub fn startRenderPass (mut self, imageIndex : u32) {
        let mut pass = VkRenderPassBeginInfo ();
        pass.sType             = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        pass.renderPass        = self._renderPass;
        pass.renderArea.extent = self._swapChainExtent;
        pass.clearValueCount   = 2u32;
        pass.pClearValues      = self._clearColor.ptr;
        pass.framebuffer = self._swapChainFramebuffers [imageIndex];

        vkCmdBeginRenderPass (self._commandBuffers [self._currentFrame], &pass, VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE)
    }

    /**
     * Stop the render pass
     * @assume: it was started
     */
    pub fn stopRenderPass (mut self) {
        vkCmdEndRenderPass (self._commandBuffers [self._currentFrame]);
    }

    /**
     * Wait the inflight frame to be rendered and present it to the window surface
     */
    pub fn presentScreen (mut self, image : u32)-> VkResult {
        let waitStages : u32 = cast!u32 (VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);

        let mut submitInfo = VkSubmitInfo ();
        submitInfo.sType                = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.waitSemaphoreCount   = 1u32;
        submitInfo.pWaitSemaphores      = &self._imageAvailableSem [self._currentFrame];
        submitInfo.pWaitDstStageMask    = &waitStages;
        submitInfo.commandBufferCount   = 1u32;
        submitInfo.pCommandBuffers      = &self._commandBuffers [self._currentFrame];
        submitInfo.signalSemaphoreCount = 1u32;
        submitInfo.pSignalSemaphores    = &self._renderFinishedSem [self._currentFrame];

        let r = vkQueueSubmit (self._graphicsQueue, 1u32, &submitInfo, self._inFlightFences [self._currentFrame]);
        if (r != VkResult::VK_SUCCESS) {
            log::error ("Error present screen queue submit : ", self._currentFrame, " ", image);
            return r;
        }

        let mut presentInfo = VkPresentInfoKHR ();
        presentInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        presentInfo.waitSemaphoreCount = 1u32;
        presentInfo.pWaitSemaphores    = &self._renderFinishedSem [self._currentFrame];
        presentInfo.swapchainCount     = 1u32;
        presentInfo.pSwapchains        = &self._swapChain;
        presentInfo.pImageIndices      = &image;

        let r2 = vkQueuePresentKHR (self._presentQueue, &presentInfo);
        if (r2 == VkResult::VK_ERROR_OUT_OF_DATE_KHR || r2 == VkResult::VK_SUBOPTIMAL_KHR) {
            self._resizingWindow = true;
        } else if (r2 != VkResult::VK_SUCCESS) {
            log::error ("Error present screen queue present : ", self._currentFrame, " ", image);
            return r2;
        }

        self._currentFrame = (self._currentFrame + 1u32) % cast!u32 (self._swapChainFramebuffers.len);

        return VkResult::VK_SUCCESS;
    }

    /**
     * Create a command buffer for a single time command
     */
    pub fn beginSingleTimeCommand (mut self)-> dmut VkCommandBuffer {
        let mut allocInfo = VkCommandBufferAllocateInfo ();
        allocInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level              = VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool        = self._commandPool;
        allocInfo.commandBufferCount = 1u32;

        let dmut cmd : VkCommandBuffer = null;
        vkAllocateCommandBuffers (self._device, &allocInfo, alias &cmd);

        let mut beginInfo = VkCommandBufferBeginInfo ();
        beginInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = cast!u32 (VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT);

        vkBeginCommandBuffer (cmd, &beginInfo);
        return alias cmd;
    }

    /**
     * End a command that was created by 'self:.beginSingleTimeCommand ()'
     * @params:
     *     - cmd: the command to end
     * @warning: the command buffer is unusable afterwards
     */
    pub fn endSingleTimeCommand (mut self, dmut cmd : VkCommandBuffer) {
        vkEndCommandBuffer (cmd);
        let mut submitInfo = VkSubmitInfo ();
        submitInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.commandBufferCount = 1u32;
        submitInfo.pCommandBuffers    = &cmd;

        vkQueueSubmit (self._graphicsQueue, 1u32, &submitInfo, null);
        vkQueueWaitIdle (self._graphicsQueue);

        vkFreeCommandBuffers (self._device, self._commandPool, 1u32, &cmd);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   MEM ALLOCATOR  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    prv fn createMemoryAllocator (mut self) {
        self._allocator = (copy MemoryAllocator (alias self))?;
    }

    prv fn createDescriptorAllocator (mut self) {
        self._descPool = (copy DescriptorAllocator (alias self))?;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   COMMAND POOL  =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create a command pool for the device used to instantiate command buffers on the graphic queue
     */
    prv fn createCommandPool (mut self, dmut _ : &Window)
        throws BalderError
    {
        let mut poolInfo = VkCommandPoolCreateInfo ();
        poolInfo.sType            = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
        poolInfo.flags            = cast!u32 (VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
        poolInfo.queueFamilyIndex = self._physicalDeviceFamilyIndices [1];

        if (vkCreateCommandPool (self._device, &poolInfo, null, alias &self._commandPool) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create the command poll");
        }
    }

    /**
     * Create the command buffers of the device
     */
    prv fn createCommandBuffers (mut self, dmut _ : &Window)
        throws BalderError
    {
        self._commandBuffers = copy [null ; self._swapChainFramebuffers.len];
        let mut allocInfo = VkCommandBufferAllocateInfo ();
        allocInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.commandPool        = self._commandPool;
        allocInfo.level              = VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandBufferCount = cast!u32 (self._commandBuffers.len);

        if (vkAllocateCommandBuffers (self._device, &allocInfo, alias self._commandBuffers.ptr) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to allocate command buffers");
        }
    }

    /**
     * Create the synchronization object used to synchronize frame rendering and presenting
     */
    prv fn createSyncObjects (mut self)
        throws BalderError
    {
        self._inFlightFences = copy [null ; self._swapChainFramebuffers.len];
        self._imageAvailableSem = copy [null ; self._swapChainFramebuffers.len];
        self._renderFinishedSem = copy [null ; self._swapChainFramebuffers.len];

        let mut semInfo = VkSemaphoreCreateInfo ();
        semInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

        let mut fenceInfo = VkFenceCreateInfo ();
        fenceInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        fenceInfo.flags = cast!u32 (VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT);

        for i in 0u32 .. self._swapChainFramebuffers.len {
            let r1 = vkCreateSemaphore (self._device, &semInfo, null, alias &self._imageAvailableSem [i]);
            let r2 = vkCreateSemaphore (self._device, &semInfo, null, alias &self._renderFinishedSem [i]);
            let r3 = vkCreateFence (self._device, &fenceInfo, null, alias &self._inFlightFences [i]);
            if (r1 != VkResult::VK_SUCCESS || r2 != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create semaphores");
            }

            if (r3 != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create fence");
            }
        }
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   RENDER PASS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the render pass attached to the images of the swapchain
     */
    fn createRenderPass (mut self, dmut _ : &Window)
        throws BalderError
    {
        let mut colorAttachement = VkAttachmentDescription ();
        colorAttachement.format         = self._swapChainFormat;
        colorAttachement.samples        = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        colorAttachement.loadOp         = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR;
        colorAttachement.storeOp        = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
        colorAttachement.stencilLoadOp  = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        colorAttachement.stencilStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        colorAttachement.initialLayout  = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        colorAttachement.finalLayout    = VkImageLayout::VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

        let mut colorAttachementRef = VkAttachmentReference ();
        colorAttachementRef.layout = VkImageLayout::VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        let mut subPass = VkSubpassDescription ();
        subPass.pipelineBindPoint    = VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
        subPass.colorAttachmentCount = 1u32;
        subPass.pColorAttachments    = &colorAttachementRef;

        let mut dependency = VkSubpassDependency ();
        dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
        dependency.dstSubpass = 0;
        dependency.srcStageMask = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        dependency.srcAccessMask = 0;
        dependency.dstStageMask = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        dependency.dstAccessMask = VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

        let mut renderPassInfo = VkRenderPassCreateInfo ();
        renderPassInfo.sType           = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
        renderPassInfo.attachmentCount = 1u32;
        renderPassInfo.pAttachments    = &colorAttachement;
        renderPassInfo.subpassCount    = 1u32;
        renderPassInfo.pSubpasses      = &subPass;
        renderPassInfo.dependencyCount = 1;
        renderPassInfo.pDependencies   = &dependency;

        if (vkCreateRenderPass (self._device, &renderPassInfo, null, alias &self._renderPass) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create render pass");
        }

        self._clearColor = copy [VkClearValue () ; 2];
        self._clearColor [0].color.float32 = [0.f, 0.f, 0.f, 1.f];
        self._clearColor [1].depthStencil.depth = 0.0f;

        log::info ("Created render pass");
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   IMAGE VIEWS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the image views of each swap frame of the swapchain
     */
    fn createImageViews (mut self, dmut _ : &Window)
        throws BalderError
    {
        self._swapChainImageViews = copy [null ; self._swapChainImages.len];
        let mut components = VkComponentMapping ();
        components.r = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
        components.g = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
        components.b = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
        components.a = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;

        let mut range = VkImageSubresourceRange ();
        range.aspectMask = cast!u32 (VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT);
        range.levelCount = 1u32;
        range.layerCount = 1u32;

        for i in 0us .. self._swapChainImages.len {
            let mut createInfo = VkImageViewCreateInfo ();
            createInfo.sType            = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            createInfo.image            = self._swapChainImages [i];
            createInfo.viewType         = VkImageViewType::VK_IMAGE_VIEW_TYPE_2D;
            createInfo.format           = self._swapChainFormat;
            createInfo.components       = components;
            createInfo.subresourceRange = range;

            if (vkCreateImageView (self._device, &createInfo, null, alias &self._swapChainImageViews[i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create image view");
            }
        }

        log::info ("Created image views : ", self._swapChainImages.len);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   FRAMEBUFFERS  =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the framebuffers of the image view in the swapchain
     */
    fn createFramebuffers (mut self, dmut _ : &Window)
        throws BalderError
    {
        self._swapChainFramebuffers = copy [null ; self._swapChainImageViews.len];
        for i in 0us .. self._swapChainImageViews.len {
            let mut framebufferInfo = VkFramebufferCreateInfo ();
            framebufferInfo.sType           = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
            framebufferInfo.renderPass      = self._renderPass;
            framebufferInfo.attachmentCount = 1u32;
            framebufferInfo.pAttachments    = &self._swapChainImageViews [i];
            framebufferInfo.width           = self._swapChainExtent.width;
            framebufferInfo.height          = self._swapChainExtent.height;
            framebufferInfo.layers          = 1u32;

            if (vkCreateFramebuffer (self._device, &framebufferInfo, null, alias &self._swapChainFramebuffers[i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create framebuffers");
            }
        }

        log::info ("Created frame buffers : ", self._swapChainImageViews.len);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   SWAP CHAIN  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the swap chain the allows to render to the window in a fluid way
     */
    fn createSwapchain (mut self, dmut win : &Window)
        throws BalderError
    {
        self._physicalDeviceSwapChainDetail = self.querySwapChainSupport (win:.getVulkanSurface (), self._physicalDevice);
        let surfaceFormat = self.chooseSwapSurfaceFormat (self._physicalDeviceSwapChainDetail.formats);
        let vsync = if let Ok (Bool (value-> b)) = self._config ["vsync"]? { b } else { true };

        let presentMode = self.chooseSwapPresentMode (self._physicalDeviceSwapChainDetail.presents, vsync);
        let imageCount = self.chooseImageCount ();

        self._swapChainFormat = surfaceFormat.format;
        self._swapChainExtent = self.chooseSwapChainExtent (win.getDimension (), self._physicalDeviceSwapChainDetail.capabilities);

        let sharingMode = if (self._graphicsQueue == self._presentQueue) {
            VkSharingMode::VK_SHARING_MODE_EXCLUSIVE
        } else { VkSharingMode::VK_SHARING_MODE_CONCURRENT };

        let indices = if (self._graphicsQueue != self._presentQueue) {
            self._physicalDeviceFamilyIndices
        } else { [] };

        let mut createInfo = VkSwapchainCreateInfoKHR ();
        createInfo.sType                 = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
        createInfo.surface               = win:.getVulkanSurface ();
        createInfo.minImageCount         = imageCount;
        createInfo.imageFormat           = self._swapChainFormat;
        createInfo.imageColorSpace       = surfaceFormat.colorSpace;
        createInfo.imageExtent           = self._swapChainExtent;
        createInfo.imageArrayLayers      = 1u32;
        createInfo.imageUsage            = cast!u32 (VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);
        createInfo.imageSharingMode      = sharingMode;
        createInfo.pQueueFamilyIndices   = indices.ptr;
        createInfo.queueFamilyIndexCount = cast!u32 (indices.len);
        createInfo.preTransform          = self._physicalDeviceSwapChainDetail.capabilities.currentTransform;
        createInfo.compositeAlpha        = VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
        createInfo.presentMode           = presentMode;
        createInfo.clipped               = VK_TRUE;

        if (vkCreateSwapchainKHR (self._device, &createInfo, null, alias &self._swapChain) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create swap chain");
        }

        let mut imageCreated = 0u32;
        vkGetSwapchainImagesKHR (self._device, self._swapChain, alias &imageCreated, null);
        self._swapChainImages = copy [null ; imageCreated];
        vkGetSwapchainImagesKHR (self._device, self._swapChain, alias &imageCreated, alias self._swapChainImages.ptr);

        self._imageCount = imageCreated;

        log::info ("Created swap chain");
    }

    /**
     * Choose a format for swap chain
     * @params:
     *      - presents: the list of available swap chain formats
     */
    fn chooseSwapSurfaceFormat (self, formats : [VkSurfaceFormatKHR])-> VkSurfaceFormatKHR
        throws BalderError
    {
        for f in formats {
            if (f.format == VkFormat::VK_FORMAT_B8G8R8_SRGB && f.colorSpace == VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
                return f;
            }
        }

        if (formats.len != 0us) return formats [0];

        throw copy BalderError ("No available format for swap chain");
    }

    /**
     * Choose a present mode for the swap chain
     * @params:
     *      - presents: the list of available present mode
     */
    fn chooseSwapPresentMode (self, presents : [VkPresentModeKHR], vsync : bool)-> VkPresentModeKHR {
        let mut best = VkPresentModeKHR::VK_PRESENT_MODE_FIFO_KHR;
        for p in presents {
            if (!vsync) {
                if (p == VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR) {
                    best = p;
                } else if (best != VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR &&
                           p == VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR) {
                    best = p;
                }
            } else {
                if (p == VkPresentModeKHR::VK_PRESENT_MODE_MAILBOX_KHR) return p;
            }
        }

        best
    }

    /**
     * Choose a size for the swap chain
     * @params:
     *     - win: the dimension of the window
     *     - cap: the capabilities of the physical used to create the swap chain
     */
    fn chooseSwapChainExtent (self, win : (u32, u32), cap : VkSurfaceCapabilitiesKHR)-> VkExtent2D {
        let mut ext = VkExtent2D ();
        ext.width = std::algorithm::comparison::clamp (win._0, cap.minImageExtent.width, cap.maxImageExtent.width);
        ext.height = std::algorithm::comparison::clamp (win._1, cap.minImageExtent.height, cap.maxImageExtent.height);

        ext
    }

    /**
     * Choose the number of image in the swap chain
     * */
    fn chooseImageCount (self)-> u32 {
        if (self._physicalDeviceSwapChainDetail.capabilities.maxImageCount > 0u32
            && self._physicalDeviceSwapChainDetail.capabilities.minImageCount == self._physicalDeviceSwapChainDetail.capabilities.maxImageCount) {
            self._physicalDeviceSwapChainDetail.capabilities.maxImageCount
        } else {
            self._physicalDeviceSwapChainDetail.capabilities.minImageCount + 1
        }
    }

    /**
     * Recreate the swapchain that became obsolete
     */
    pub fn recreateSwapchain (mut self, surface : VkSurfaceKHR)
        throws BalderError
    {
        vkDeviceWaitIdle (self._device);

        self:.disposeSwapchain ();
        if let Ok (dmut w) = alias self._win {
            self._physicalDeviceSwapChainDetail = self.querySwapChainSupport (surface, self._physicalDevice);

            self:.createSwapchain (alias w);
            self:.createImageViews (alias w);
            self:.createFramebuffers (alias w);
        } else {
            throw copy BalderError ("Malformed device");
        }

        self._resizingWindow = false;
        log::info ("Recreated swap chain");
    }

    /**
     * Dispose the swap chain and its components
     */
    pub fn disposeSwapchain (mut self) {
        atomic self {
            for buf in self._swapChainFramebuffers {
                vkDestroyFramebuffer (self._device, buf, null);
            }
            self._swapChainFramebuffers = [];

            for image in self._swapChainImageViews {
                vkDestroyImageView (self._device, image, null);
            }

            self._swapChainImageViews = [];

            if (self._swapChain != null) {
                vkDestroySwapchainKHR (self._device, self._swapChain, null);
                self._swapChain = null;
                self._swapChainExtent = VkExtent2D ();
                self._swapChainFormat = VkFormat::VK_FORMAT_MAX_ENUM;
                self._swapChainImages = [];
                log::info ("Swap chain disposed");
            }
        }
    }
    
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===========================================   LOGICAL DEVICE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the logical device to attach to the selected physical device to render things
     */
    fn createLogicalDevice (mut self, dmut _ : &Window)
        throws BalderError
    {
        let mut priority = 1.0f;

        let mut uniq : [u32 => mut ()] = copy [];
        let mut v : [mut VkDeviceQueueCreateInfo] = [];

        for i in self._physicalDeviceFamilyIndices {
            if (i !in uniq) {
                let mut queue = VkDeviceQueueCreateInfo ();
                queue.sType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
                queue.queueFamilyIndex = i;
                queue.queueCount = 1u32;
                queue.pQueuePriorities = &priority;

                v ~= [queue];
                uniq [i] = ();
            }
        }

        let mut queueCreateInfos = v;
        let mut logFeatures = VkPhysicalDeviceFeatures ();
        if let Ok (true) = self._config ["anisotropy"].to!{bool} ()? {
            logFeatures.samplerAnisotropy = VK_TRUE;
        }

        let mut extensions = copy [std::conv::toStringZ (i) for i in self._requiredExtensions];

        let mut createInfo = VkDeviceCreateInfo ();
        createInfo.sType                   = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        createInfo.pQueueCreateInfos       = queueCreateInfos.ptr;
        createInfo.queueCreateInfoCount    = cast!u32 (queueCreateInfos.len);
        createInfo.pEnabledFeatures        = &logFeatures;
        createInfo.enabledExtensionCount   = cast!u32 (extensions.len);
        createInfo.ppEnabledExtensionNames = extensions.ptr;

        if (vkCreateDevice (self._physicalDevice, &createInfo, null, alias &self._device) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create logical device");
        }

        vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [0], 0u32, alias &self._graphicsQueue);
        vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [1], 0u32, alias &self._presentQueue);

        if (self._graphicsQueue == null) throw copy BalderError ("Failed to retreive graphics queue");
        if (self._presentQueue == null) throw copy BalderError ("Failed to retreive present queue");

        log::info ("Created logical device");
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===========================================   PHYSICAL DEVICE  =======================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * List all available devices and select the best one for rendering
     */
    fn selectPhysicalDevice (mut self, dmut win : &Window)
        throws BalderError
    {
        let mut deviceCount = 0u32;
        if (self._instance:.getHandle () == null) throw copy BalderError ("Invalid vulkan instance");

        vkEnumeratePhysicalDevices (self._instance:.getHandle (), alias &deviceCount, null);
        if (deviceCount == 0u32) throw copy BalderError ("No available devices");

        let dmut devices : [VkPhysicalDevice] = copy [null ; deviceCount];
        vkEnumeratePhysicalDevices (self._instance:.getHandle (), alias &deviceCount, alias devices.ptr);

        let mut maxScore = 0;
        for i in 0u32 .. deviceCount {
            let (name, score, fam, support) = self.ratePhysicalDevice (win:.getVulkanSurface (), devices [i]);
            if (maxScore <= score) {
                self._physicalDevice = alias devices [i];
                self._physicalDeviceName = name;
                self._physicalDeviceFamilyIndices = fam;
                self._physicalDeviceSwapChainDetail = support;
                maxScore = score;
            }
        }

        if (self._physicalDevice == null) throw copy BalderError ("No suitable device found");
        log::info ("Selected physical device : ", self._physicalDeviceName);
    }

    /**
     * @returns: a score for the physical device, -1 if the device is not suitable
     */
    fn ratePhysicalDevice (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> ([c8], i32, [u32], SwapChainDetail) {
        let dmut properties = VkPhysicalDeviceProperties ();
        let dmut features = VkPhysicalDeviceFeatures ();
        let dmut memProperties = VkPhysicalDeviceMemoryProperties ();

        vkGetPhysicalDeviceProperties (device, alias &properties);
        vkGetPhysicalDeviceFeatures (device, alias &features);
        vkGetPhysicalDeviceMemoryProperties (device, alias &memProperties);

        if (features.geometryShader == 0u32) return ("", -1, [], SwapChainDetail ());

        let family = self.findQueueFamily (surface, device);
        if (!family._0) return ("", -1, [], SwapChainDetail ());
        if (!self.checkDeviceExtensionSupport (device)) return ("", -1, [], SwapChainDetail ());

        let support = self.querySwapChainSupport (surface, device);
        if (support.formats.len == 0us || support.presents.len == 0us) return ("", -1, [], SwapChainDetail ());

        let mut score = cast!i32 (properties.limits.maxImageDimension2D);
        let name = unsafe {
            fromStringZ (properties.deviceName.ptr)
        };

        for i in 0 .. memProperties.memoryHeapCount {
            score += cast!i32 (memProperties.memoryHeaps [i].size / (1024 * 1024));
        }

        return if (properties.deviceType == VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
            log::info ("Rating physical device : ", name, " = ", score + 1000);
            (name, score + 1000, copy [family._1, family._2], support)
        } else {
            log::info ("Rating physical device : ", name, " = ", score);
            (name, score, copy [family._1, family._2], support)
        };
    }

    /**
     * Find the indices of the queue family (graphics and present)
     */
    fn findQueueFamily (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> (bool, u32, u32) {
        let mut gr = 0u32, mut pr = 0u32;
        let mut foundGr = false, mut foundPr = false;

        let mut queueFamilyCount = 0u32;
        vkGetPhysicalDeviceQueueFamilyProperties (device, alias &queueFamilyCount, null);

        if (queueFamilyCount != 0u32) {
            let dmut queueFamilies = copy [VkQueueFamilyProperties () ; queueFamilyCount];
            vkGetPhysicalDeviceQueueFamilyProperties (device, alias &queueFamilyCount, alias queueFamilies.ptr);

            for i, q in queueFamilies {
                if (q.queueFlags & cast!u32 (VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT) != 0u32) {
                    gr = cast!u32 (i);
                    foundGr = true;
                }

                let mut presentSupport = VK_FALSE;
                vkGetPhysicalDeviceSurfaceSupportKHR (device, cast!u32 (i), surface, alias &presentSupport);
                if (presentSupport != VK_FALSE) {
                    pr = cast!u32 (i);
                    foundPr = true;
                }

                if (foundPr && foundGr) break;
            }
        }

        return (foundGr && foundPr, gr, pr);
    }

    /**
     * @returns: true if the physical device has the correct extension for the balder engine to work, false otherwise
     */
    fn checkDeviceExtensionSupport (self, device : VkPhysicalDevice)-> bool {
        let mut extensionCount = 0u32;
        vkEnumerateDeviceExtensionProperties (device, null, alias &extensionCount, null);

        if (extensionCount != 0u32) {
            let dmut availableExtensions = copy [VkExtensionProperties () ; extensionCount];
            vkEnumerateDeviceExtensionProperties (device, null, alias &extensionCount, alias availableExtensions.ptr);

            let dmut required = copy self._requiredExtensions;
            for a in availableExtensions {
                unsafe {
                    required:.remove (fromStringZ (a.extensionName.ptr));
                }
            }

            return required.len == 0us;
        }

        false
    }

    /**
     * Get information about the support for swapchain for the device
     */
    fn querySwapChainSupport (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> SwapChainDetail {
        let mut capabilities = VkSurfaceCapabilitiesKHR ();
        vkGetPhysicalDeviceSurfaceCapabilitiesKHR (device, surface, alias &capabilities);

        let mut formatCount = 0u32;
        vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, null);

        let dmut formats : [VkSurfaceFormatKHR] = [];
        if (formatCount != 0u32) {
            formats = copy [VkSurfaceFormatKHR () ; formatCount];
            vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, alias formats.ptr);
        }

        let mut presentCount = 0u32;
        vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, null);


        let dmut presents : [VkPresentModeKHR] = [];
        if (presentCount != 0u32) {
            presents = copy [VkPresentModeKHR::VK_PRESENT_MODE_MAX_ENUM_KHR ; presentCount];
            vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, alias presents.ptr);
        }

        SwapChainDetail (capabilities-> capabilities, formats-> formats, presents-> presents)
    }


    /**
     * ======================================================================================================
     * ======================================================================================================
     * ======================================================================================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {

        pub over dispose (mut self) {            
            self._requiredExtensions = copy [];
            self._win = none;

            // No need to destroy the command buffers, they are managed by the pool
            if (self._commandPool != null) {
                vkDestroyCommandPool (self._device, self._commandPool, null);
                self._commandPool = null;

                // So they are destroyed here
                self._commandBuffers = [];
            }

            self:.disposeSwapchain ();

            if let Ok (dmut a) = alias self._allocator {
                a:.dispose ();
                self._allocator = none;
            }

            if let Ok (dmut d) = alias self._descPool {
                d:.dispose ();
                self._descPool = none;
            }


            if (self._imageAvailableSem.len != 0us) {
                // We dispose the three elements at the same time, they are always constructed and used together
                for i in 0us .. self._imageAvailableSem.len {
                    vkDestroySemaphore (self._device, self._imageAvailableSem[i], null);
                    vkDestroySemaphore (self._device, self._renderFinishedSem[i], null);
                    vkDestroyFence (self._device, self._inFlightFences[i], null);
                }

                self._imageAvailableSem = [];
                self._renderFinishedSem = [];
                self._inFlightFences = [];
            }

            if (self._renderPass != null) {
                vkDestroyRenderPass (self._device, self._renderPass, null);
                self._renderPass = null;
                self._clearColor = [];
                self._renderPassBeginInfo = VkRenderPassBeginInfo ();
            }

            if (self._device != null) {
                vkDestroyDevice (self._device, null);
                self._device = null;
                self._graphicsQueue = null;
                self._presentQueue = null;

                log::info ("Disposing device");
            }

            self._physicalDevice = null;
            self._physicalDeviceName = "";
            self._physicalDeviceSwapChainDetail = SwapChainDetail ();
            self._physicalDeviceFamilyIndices = [];
        }



    }

    __dtor (mut self) {
        self:.dispose ();
    }
         

}
