in color;

use vulkan::_;
use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;

pub class VulkanColorSubpass over VulkanSubpass {

    prot { // Output buffers

        // The depth texture of the subpass
        let dmut _depth : (&DepthTexture)? = none;

        // The color texture of the subpass
        let dmut _color : (&ColorTexture)? = none;

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice, width : u32, height : u32)
        with super (alias device, width, height)
        throws BalderError
    {
        self:.configure ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn configure (mut self)
        throws BalderError
    {
        self:.createTextures ();
        self:.createRenderPass ();
        self:.createFramebuffer ();
    }

    /**
     * Create the result textures
     * @params:
     *    - onlyDepth: true iif color is not important
     * */
    fn createTextures (mut self)
        throws BalderError
    {
        {
            let dmut text = copy ColorTexture (alias self._device, self._device.getSwapchainFormat (), self._width, self._height, forSubpass-> true);
            self._color = (alias text)?;
        }

        {
            let dmut text = copy DepthTexture (alias self._device, self._device.getDepthFormat (), self._width, self._height, forSubpass-> true);
            self._depth = (alias text)?;
        }
    }

    /**
     * Create the rendering pass
     * */
    fn createRenderPass (mut self)
        throws BalderError
    {
        let mut colorAttachement = VkAttachmentDescription ();
        colorAttachement.format = self._device.getSwapchainFormat ();
        colorAttachement.samples        = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        colorAttachement.loadOp         = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR;
        colorAttachement.storeOp        = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
        colorAttachement.stencilLoadOp  = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        colorAttachement.stencilStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        colorAttachement.initialLayout  = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        colorAttachement.finalLayout    = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

        let mut depthAttachment = VkAttachmentDescription ();
        depthAttachment.format = self._device.getDepthFormat ();
        depthAttachment.samples = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        depthAttachment.loadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR;
        depthAttachment.storeOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        depthAttachment.stencilLoadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        depthAttachment.stencilStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        depthAttachment.initialLayout = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        depthAttachment.finalLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;

        let mut colorAttachementRef = VkAttachmentReference ();
        colorAttachementRef.attachment = 0;
        colorAttachementRef.layout = VkImageLayout::VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        let mut depthAttachmentRef = VkAttachmentReference ();
        depthAttachmentRef.attachment = 1;
        depthAttachmentRef.layout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

        let mut subPass = VkSubpassDescription ();
        subPass.pipelineBindPoint    = VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
        subPass.pDepthStencilAttachment = &depthAttachmentRef;

        subPass.colorAttachmentCount = 1u32;
        subPass.pColorAttachments    = &colorAttachementRef;

        let dmut dependencies = copy [VkSubpassDependency () ; 2];
        dependencies[0].srcSubpass = VK_SUBPASS_EXTERNAL;
		dependencies[0].dstSubpass = 0;
		dependencies[0].srcStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
        dependencies[0].dependencyFlags = VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT;

        dependencies[0].srcAccessMask   = VkAccessFlagBits::VK_ACCESS_NONE_KHR;
		dependencies[0].dstStageMask   = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;

		dependencies[0].dstAccessMask  = VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

		dependencies[1].srcSubpass = 0;
		dependencies[1].dstSubpass      = VK_SUBPASS_EXTERNAL;
        dependencies[1].dstStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
		dependencies[1].dependencyFlags = VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT;


        dependencies[1].dstAccessMask   = VkAccessFlagBits::VK_ACCESS_MEMORY_READ_BIT;
		dependencies[1].srcStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;

		dependencies[1].srcAccessMask   = VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

        let dmut attachment = copy [colorAttachement, depthAttachment];
        let mut renderPassInfo = VkRenderPassCreateInfo ();
        renderPassInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
        renderPassInfo.attachmentCount = 2u32;
        renderPassInfo.pAttachments = attachment.ptr;

        renderPassInfo.subpassCount = 1u32;
        renderPassInfo.pSubpasses = &subPass;
        renderPassInfo.dependencyCount = cast!u32 (dependencies.len);
        renderPassInfo.pDependencies = dependencies.ptr;

        if vkCreateRenderPass (self._device.getDeviceHandle (), &renderPassInfo, null, alias &self._renderPass) != VkResult::VK_SUCCESS {
            throw copy BalderError ("Failed to create render pass");
        }

        self._clearColor = copy [VkClearValue () ; 2];
        self._clearColor [0].color.float32 = [0.f, 0.f, 0.f, 1.f];
        self._clearColor [1].depthStencil.depth = 1.0f;

        log::info ("Created color subpass render pass");
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          FRAMEBUFFER          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the frame buffer of the subpass
     * */
    fn createFramebuffer (mut self)
        throws BalderError
    {
        let dmut attachment : [VkImageView] = {
            copy [self._color.value:.getImageView (), self._depth.value:.getImageView ()]
        } catch {
            _ => {
                throw copy BalderError ("Failed to create framebuffer");
            }
        }

        let mut framebufferInfo = VkFramebufferCreateInfo ();
        framebufferInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = self._renderPass;
        framebufferInfo.attachmentCount = cast!{u32} (attachment.len);
        framebufferInfo.pAttachments = attachment.ptr;
        framebufferInfo.width = self._width;
        framebufferInfo.height = self._height;
        framebufferInfo.layers = 1u32;

        if vkCreateFramebuffer (self._device.getDeviceHandle (), &framebufferInfo, null, alias &self._framebuffer) != VkResult::VK_SUCCESS {
            throw copy BalderError ("Failed to create framebuffer");
        }

        log::info ("Created frame buffer for subpass");
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the depth texture result of the render pass
     * */
    pub fn getDepth (mut self)-> dmut &DepthTexture {
        if let Ok (dmut d) = alias self._depth {
            return alias d;
        }

        panic;
    }

    /**
     * @returns: the color texture result of the render pass
     * */
    pub fn getColor (mut self)-> dmut &ColorTexture {
        if let Ok (dmut d) = alias self._color {
            return alias d;
        }

        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          RENDERING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over startRenderPass (mut self) {
        let mut pass = VkRenderPassBeginInfo ();
        pass.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        pass.renderPass = self._renderPass;
        pass.renderArea.extent.width = self._width;
        pass.renderArea.extent.height = self._height;
        pass.clearValueCount   = cast!{u32} (self._clearColor.len);
        pass.pClearValues      = self._clearColor.ptr;
        pass.framebuffer = self._framebuffer;

        vkCmdBeginRenderPass (self._device:.getCommandBuffer (), &pass, VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE);
        let mut viewport = VkViewport ();
        viewport.width = cast!{f32} (self._width);
        viewport.height = cast!{f32} (self._height);
        viewport.maxDepth = 1.0f;

        let mut scissor = VkRect2D ();
        scissor.extent.width = self._width;
        scissor.extent.height = self._height;

        vkCmdSetViewport (self._device:.getCommandBuffer (), 0, 1, &viewport);
        vkCmdSetScissor (self._device:.getCommandBuffer (), 0, 1, &scissor);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            log::info ("Disposing subpass render");
            if let Ok (dmut c) = alias self._color {
                c:.dispose ();
                self._color = none;
            }

            if let Ok (dmut d) = alias self._depth {
                d:.dispose ();
                self._depth = none;
            }

            if self._framebuffer != null {
                vkDestroyFramebuffer (self._device.getDeviceHandle (), self._framebuffer, null);
                self._framebuffer = null;
            }

            if self._renderPass != null {
                vkDestroyRenderPass (self._device.getDeviceHandle (), self._renderPass, null);
                self._renderPass = null;
                self._clearColor = [];
            }
        }

    }

}
