in compute;



use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;

@final
pub class ComputeSubpass over VulkanSubpass {

    prot {
        let _width : u32;        
        let _height : u32;
        let _depth : u32;
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice, width : u32, height : u32, depth : u32)
        with super (alias device)
        , _width = width
        , _height = height
        , _depth = depth
        throws BalderError
    {}            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the dimension of the subpass
     *     - .0: the width
     *     - .1: the height
     * */
    pub fn getDimension (self)-> (u32, u32, u32) {
        (self._width, self._height, self._depth)
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SUBMIT          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
        
    /**
     * Submit the pass to the graphics queue
     * */
    pub over submit (mut self, frame : u32, previousPassStages : [u32], previousPass : [VkSemaphore])-> VkResult {                                
        let mut submitInfo = VkSubmitInfo ();
        submitInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO;
        
        submitInfo.waitSemaphoreCount = cast!u32 (previousPass.len);
        submitInfo.pWaitSemaphores = previousPass.ptr;
        submitInfo.pWaitDstStageMask = previousPassStages.ptr;    
        
        submitInfo.signalSemaphoreCount = 1u32;        
        submitInfo.pSignalSemaphores = &self._finishSemaphore [frame];

        submitInfo.commandBufferCount   = 1u32;
        submitInfo.pCommandBuffers      = &self._commandBuffers [frame];
        
        atomic self._device {
            let r = vkQueueSubmit (self._device.getComputeQueue (), 1u32, &submitInfo, self._fences [frame]);                
            if (r != VkResult::VK_SUCCESS) {
                log::error #("DrawPass", "Error submitting pass to queue : ", frame);
                return r;
            }
            
            return r;
        }                            
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self.__super__:.dispose ();
        }
    }
    

}
