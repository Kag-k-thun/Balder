in clock;


use std::time::_;
use balder::core::driver::_;
use balder::core::dispose;
use balder::utils::log;

use ::vulkan::core;

/**
 * A class used to measure time within a GPU command buffer
 * */
pub class VulkanClock {

    // The device on which the clock is watching
    let dmut _device : &VulkanDevice;

    // The query pool for the clock
    let dmut _pool : VkQueryPool = null;

    let mut _started : bool = false;
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
    {
        self:.configure ();
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn configure (mut self) {
        let mut info = VkQueryPoolCreateInfo ();
        info.sType = VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
        info.queryType = VkQueryType::VK_QUERY_TYPE_TIMESTAMP;
        info.queryCount = 2;

        if (vkCreateQueryPool (self._device.getDeviceHandle (), &info, null, alias &self._pool) != VkResult::VK_SUCCESS) {
            log::error #("Failed to create query pool");            
        }        
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Reset the clock
     * */
    pub fn reset (mut self, cmd : VkCommandBuffer) atomic self {        
        vkCmdResetQueryPool (cmd, self._pool, 0, 2);
    }
    
    /**
     * Start the clock
     * */
    pub fn start (mut self, cmd : VkCommandBuffer) atomic self {        
        vkCmdWriteTimestamp (cmd, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, self._pool, 0);        
    }

    /**
     * End the clock
     * */
    pub fn end (mut self, cmd : VkCommandBuffer, stage : VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT) atomic self {        
        vkCmdWriteTimestamp (cmd, stage, self._pool, 1);        
    }

    pub fn submit (mut self) {
        self._started = true;
    }
    
    /**
     * @returns: the duration of the timer between the two ticks
     * */
    pub fn time (mut self)-> dur::Duration atomic self {        
        if self._started {            
            self._started = false;
            let dmut stamps : [u64 ; 2] = [0 ; 2];
            vkGetQueryPoolResults (self._device.getDeviceHandle (),
                                   self._pool,
                                   0, 2,
                                   u64::size * 2,
                                   cast!{*void} (alias stamps.ptr),
                                   u64::size,
                                   VkQueryResultFlagBits::VK_QUERY_RESULT_64_BIT | VkQueryResultFlagBits::VK_QUERY_RESULT_WAIT_BIT);
            
            let ns = cast!f32 (stamps [1] - stamps [0]) * self._device.getNsPerTicks ();
            return dur::micros (cast!u64 (ns / 1000.0f));
        } else {
            return dur::micros (0);
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if self._pool != null {
                vkDestroyQueryPool (self._device.getDeviceHandle (), self._pool, null);
                self._pool = null;
            }
        }
    }
    
    
}
