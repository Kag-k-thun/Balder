in mem_alloc;

use vulkan::_;
use balder::core::driver::_;
use balder::core::{dispose, error};
use balder::utils::log;

use std::{io, stream};
use std::algorithm::comparison;

pub record MemoryAllocation {
    pub let mut type : u32 = 0u32;
    pub let mut index : usize = 0us;
    pub let mut offset : u64 = 0u64;
    pub let mut size : u64 = 0u64;
    pub let mut mem : VkDeviceMemory = null;
    pub self (type : u32 = 0, index : usize = 0, offset : u64 = 0, size : u64 = 0, mem : VkDeviceMemory = null)
        with type = type
        , index = index
        , offset = offset
        , size = size
        , mem = mem
    {}
}

class MemoryDescription {

    // The allocated memory segment
    let dmut _mem : VkDeviceMemory;

    // The type of memory
    let _type : u32;

    // The size of the memory segment
    let _size = 0u64;    
    
    // The memory segments
    let mut _segments : [mut (u64, u64)] = [];
    
    /**
     * @params:
     *   - type: the type of memory
     *   - mem: the allocated memory
     *   - size: the size of the allocated memory
     */
    pub self (type : u32, dmut mem : VkDeviceMemory, size : u64)
        with _mem = alias mem
        , _type = type
        , _segments = copy [(0u64, size)]
        , _size = size
    {}

    /**
     * Find a free location in the memory segment
     * @params:
     *    - size: the size of the allocation to find
     *    - align: the alignement of the allocation
     * @returns:
     *    - .0: true iif found
     *    - .1: the index of the offset
     */
    pub fn findFreeSegment (mut self, size : u64, align : u64)-> (bool, u64) {
        for i in 0us .. self._segments.len {
            let current = self._segments [i].0 + if (self._segments [i].0 % align != 0u64) { (align - (self._segments [i].0 % align)) } else { 0u64 };
            if (current + size <= self._segments [i].1) {
                return (true, current);
            }
        }

        (false, 0u64)
    }

    /**
     * @returns: the vulkan handle of the memory
     */
    pub fn getMemory (mut self)-> dmut VkDeviceMemory {
        alias self._mem
    }

    /**
     * @returns: true if the segment is completely free 
     */
    pub fn isEmpty (self)-> bool {
        (self._segments.len == 1us && self._segments[0us].0 == 0u64 && self._segments [0].1 == self._size)
    }
    
    /**    
     * Reserve a segment of the memory
     * @params:
     *    - offset: the offset of the reservation
     *    - size: the size of the reservation   
     * @assume: the segment is free
     */
    pub fn reserve (mut self, offset : u64, size : u64) {
        for i in 0us .. self._segments.len {
            if (self._segments[i].0 <= offset && self._segments[i].1 >= (offset + size)) {
                let mut left  : [mut (u64, u64)] = if (self._segments[i].0 != offset) { copy [(self._segments[i].0, offset)] } else { [] };
                let mut right : [mut (u64, u64)] = if (self._segments[i].1 != (offset + size)) { copy [(offset + size, self._segments[i].1)] } else { [] };
                
                self._segments = alias (self._segments [0us .. i] ~ left ~ right ~ self._segments[i + 1us .. $]);
            }
        }
    }

    
    /**
     * Free a segment
     * @params:
     *    - offset: the start of the segment
     *    - size: the size of the segment to reserve
     * @assume the segment was reserved
     */
    pub fn free (mut self, offset : u64, size : u64) {
        if (self._segments.len == 0us) {
            self._segments = copy [(offset, size)];
        } else {
            let mut where = 0us;
            for i in 0us .. self._segments.len {
                if (offset + size <= self._segments [i].0) {
                    break {}
                }
                where += 1us;
            }

            if (where == 0us) {                
                if (self._segments [0].0 == offset + size) {
                    self._segments [0] = (offset, self._segments [0].1);
                } else {
                    self._segments = alias ([(offset, offset + size)] ~ self._segments);
                }
            } else if (where == self._segments.len) {
                if (self._segments [$ - 1us].1 == offset) {
                    self._segments [$ - 1us] = (self._segments [$ - 1us].0, offset + size);
                } else {
                    self._segments = alias (self._segments ~ [(offset, offset + size)]);
                }
            } else {
                if (self._segments [where - 1us].1 == offset && self._segments [where].0 == offset + size) {
                    self._segments = alias (self._segments [0us .. where - 1us] ~ [(self._segments[where - 1us].0, self._segments[where].1)] ~ self._segments [where + 1us .. $]);
                } else if (self._segments [where - 1us].1 == offset) {
                    self._segments [where - 1us] = (self._segments [where - 1us].0, offset + size);
                } else if (self._segments [where].0 == offset + size) {
                    self._segments [where] = (offset, self._segments [where].1);
                } else {
                    self._segments = alias (self._segments [0us .. where - 1us] ~ [(offset, offset + size)] ~ self._segments [where .. $]);
                }
            }
        }
        
    }

    impl Streamable;

}


/**
 * Memory allocator used to manage the memory of a vulkan device
 */
pub class MemoryAllocator {

    // The device used by the allocator
    let dmut _device : &VulkanDevice;

    // The allocated memory segments
    let dmut _memDescs : [u32 => [&MemoryDescription]] = copy [];

    // The size of a memory segment
    let mut _memorySegmentSize : u64 = 0u64;
    
    /**
     * @params:
     *   - device: the device used to allocate memory
     */
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
    {
        let dmut properties = VkPhysicalDeviceProperties ();
        let mut memProperties = VkPhysicalDeviceMemoryProperties ();
        vkGetPhysicalDeviceProperties (self._device:.getPhysicalDeviceHandle (), alias &properties);
        vkGetPhysicalDeviceMemoryProperties (self._device:.getPhysicalDeviceHandle (), alias &memProperties);
        
        self._memorySegmentSize = memProperties.memoryHeaps [0us].size / cast!u64 (min (4096u32, properties.limits.maxMemoryAllocationCount));
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   GETTERS   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the device used by the allocator
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   ALLOCATION   =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Allocate a buffer
     * @params:
     *    - size: the size of the buffer to allocate
     *    - bufferUsage: the type of buffer to allocate
     */
    pub fn allocBuffer (mut self, size : u64, bufferUsage : u32, memoryFlags : u32)-> dmut &Buffer
        throws BalderError
    {
        let mut isLocal = (memoryFlags & cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) == 1u32);
        isLocal = isLocal || (memoryFlags & cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 1u32);

        let mut bufferInfo = VkBufferCreateInfo ();
        bufferInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = size;
        bufferInfo.usage = bufferUsage;
        bufferInfo.sharingMode = VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;

        let dmut buf : VkBuffer = null;
        if (vkCreateBuffer (self._device:.getDeviceHandle (), &bufferInfo, null, alias &buf) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create buffer.");
        }

        let memAlloc = self:.findSuitableMemory (buf, bufferInfo, memoryFlags);
        return copy Buffer (alias self, memAlloc, alias buf, isLocal-> isLocal);
    }


    /**
     * Find a suitable free memory segment to bind to the buffer
     * @params:
     *    - buf: the buffer to bind
     *    -
     */
    fn findSuitableMemory (mut self, buf : VkBuffer, bufferInfo : VkBufferCreateInfo, memoryFlags : u32)-> MemoryAllocation
        throws BalderError
    {
        let dmut memReq = VkMemoryRequirements ();
        vkGetBufferMemoryRequirements (self._device:.getDeviceHandle (), buf, alias &memReq);

        let type = self:.findMemoryType (memReq.memoryTypeBits, memoryFlags);
        if let Ok (dmut vec) = alias self._memDescs [type] {
            for i in 0us .. vec.len {
                let (succ, off) = (vec [i]):.findFreeSegment (bufferInfo.size, memReq.alignment);
                if (succ) {
                    (vec [i]):.reserve (off, bufferInfo.size);
                    let res = MemoryAllocation (
                        type-> type,
                        index-> i,
                        offset-> off,
                        size-> bufferInfo.size,
                        mem-> vec [i]:.getMemory ());

                    if (vkBindBufferMemory (self._device:.getDeviceHandle (), buf, (vec [i]):.getMemory (), off) != VkResult::VK_SUCCESS) {
                        throw copy BalderError ("Failed to bind buffer memory");
                    }

                    return res;
                }
            }
        }

        let mut index = 0us;
        let allocSize = max (self._memorySegmentSize, bufferInfo.size);
        let dmut mem = self:.allocateNewMemorySegment (type, allocSize, ref index);
        mem:.reserve (0u64, bufferInfo.size);

        if let Ok (ref dmut v) = ref self._memDescs [type] {
            v ~= [alias mem];
        } else { self._memDescs [type] = copy [alias mem]; }

        if (vkBindBufferMemory (self._device:.getDeviceHandle (), buf, mem:.getMemory (), 0u64) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to bind buffer memory");
        }

        let res = MemoryAllocation (
            type-> type,
            index-> index,
            offset-> 0u64,
            size-> bufferInfo.size,
            mem-> mem:.getMemory ());

        return res;
    }

    /**
     * Allocate a new memory segment
     * @params:
     *    - type: the type of memory to allocate
     *    - size: the size of the memory to allocate
     * @returns:
     *    - the allocated memory
     *    - index: the index where the memory was inserted in the memDesc map
     */
    fn allocateNewMemorySegment (mut self, type : u32, size : u64, ref mut index : usize)-> dmut &MemoryDescription
        throws BalderError
    {
        let mut memInfo = VkMemoryAllocateInfo ();

        memInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        memInfo.allocationSize = size;
        memInfo.memoryTypeIndex = type;
        
        let dmut mem : VkDeviceMemory = null;
        if (vkAllocateMemory (self._device:.getDeviceHandle (), &memInfo, null, alias &mem) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to allocate buffer memory."s8);
        }

        let dmut memDesc = copy MemoryDescription (type, alias mem, size);
        if let Ok (ref dmut vec) = ref self._memDescs [type] {
            vec ~= [alias memDesc];
            index = vec.len - 1us;
        }
        else {
            self._memDescs [type] = copy [alias memDesc];
            index = 0;
        }
        
        return alias memDesc;
    }

    /**
     * Find a memory type that can be bound to the buffer
     */
    fn findMemoryType (mut self, typeFilter : u32, properties : VkMemoryPropertyFlags)-> u32
        throws BalderError
    {
        let dmut memProperties = VkPhysicalDeviceMemoryProperties ();
        vkGetPhysicalDeviceMemoryProperties (self._device:.getPhysicalDeviceHandle (), alias &memProperties);

        for i in 0u32 .. memProperties.memoryTypeCount {
            if ((typeFilter & (1u32 << i)) != 0u32 && ((memProperties.memoryTypes [i].propertyFlags & properties) != 0u32)) {
                return i;
            }
        }

        throw copy BalderError ("Failed to find suitable memory type."s8);
    }


    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   CLEANING   ===========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Remove an allocation
     */
    pub fn free (mut self, dmut buf : VkBuffer, memAlloc : MemoryAllocation) {
        vkDestroyBuffer (self._device:.getDeviceHandle (), buf, null);

        if let Ok (ref dmut vec) = ref self._memDescs [memAlloc.type] {
            vec [memAlloc.index]:.free (memAlloc.offset, memAlloc.size);
            if (vec [memAlloc.index].isEmpty ()) {
                vkFreeMemory (self._device:.getDeviceHandle (), vec [memAlloc.index]:.getMemory (), null);
                if (vec.len == 1us) {
                    self._memDescs:.remove (memAlloc.type);
                } else {
                    vec = alias (vec [0 .. memAlloc.index] ~ vec [memAlloc.index + 1 .. $]);
                }
            }
        }
    }

    impl Disposable {
        pub over dispose (mut self) {
            for _, dmut vec in alias self._memDescs {
                for i in 0us .. vec.len {
                    vkFreeMemory (self._device:.getDeviceHandle (), vec[i]:.getMemory (), null);
                }
            } 
            
            self._memDescs = copy [];
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
}
