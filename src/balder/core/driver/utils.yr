in utils;

use vulkan::_;
use balder::math::_;

/**
 * Image 2D are passed using image buffers to shader
 */
pub fn getDescriptorType {T of Texture2D} ()-> VkDescriptorType {
    VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
}

/**
 * All other kind of data (vec, mat, etc.) are passed using uniform buffers
 */
pub fn getDescriptorType {T} ()-> VkDescriptorType {
    VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
}

/**
 * @returns: the flag bits for the shader stage
 * @info: this is a convention in the name of the uniform, maybe there is a better way for doing that but for the moment it seems ok
 * @example:
 * ====
 * let v_projection = ; // vertex shader
 * let vf_view = ; // vertex and frag shader
 * let f_color = ; // frag shader
 * let g_color = ; // geometry
 * let c_color = ; // compute
 * let a_color = ; // all graphics
 * let A_color = ; // all
 * let pos = ; // all
 * ====
 */
pub fn getDescriptorStage (name : [c8])-> u32 {
    let mut stage : u32 = 0u32;
    if let Ok (fnd) = std::algorithm::searching::find (name, '_') {
        for i in 0 .. fnd {
            match name [i] {
                'f' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT); }
                'v' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT); }
                'g' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT); }
                'c' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT); }
                'a' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS); }
                'A' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL); }
                '_' => { break {} }
            }
        };
    } else { // the name does not start with a stage descriptor
        stage = cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL);
    }

    stage
}


/**
 * @returns: the format that can be used for the type V
 * @static_assert: if type V is not supported
 */
pub fn getFormat {T, V} ()-> VkFormat {
    cte if (is!{V}{U of vec4}) {
        VkFormat::VK_FORMAT_R32G32B32A32_SFLOAT
    } else cte if (is!{V}{U of vec3}) {
        VkFormat::VK_FORMAT_R32G32B32_SFLOAT
    } else cte if (is!{V}{U of vec2}) {
        VkFormat::VK_FORMAT_R32G32_SFLOAT
    } else cte if (is!{V}{U of f32}) {
        VkFormat::VK_FORMAT_R32_SFLOAT
    } else cte if (is!{V}{U of ivec4}) {
        VkFormat::VK_FORMAT_R32G32B32A32_SINT
    } else cte if (is!{V}{U of ivec3}) {
        VkFormat::VK_FORMAT_R32G32B32_SINT
    } else cte if (is!{V}{U of ivec2}) {
        VkFormat::VK_FORMAT_R32G32_SINT
    } else cte if (is!{V}{U of i32}) {
        VkFormat::VK_FORMAT_R32_SINT
    } else {
        cte assert (false, "Field of type : " ~ (V)::typeid ~ " in type " ~ T::typeid ~ " is unsable as a shader input");
    }
}

