in transfer;

use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;

use std::concurrency::mail;


fn emptyClean () {}

@final
pub class VulkanTransferPass {
    
    // The vulkan device used to render the subpass
    let dmut _device : &VulkanDevice;

    // The list of semaphores to wait from the device
    let _imageAvailableSem : [VkSemaphore];
        
    // The semaphore emited when the subpass is finished (one per swap chain frame)
    let dmut _finishSemaphore : [VkSemaphore] = [];

    // Fence emited to synchronize CPU with the sub pass
    let dmut _fences : [VkFence] = [];

    // The list of command buffers
    let dmut _commandBuffers : [VkCommandBuffer] = [];

    // Empty command buffer when nothing to transfer
    let dmut _emptyCmd : [VkCommandBuffer] = [];

    // Clocks to compute transfer pass time
    let dmut _clocks : [&VulkanClock] = [];

    prot {
        // The signal emitted by the subpass when it is redrawn
        let dmut _box : [dg (VkCommandBuffer)-> void] = [];

        let dmut _clean : [dg ()-> void] = [];
        
        // The cleaners to run when the previous transfer has been awaited
        let mut _cleaners : [mut [dg ()-> void]] = [];
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice, imageSems : [VkSemaphore])
        with _device = alias device
        , _imageAvailableSem = imageSems
        throws BalderError
    {
        self:.configureSyncObjects ();
        self:.configureCommandBuffers ();
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the clock of the frame 'frame'
     * */
    pub fn getClock (mut self, frame : u32)-> dmut &VulkanClock {
        alias self._clocks [frame]
    }
    
    /**
     * @returns: the semaphore emitted when the pass has finished (on GPU side)
     * */
    @final
    pub fn getSemaphore (self, currentFrame : u32)-> VkSemaphore {
        self._finishSemaphore [currentFrame]
    }

    /**
     * @returns: the fence emitted when the pass has finished (on CPU side)
     * */
    @final
    pub fn getFence (self, currentFrame : u32)-> VkFence {
        self._fences [currentFrame]
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          INSERTION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a transfer in the pass
     * */
    pub fn add (mut self, callback : dg (VkCommandBuffer)-> void, clean : dg ()-> void = &emptyClean) {
        atomic self {
            self._box ~= [callback];
            self._clean ~= [clean];
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SUBMIT          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */    
    
    /**
     * Execute all the transfer commands
     * */
    pub fn submit (mut self, frame : u32)-> VkResult {
        let tasks = atomic self {
            let tasks = self._box;
            self._box = [];
            
            // run cleaners of previous similar transfer
            for c in self._cleaners [frame] { 
                c ();
            }            
            
            self._cleaners [frame] = self._clean;
            self._clean = [];
            tasks
        }
        
        
        let mut submitInfo = VkSubmitInfo ();
        submitInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO;

        let stage : u32 = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        
        submitInfo.waitSemaphoreCount = 1u32;
        submitInfo.pWaitSemaphores    = &self._imageAvailableSem [frame];
        submitInfo.pWaitDstStageMask  = &stage;    
        
        submitInfo.signalSemaphoreCount = 1u32;        
        submitInfo.pSignalSemaphores    = &self._finishSemaphore [frame];

        let mut cmd : VkCommandBuffer = self._emptyCmd [frame];         
        
        // Launch the transfer tasks
        if tasks.len != 0 {
            log::debug #("VulkanTransferPass", "Transfer commands : ", tasks.len);
            cmd = self._commandBuffers [frame];
            vkResetCommandBuffer (cmd, 0u32);
            let mut cmdBegin = VkCommandBufferBeginInfo ();
            cmdBegin.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            
            vkBeginCommandBuffer (cmd, &cmdBegin);
            self._clocks [frame]:.reset (cmd);
            self._clocks [frame]:.start (cmd);
            
            for t in tasks {
                t (cmd);
            }            

            self._clocks [frame]:.end (cmd);
            vkEndCommandBuffer (cmd);                    
        }

        submitInfo.commandBufferCount = 1u32;
        submitInfo.pCommandBuffers    = &cmd;
        self._device:.getMemoryAllocator ():.commitDynamicBuffers ();
        
        atomic self._device {            
            let r = vkQueueSubmit (self._device.getTransferQueue (), 1u32, &submitInfo, null);
            self._clocks [frame]:.submit ();

            if (r != VkResult::VK_SUCCESS) {
                log::error #("TransferPass", "Error submitting pass to queue : ", frame);                
            }
            
            return r;                            
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          SYNCHRONIZE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Create the sync objects 
     * */
    prv fn configureSyncObjects (mut self)
        throws BalderError
    {
        self._finishSemaphore = copy [null ; self._device:.getSwapchain ().nbFrames];
        self._fences          = copy [null ; self._device:.getSwapchain ().nbFrames];

        let mut semInfo = VkSemaphoreCreateInfo ();
        semInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
        
        let mut fenceInfo = VkFenceCreateInfo ();
        fenceInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        fenceInfo.flags = cast!u32 (VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT);

        for i in 0 .. self._finishSemaphore.len {
            if (vkCreateSemaphore (self._device.getDeviceHandle () , &semInfo, null, alias &self._finishSemaphore [i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create subpass finish semaphore");
            }

            if (vkCreateFence (self._device.getDeviceHandle (), &fenceInfo, null, alias &self._fences [i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create fence");
            }            
        }

        self._clocks = copy [copy VulkanClock (alias self._device) ; self._device:.getSwapchain ().nbFrames];        
    }

    /**
     * Configure the command buffers of the subpass
     * */
    prv fn configureCommandBuffers (mut self)
        throws BalderError
    {
        let nbFrames = self._device.getNbFrames ();        
        self._commandBuffers = copy [null ; nbFrames];
        self._emptyCmd = copy [null ; nbFrames];
        
        let mut allocInfo = VkCommandBufferAllocateInfo ();
        allocInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level              = VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool        = self._device.getTransferCommandPool ();
        allocInfo.commandBufferCount = nbFrames;
        
        if (vkAllocateCommandBuffers (self._device.getDeviceHandle (), &allocInfo, alias self._commandBuffers.ptr) != VkResult::VK_SUCCESS) {
            log::error #("VulkanSubpass", "Failed to allocate command buffers");
            throw copy BalderError ("Failed to allocate command buffers");
        }
        
        if (vkAllocateCommandBuffers (self._device.getDeviceHandle (), &allocInfo, alias alias self._emptyCmd.ptr) != VkResult::VK_SUCCESS) {
            log::error #("VulkanSubpass", "Failed to allocate command buffers");
            throw copy BalderError ("Failed to allocate command buffers");
        }

        for i in 0 .. nbFrames {
            // Set the empty to contain nothing
            let mut cmdBegin = VkCommandBufferBeginInfo ();
            cmdBegin.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            vkResetCommandBuffer (self._emptyCmd [i], 0u32);
            vkBeginCommandBuffer (self._emptyCmd [i], &cmdBegin);
            vkEndCommandBuffer (self._emptyCmd [i]);
        }

        self._cleaners = copy [[] ; nbFrames];    
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {                        
            for c in self._clean {
                c ();
            }
            
            for lst in self._cleaners for c in lst {
                c ();
            }
                                                
            for i in 0 .. self._finishSemaphore.len {
                vkDestroySemaphore (self._device.getDeviceHandle (), self._finishSemaphore [i], null);
            }

            for i in 0 .. self._fences.len {
                vkDestroyFence (self._device.getDeviceHandle (), self._fences [i], null);
            }

            for i in 0 .. self._clocks.len {
                self._clocks [i]:.dispose ();
            }
                                                            
            self._finishSemaphore = [];
            self._fences = [];
            self._commandBuffers = [];
            self._emptyCmd = [];
            self._clocks = [];
            self._cleaners = [];
            self._clean = [];
            self._box = [];
        }        
    }

}
