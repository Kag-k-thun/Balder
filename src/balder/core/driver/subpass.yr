in subpass;

use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;


mod ::draw;
mod ::compute;

@abstract
pub class VulkanSubpass {

    // The name of the pass
    let _name : [c8];
    
    // The vulkan device used to render the subpass
    let dmut _device : &VulkanDevice;

    // The window to which the subpass is associated
    let dmut _window : &Window;
    
    // The semaphore emited when the subpass is finished (one per swap chain frame)
    let dmut _finishSemaphore : [VkSemaphore] = []; 

    // Fence emited to synchronize CPU with the sub pass
    let dmut _fences : [VkFence] = [];

    prot { // command buffer and online swapping
        
        // The command buffers used to draw the subpass ([0] => the one to reset, [1] => the one in use, [2] => the one to swap)
        let dmut _commandBuffers : [VkCommandBuffer] = [];        

        // The list of command buffer to reset 
        let dmut _nextCommandBuffer : [VkCommandBuffer] = [];
                
        // The signal emitted by the subpass when it is redrawn
        let dmut _onRedraw : &DirectSignal!{()} = copy DirectSignal!{()} ();

    }
    
    prot { // Command allocators

        // The current frame being recorded or drawn
        let mut _currentFrame : u32 = 0;

        // The allocators used to record draw/compute commands 
        let dmut _allocators : [[&CommandAllocator]] = [];
        
    }

    let dmut _clocks : [&VulkanClock] = [];    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice, name : [c8])
        with _device = alias device  
        , _window = alias  device:.getWindow ()
        , _name = name        
        
        throws BalderError
    {
        self:.configureSyncObjects ();
        self:.configureCommandBuffers ();        
    }        

    __dtor (mut self) {
        self:.dispose ();
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the name of the subpass
     * */
    @field
    pub fn name (self)-> [c8] {
        self._name
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          SYNCHRONIZE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Create the sync objects 
     * */
    prv fn configureSyncObjects (mut self)
        throws BalderError
    {
        self._finishSemaphore = copy [null ; self._device:.getSwapchain ().nbFrames];
        self._fences          = copy [null ; self._device:.getSwapchain ().nbFrames];

        let mut semInfo = VkSemaphoreCreateInfo ();
        semInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
        
        let mut fenceInfo = VkFenceCreateInfo ();
        fenceInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        fenceInfo.flags = cast!u32 (VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT);

        for i in 0 .. self._finishSemaphore.len {
            if (vkCreateSemaphore (self._device.getDeviceHandle () , &semInfo, null, alias &self._finishSemaphore [i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create subpass finish semaphore");
            }

            if (vkCreateFence (self._device.getDeviceHandle (), &fenceInfo, null, alias &self._fences [i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create fence");
            }            
        }

        self._clocks = copy [copy VulkanClock (alias self._device) ; self._device:.getSwapchain ().nbFrames];        
    }

    /**
     * Wait for the render pass to be finished (synchronize CPU and GPU rendering)
     * */
    @final
    pub fn await (mut self, currentFrame : u32) {
        vkWaitForFences (self._device.getDeviceHandle (), 1u32, &self._fences [currentFrame], VK_TRUE, u64::max);            
        vkResetFences (self._device.getDeviceHandle (), 1u32, &self._fences [currentFrame]);
        
        log::debug #("VulkanPipeline", "Pipeline stage '", self._name, "' took ", self._clocks [currentFrame]:.time ());
    }

    /**
     * @returns: the semaphore emitted when the pass has finished (on GPU side)
     * */
    @final
    pub fn getSemaphore (self, currentFrame : u32)-> VkSemaphore {
        self._finishSemaphore [currentFrame]
    }

    /**
     * @returns: the fence emitted when the pass has finished (on CPU side)
     * */
    @final
    pub fn getFence (self, currentFrame : u32)-> VkFence {
        self._fences [currentFrame]
    }

    /**
     * @returns: the command buffer in which the subpass is currently drawing
     * */
    pub fn getDrawingCommandBuffer (self)-> VkCommandBuffer {
        self._nextCommandBuffer [self._currentFrame]
    }

    pub fn getCurrentFrame (self)-> u32 {
        self._currentFrame
    }


    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }
    
    /**
     * @returns: the signal emitted when the frame is redrawn
     * @warning: this is a direct signal, meaning it is called within the drawing thread directy upon redraw
     * */
    pub fn onDraw (mut self)-> dmut &DirectSignal!{()} {
        alias self._onRedraw
    }
        
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          COMMAND BUFFERS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Start the recording of the subpass     
     * */
    prot fn startRecording (mut self) {
        vkResetCommandBuffer (self._nextCommandBuffer [self._currentFrame], 0u32);
                
        let mut cmdBegin = VkCommandBufferBeginInfo ();
        cmdBegin.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        
        vkBeginCommandBuffer (self._nextCommandBuffer [self._currentFrame], &cmdBegin);
        self._clocks [self._currentFrame]:.reset (self._nextCommandBuffer [self._currentFrame]);
        self._clocks [self._currentFrame]:.start (self._nextCommandBuffer [self._currentFrame]);           
    }

    /**
     * Stop the recording of the subpass
     * */
    prot fn stopRecording (mut self) {
        self._clocks [self._currentFrame]:.end (self._nextCommandBuffer [self._currentFrame]);
        vkEndCommandBuffer (self._nextCommandBuffer [self._currentFrame]);
    }
    
    /**
     * Submit the pass to the queue
     * @params:
     *    - currentFrame: the current frame to submit
     *    - previousPass: the list of semaphores to wait emited by previous passes
     *    - previousPassStages: the flags of the pass considered finished when reaching the stage (example: VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
     * */
    pub fn submit (mut self, frame : u32, previousPassStages : [u32], previousPass : [VkSemaphore])-> VkResult;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Configure the command buffers of the subpass
     * */
    prv fn configureCommandBuffers (mut self)
        throws BalderError
    {
        let nbFrames = self._device:.getSwapchain ().nbFrames;

        self._allocators = copy [[] ; nbFrames];
        self._commandBuffers = copy [null ; nbFrames];
        self._nextCommandBuffer = copy [null ; nbFrames];

        let mut allocInfo = VkCommandBufferAllocateInfo ();
        allocInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level              = VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool        = self._device.getDrawCommandPool ();
        allocInfo.commandBufferCount = nbFrames;
        
        if (vkAllocateCommandBuffers (self._device.getDeviceHandle (), &allocInfo, alias self._commandBuffers.ptr) != VkResult::VK_SUCCESS) {
            log::error #("VulkanSubpass", "Failed to allocate command buffers");
            throw copy BalderError ("Failed to allocate command buffers");
        }
        
        if (vkAllocateCommandBuffers (self._device.getDeviceHandle (), &allocInfo, alias self._nextCommandBuffer.ptr) != VkResult::VK_SUCCESS) {
            log::error #("VulkanSubpass", "Failed to allocate swap command buffers");
            throw copy BalderError ("Failed to allocate swap command buffers");        
        }                                                    
    }

    /**
     * Redraw the pass     
     * */
    pub fn redraw (mut self, frame : u32) atomic self {
        self._currentFrame = frame;

        for dmut alloc in alias self._allocators [frame] {
            self._window:.insertBin (alias alloc);
        }
        self._allocators [frame] = [];
                           
        self:.startRecording ();                             
        self._onRedraw:.emit ();                                
        self:.stopRecording ();
        
        let dmut aux = alias self._commandBuffers [frame];
        self._commandBuffers [frame] = alias self._nextCommandBuffer [frame];
        self._nextCommandBuffer [frame] = alias aux;
        
        vkResetCommandBuffer (aux, 0u32);         
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          COMMAND ALLOCATORS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Get a command allocator for the subpass
     * @params:
     *    - currentFrame: the frame being drawn
     * */
    pub fn registerCommandAllocator (mut self, dmut cmd : &CommandAllocator) {        
        self._allocators [self._currentFrame] ~= [alias cmd];                
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Reset all the command buffers of the subpass
     * */
    pub fn resetCommands (mut self) atomic self {
        for i, dmut lst in alias self._allocators {
            for dmut cmd in alias lst {
                cmd:.dispose ();
            }
            self._allocators [i] = [];
        }        
        
        for i in 0 .. self._commandBuffers.len {
            vkResetCommandBuffer (self._commandBuffers [i], 0u32);
        }

        for i in 0 .. self._nextCommandBuffer.len {
            vkResetCommandBuffer (self._nextCommandBuffer [i], 0u32);
        }
    }

    /**
     * Reset the onRedraw signal (disconnect every slots)
     * */
    pub fn resetDrawSignal (mut self) {
        self._onRedraw = copy DirectSignal!{()} ();
    }

    impl Disposable {
        pub over dispose (mut self) {            
            for i in 0 .. self._finishSemaphore.len {
                vkDestroySemaphore (self._device.getDeviceHandle (), self._finishSemaphore [i], null);
            }

            for i in 0 .. self._fences.len {
                vkDestroyFence (self._device.getDeviceHandle (), self._fences [i], null);
            }

            for i in 0 .. self._clocks.len {
                self._clocks [i]:.dispose ();
            }
            
            self:.resetCommands ();
            self:.resetDrawSignal ();
            
            self._allocators = [];
            self._finishSemaphore = [];
            self._fences = [];
            self._commandBuffers = [];
            self._nextCommandBuffer = [];
            self._clocks = [];
        }        
    }
}


pub def DrawSubpass : draw::DrawSubpass;
pub def ComputeSubpass : compute::ComputeSubpass;
