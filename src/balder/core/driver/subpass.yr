
use vulkan::_;
use balder::core::{_, driver::_, memory::_, application::_, shader::_};


pub class VulkanSubpass {

    // The vulkan device used to render the subpass
    let dmut _device : &VulkanDevice;

    prot { // Rendering pass

        // The frame buffer attached to the rendering texture
        let dmut _framebuffer : VkFramebuffer = null;

        // The render pass of the subpass
        let dmut _renderPass : VkRenderPass = null;

        // The color used when clearing an image of the swap chain;
        let dmut _clearColor : [VkClearValue] = [];

        // The begin info used when begining the render pass
        let dmut _renderPassBeginInfo : VkRenderPassBeginInfo = VkRenderPassBeginInfo ();

    }

    prot { // Output buffers

        // The width of the subpass texture
        let dmut _width : u32;

        // The height of the subpass texture
        let dmut _height : u32;

        // The depth texture of the subpass
        let dmut _depth : (&DepthTexture)? = none;

        // The color texture of the subpass
        let dmut _color : (&ColorTexture)? = none;

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice, width : u32, height : u32, onlyDepth : bool = false)
        with _device = alias device
        , _width = width
        , _height = height

        throws BalderError
    {
        self:.configure (onlyDepth);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn configure (mut self, onlyDepth : bool)
        throws BalderError
    {
        self:.createTextures (onlyDepth);
        self:.createRenderPass (onlyDepth);
        self:.createFramebuffer (onlyDepth);
    }

    /**
     * Create the result textures
     * @params:
     *    - onlyDepth: true iif color is not important
     * */
    fn createTextures (mut self, onlyDepth : bool)
        throws BalderError
    {
        if !onlyDepth {
            let dmut text = copy ColorTexture (alias self._device, self._device.getSwapchainFormat (), self._width, self._height);
            self._color = (alias text)?;
        }

        let dmut text = copy DepthTexture (alias self._device, self._device.findDepthFormat (), self._width, self._height);
        self._depth = (alias text)?;
    }

    /**
     * Create the rendering pass
     * @params:
     *    - onlyDepth: true iif color is not important
     * */
    fn createRenderPass (mut self, onlyDepth : bool)
        throws BalderError
    {
        let mut colorAttachement = VkAttachmentDescription ();
        colorAttachement.format = self._device.getSwapchainFormat ();
        colorAttachement.samples        = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        colorAttachement.loadOp         = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR;
        colorAttachement.storeOp        = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
        colorAttachement.stencilLoadOp  = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        colorAttachement.stencilStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        colorAttachement.initialLayout  = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        colorAttachement.finalLayout    = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

        let mut depthAttachment = VkAttachmentDescription ();
        depthAttachment.format = self.findDepthFormat ();
        depthAttachment.samples = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        depthAttachment.loadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR;
        depthAttachment.storeOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        depthAttachment.stencilLoadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        depthAttachment.stencilStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
        depthAttachment.initialLayout = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        depthAttachment.finalLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

        let mut colorAttachementRef = VkAttachmentReference ();
        colorAttachementRef.attachment = 0;
        colorAttachementRef.layout = VkImageLayout::VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        let mut depthAttachmentRef = VkAttachmentReference ();
        depthAttachmentRef.attachment = 1;
        depthAttachmentRef.layout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

        let mut subPass = VkSubpassDescription ();
        subPass.pipelineBindPoint    = VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
        subPass.pDepthStencilAttachment = &depthAttachmentRef;

        if !onlyDepth {
            subPass.colorAttachmentCount = 1u32;
            subPass.pColorAttachments    = &colorAttachementRef;
        } else {
            subPass.colorAttachmentCount = 0u32;
        }

        let mut dependencies = copy [VkSubpassDependency () ; 2];
        dependencies[0].srcSubpass = VK_SUBPASS_EXTERNAL;
		dependencies[0].dstSubpass = 0;
		dependencies[0].srcStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
		dependencies[0].dstStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;

		dependencies[0].srcAccessMask   = VkAccessFlagBits::VK_ACCESS_NONE_KHR;
		dependencies[0].dstAccessMask   = VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
		dependencies[0].dependencyFlags = VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT;

		dependencies[1].srcSubpass = 0;
		dependencies[1].dstSubpass      = VK_SUBPASS_EXTERNAL;
		dependencies[1].srcStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
                                        | VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;
		dependencies[1].dstStageMask    = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;

		dependencies[1].srcAccessMask   = VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
                                        | VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
		dependencies[1].dstAccessMask   = VkAccessFlagBits::VK_ACCESS_MEMORY_READ_BIT;
		dependencies[1].dependencyFlags = VkAccessFlagBits::VK_DEPENDENCY_BY_REGION_BIT;


        let mut renderPassInfo = VkRenderPassCreateInfo ();
        renderPassInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
        if (onlyDepth) {
            renderPassInfo.attachmentCount = 1u32;
            renderPassInfo.pAttachments = &depthAttachment;
        } else {
            let dmut attachment = copy [colorAttachement, depthAttachment];
            renderPassInfo.attachmentCount = 2u32;
            renderPassInfo.pAttachments = attachment.ptr;
        }

        renderPassInfo.subpassCount = 1u32;
        renderPassInfo.pSubpasses = &subPass;
        renderPassInfo.dependencyCount = cast!u32 (dependencies.len);
        renderPassInfo.pDependencies = dependencies.ptr;

        if vkCreateRenderPass (self._device:.getDeviceHandle (), &renderPassInfo, null, alias &self._renderPass) != VkResult::VK_SUCCESS {
            throw copy BalderError ("Failed to create render pass");
        }

        self._clearColor = copy [VkClearValue () ; 2];
        self._clearColor [0].color.float32 = [0.f, 0.f, 0.f, 1.f];
        self._clearColor [1].depthStencil.depth = 1.0f;

        log::info ("Created subpass render pass");
    }

    /**
     * Create the frame buffer of the subpass
     * */
    fn createFramebuffer (mut self, onlyDepth : bool)
        throws BalderError
    {
        let dmut attachment : [VkImageView] = {
            if onlyDepth {
                copy [self._depth.value:.getImageView ()]
            } else {
                copy [self._color.value:.getImageView (), self._depth.value:.getImageView ()]
            }
        } catch {
            throw copy BalderError ("Failed to create framebuffer");
        }

        let mut framebufferInfo = VkFramebufferCreateInfo ();
        framebufferInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = self._renderPass;
        framebufferInfo.attachmentCount = cast!{u32} (attachment.len);
        framebufferInfo.pAttachments = attachment.ptr;
        framebufferInfo.width = self._width;
        framebufferInfo.height = self._height;
        framebufferInfo.layers = 1u32;


        if vkCreateFramebuffer (self._device, &framebufferInfo, null, alias &self._framebuffer) != VkResult::VK_SUCCESS {
            throw copy BalderError ("Failed to create framebuffer");
        }

        log::info ("Created frame buffer for subpass");
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the depth texture result of the render pass
     * */
    pub fn getDepth (mut self)-> dmut (&DepthTexture)? {
        self._depth
    }

    /**
     * @returns: the color texture result of the render pass
     * */
    pub fn getColor (mut self)-> dmut (&ColorTexture)? {
        self._color
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over (mut self) {
            if let Ok (dmut c) = alias self._color {
                c:.dispose ();
                self._color = none;
            }

            if let Ok (dmut d) = alias self._depth {
                d:.dispose ();
                self._depth = none;
            }

            if self._framebuffer != null {
                vkDestroyFramebuffer (self._device:.getDeviceHandle (), self._framebuffer, null);
                self._framebuffer = null;
            }

            if self._renderPass != null {
                vkDestroyRenderPass (self._device:.getDeviceHandle (), self._renderPass, null);
                self._renderPass = null;
                self._clearColor = [];
                self._renderPassBeginInfo = VkRenderPassBeginInfo ();
            }
        }

    }

}
