in subpass;

use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;


mod ::draw;


enum
| REDRAW    = 1
| DRAWING   = 2
| GENERATED = 3
| SWAPPED   = 4
 -> FrameDrawing;

@abstract
pub class VulkanSubpass {

    // The vulkan device used to render the subpass
    let dmut _device : &VulkanDevice;

    // The semaphore emited when the subpass is finished (one per swap chain frame)
    let dmut _finishSemaphore : [VkSemaphore] = []; 

    // Fence emited to synchronize CPU with the sub pass
    let dmut _fences : [VkFence] = [];

    prot { // command buffer and online swapping
        
        // The command buffers used to draw the subpass ([0] => the one to reset, [1] => the one in use, [2] => the one to swap)
        let dmut _commandBuffers : [VkCommandBuffer] = [];        

        // The list of command buffer to reset 
        let dmut _nextCommandBuffer : [VkCommandBuffer] = [];
        
        // The frames that have been swapped already
        let dmut _updated : [FrameDrawing] = [];

        // The signal emitted by the subpass when it is redrawn
        let dmut _onRedraw : &DirectSignal!{()} = copy DirectSignal!{()} ();

    }
    
    prot { // Command allocators

        // The current frame being recorded or drawn
        let mut _currentFrame : u32 = 0;

        // The allocators used to record draw/compute commands 
        let dmut _allocators : [[c8] => &CommandAllocator] = copy [];
        
    }
    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice)
        with _device = alias device        
        throws BalderError
    {
        self:.configureSyncObjects ();
        self:.configureCommandBuffers ();
    }        

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          SYNCHRONIZE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the sync objects 
     * */
    prv fn configureSyncObjects (mut self)
        throws BalderError
    {
        self._finishSemaphore = copy [null ; self._device:.getSwapchain ().nbFrames];
        self._fences          = copy [null ; self._device:.getSwapchain ().nbFrames];

        let mut semInfo = VkSemaphoreCreateInfo ();
        semInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
        
        let mut fenceInfo = VkFenceCreateInfo ();
        fenceInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        fenceInfo.flags = cast!u32 (VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT);

        for i in 0 .. self._finishSemaphore.len {
            if (vkCreateSemaphore (self._device.getDeviceHandle () , &semInfo, null, alias &self._finishSemaphore [i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create subpass finish semaphore");
            }

            if (vkCreateFence (self._device.getDeviceHandle (), &fenceInfo, null, alias &self._fences [i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create fence");
            }            
        }
    }

    /**
     * Wait for the render pass to be finished (synchronize CPU and GPU rendering)
     * */
    @final
    pub fn await (mut self, currentFrame : u32) {
        vkWaitForFences (self._device.getDeviceHandle (), 1u32, &self._fences [currentFrame], VK_TRUE, u64::max);
        vkResetFences (self._device.getDeviceHandle (), 1u32, &self._fences [currentFrame]);
    }

    /**
     * @returns: the semaphore emitted when the pass has finished (on GPU side)
     * */
    @final
    pub fn getSemaphore (self, currentFrame : u32)-> VkSemaphore {
        self._finishSemaphore [currentFrame]
    }

    /**
     * @returns: the fence emitted when the pass has finished (on CPU side)
     * */
    @final
    pub fn getFence (self, currentFrame : u32)-> VkFence {
        self._fences [currentFrame]
    }

    /**
     * @returns: the command buffer in which the subpass is currently drawing
     * */
    pub fn getDrawingCommandBuffer (self)-> VkCommandBuffer {
        self._nextCommandBuffer [self._currentFrame]
    }

    /**
     * @returns: the signal emitted when the frame is redrawn
     * @warning: this is a direct signal, meaning it is called within the drawing thread directy upon redraw
     * */
    pub fn onDraw (mut self)-> dmut &DirectSignal!{()} {
        alias self._onRedraw
    }

    /**
     * Force the subpass to be redrawn
     * */
    pub fn forceRedraw (mut self) {
        atomic self {
            for i in 0 .. self._updated.len {
                self._updated [i] = FrameDrawing::REDRAW;
            }
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          COMMAND BUFFERS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Start the recording of the subpass     
     * */
    prot fn startRecording (mut self, currentFrame : u32) {
        atomic self { // Allocated a new command buffer
            self._currentFrame = currentFrame;
            self._updated [self._currentFrame] = FrameDrawing::DRAWING;           
            vkResetCommandBuffer (self._nextCommandBuffer [currentFrame], 0u32);
            
            let mut cmdBegin = VkCommandBufferBeginInfo ();
            cmdBegin.sType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            
            vkBeginCommandBuffer (self._nextCommandBuffer [currentFrame], &cmdBegin);        
        }
    }

    /**
     * Stop the recording of the subpass
     * */
    prot fn stopRecording (mut self) {
        vkEndCommandBuffer (self._nextCommandBuffer [self._currentFrame]);
        atomic self {
            self._updated [self._currentFrame] = FrameDrawing::GENERATED;               
        }
    }
    
    /**
     * Submit the pass to the queue
     * @params:
     *    - currentFrame: the current frame to submit
     *    - previousPass: the list of semaphores to wait emited by previous passes
     *    - previousPassStages: the flags of the pass considered finished when reaching the stage (example: VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
     * */
    prot fn submit (mut self, frame : u32, previousPassStages : [u32], previousPass : [VkSemaphore])-> VkResult;


    /**
     * Execute the subpass
     * @params:
     *    - frame: the frame to draw
     *    - previousPass: the list of semaphores to wait emited by previous passes
     *    - previousPassStages: the flags of the pass considered finished when reaching the stage (example: VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
     * */
    pub fn execute (mut self, frame : u32, previousPassStages : [u32], previousPass : [VkSemaphore]) {
        atomic self {
            if self._updated [frame] != FrameDrawing::SWAPPED {
                self:.redraw (frame);                
            }

            self:.submit (frame, previousPassStages, previousPass);
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Configure the command buffers of the subpass
     * */
    prv fn configureCommandBuffers (mut self)
        throws BalderError
    {
        let nbFrames = self._device:.getSwapchain ().nbFrames;
        
        self._commandBuffers = copy [null ; nbFrames];
        self._nextCommandBuffer = copy [null ; nbFrames];

        let mut allocInfo = VkCommandBufferAllocateInfo ();
        allocInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level              = VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool        = self._device.getDrawCommandPool ();
        allocInfo.commandBufferCount = nbFrames;
        
        if (vkAllocateCommandBuffers (self._device.getDeviceHandle (), &allocInfo, alias self._commandBuffers.ptr) != VkResult::VK_SUCCESS) {
            log::error #("VulkanSubpass", "Failed to allocate command buffers");
            throw copy BalderError ("Failed to allocate command buffers");
        }
        
        if (vkAllocateCommandBuffers (self._device.getDeviceHandle (), &allocInfo, alias self._nextCommandBuffer.ptr) != VkResult::VK_SUCCESS) {
            log::error #("VulkanSubpass", "Failed to allocate swap command buffers");
            throw copy BalderError ("Failed to allocate swap command buffers");        
        }
                             
        self._updated = copy [FrameDrawing::REDRAW ; nbFrames];                
    }

    /**
     * @returns: the command buffer to submit for frame 'frame'
     * */
    prot fn getCommandBuffer (mut self, frame : u32)-> VkCommandBuffer {
        atomic self {
            if self._updated [frame] == FrameDrawing::GENERATED {
                self._updated [frame] = FrameDrawing::SWAPPED;
                let dmut aux = alias self._commandBuffers [frame];
                self._commandBuffers [frame] = alias self._nextCommandBuffer [frame];
                self._nextCommandBuffer [frame] = alias aux;
                
                vkResetCommandBuffer (aux, 0u32);
            }
        }

        self._commandBuffers [frame]
    }

    /**
     * Redraw the pass     
     * */
    prot fn redraw (mut self, frame : u32) atomic self {
        self:.startRecording (frame);
        self._onRedraw:.emit ();
        self:.stopRecording ();
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          COMMAND ALLOCATORS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Get a command allocator for the subpass
     * @params:
     *    - currentFrame: the frame being drawn
     * */
    pub fn getCommandAllocator {T over CommandAllocator} (mut self)-> T {
        if let Ok (dmut cmd) = alias self._allocators [T::typeinfo.name] {
            return alias cmd;
        }

        let dmut cmd = copy T (alias self._device, alias self);
        self._allocators [T::typeinfo.name] = alias cmd;        
        alias cmd
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            for i in 0 .. self._finishSemaphore.len {
                vkDestroySemaphore (self._device.getDeviceHandle (), self._finishSemaphore [i], null);
            }

            for i in 0 .. self._fences.len {
                vkDestroyFence (self._device.getDeviceHandle (), self._fences [i], null);
            }

            for _, dmut cmd in alias self._allocators {                
                cmd:.dispose ();            
            }

            for i in 0 .. self._commandBuffers.len if self._commandBuffers [i] != null {
                vkResetCommandBuffer (self._commandBuffers [i], 0u32);                
            }

            for i in 0 .. self._commandBuffers.len if self._nextCommandBuffer [i] != null {
                vkResetCommandBuffer (self._nextCommandBuffer [i], 0u32);                
            }
            
            self._allocators = copy [];
            self._finishSemaphore = [];
            self._fences = [];
            self._commandBuffers = [];
            self._nextCommandBuffer = [];
        }        
    }
}


pub def DrawSubpass : draw::DrawSubpass;
