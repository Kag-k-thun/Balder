in swapchain;


use balder::core::{_,
                   driver::_,                   
                   memory::_,
                   application::_,
                   shader::texture};

use balder::utils::log;

use ::vulkan::core;
use ::sdl2::_;

use std::{io, conv, time::_};


pub record SwapChainDetail {
    pub let mut capabilities : VkSurfaceCapabilitiesKHR;
    pub let mut formats : [VkSurfaceFormatKHR];
    pub let mut presents : [VkPresentModeKHR];

    pub self ()
        with capabilities = VkSurfaceCapabilitiesKHR ()
        , formats = []
        , presents = []
    {}

    pub self (capabilities : VkSurfaceCapabilitiesKHR, formats : [VkSurfaceFormatKHR], presents : [VkPresentModeKHR])
        with capabilities = capabilities
        , formats = formats
        , presents = presents
    {}
}

pub class SwapChain {

    let dmut _device : &VulkanDevice;

    prot { // configuration

        // The size of the swap chain
        let mut _extent : VkExtent2D = VkExtent2D ();

        // The format of the color surface
        let mut _surfaceFormat : VkSurfaceFormatKHR = VkSurfaceFormatKHR ();

        // The format of the depth attachment
        let mut _depthFormat : VkFormat = VkFormat::VK_FORMAT_MAX_ENUM;

        // The swap chain of the device to render, and display using different images
        let dmut _swapChain : VkSwapchainKHR = null;

        // The detail of the capabilities of the swap chain of the physical device
        let mut _physicalDeviceSwapChainDetail : SwapChainDetail = SwapChainDetail ();

        // True if vsync is activated
        let mut _vsync : bool = true;

        // The number of images in the swap chain
        let mut _imageCount : u32 = 0;
    }

    prot { // resources
        
        // The image attached to the swap chain
        let dmut _images : [VkImage] = [];

        // The view of the images attach to each frame of the swap chain
        let dmut _imageViews : [VkImageView] = [];

        // The depth image
        let dmut _depthImage : (&OutputTexture)? = none;        

        // The draw render pass
        let dmut _renderPass : (&DrawSubpass)? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut context : &VulkanDevice)
        with _device = alias context
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the size of the images of the swap chain
     * */
    @field
    pub fn extent (self)-> VkExtent2D {
        self._extent
    }

    /**
     * @returns: the format of the color images
     * */
    @field
    pub fn format (self)-> VkFormat {
        self._surfaceFormat.format
    }

    /**
     * @returns: the format of the depth image 
     * */
    @field
    pub fn depthFormat (self)-> VkFormat {
        self._depthFormat
    }

    /**
     * @returns: the vulkan handle of the swap chain
     * */
    @field
    pub fn chain (self)-> VkSwapchainKHR {
        self._swapChain
    }

    /**
     * @returns: the number of frames in the swap chain
     * */
    @field
    pub fn nbFrames (self)-> u32 {
        cast!u32 (self._imageViews.len)
    }

    /**
     * @returns: true iif the swap chain has vsync
     * */
    pub fn hasVSync (self)-> bool {
        self._vsync
    }
    
    /**
     * @returns: the image views of the color texture
     * */
    pub fn getColorImageViews (mut self)-> [VkImageView] {
        self._imageViews
    }
    
    /**
     * @returns: the image views of the depth texture
     * */
    pub fn getDepthImageViews (mut self)-> [VkImageView] {
        if let Ok (dmut out : &OutputTexture) = alias self._depthImage {
            return out.getImageViews ();
        }

        []
    }

    /**
     * @returns: the render pass of the swapchain
     * */
    pub fn getRenderPass (mut self)-> dmut &DrawSubpass {
        if let Ok (dmut pass) = alias self._renderPass {
            return alias pass;
        }

        log::error #("Swapchain", "Getting render pass on an empty swapchain");
        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          PRESENTING          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Present the swap chain to screen
     * */
    pub fn present (self, image : u32, currentFrame : u32)-> VkResult {
        if let Ok (rend) = self._renderPass {
            let sem = rend.getSemaphore (currentFrame);            
            
            let mut presentInfo = VkPresentInfoKHR ();
            presentInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
            presentInfo.waitSemaphoreCount = 1u32;
            presentInfo.pWaitSemaphores    = &sem;
            presentInfo.swapchainCount     = 1u32;
            presentInfo.pSwapchains        = &self._swapChain;
            presentInfo.pImageIndices      = &image;

            return vkQueuePresentKHR (self._device.getPresentQueue (), &presentInfo);
        }

        log::error #("SwapChain", "presenting an empty swapchain");
        panic;
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the swap chain
     * */
    pub fn configure (mut self, dmut win : &Window, cfg : &BalderConfig)
        throws BalderError
    {            
        self:.createSwapchain (alias win, cfg.vulkan.vsync, cfg.vulkan.imageCount);
        self:.createImageViews ();        
        self:.createDepthResources ();        
        
        let dmut renderPass = copy DrawSubpass::toScreen (alias self._device, "#swap", self._extent.width, self._extent.height, alias self);
        self._renderPass = (alias renderPass)?;
    }

    /**
     * Recreate the swap chain on the fly
     * */
    pub fn reconfigure (mut self, dmut win : &Window, cfg : &BalderConfig)
        throws BalderError
    {
        self:.destroy ();
        
        self:.createSwapchain (alias win, cfg.vulkan.vsync, cfg.vulkan.imageCount);
        self:.createImageViews ();        
        self:.createDepthResources ();    

        if let Ok (dmut sub) = alias self._renderPass {
            sub:.reconfigureToScreen (self._extent.width, self._extent.height, alias self);
        }            
    }    

    /**
     * Create the swap chain the allows to render to the window in a fluid way
     */
    fn createSwapchain (mut self, dmut win : &Window, vsync : bool, imageCount : u32)
        throws BalderError
    {        
        self._physicalDeviceSwapChainDetail = self.querySwapChainSupport (win:.getVulkanSurface (), self._device.getPhysicalDeviceHandle ());        
        self._imageCount = self.chooseImageCount (imageCount);

        self._surfaceFormat = self.chooseSwapSurfaceFormat (self._physicalDeviceSwapChainDetail.formats);
        self._depthFormat = self.findDepthFormat ();        
        
        self._vsync = vsync;
        self._extent = self.chooseSwapChainExtent (win.getDimension (), self._physicalDeviceSwapChainDetail.capabilities);

        let presentMode = self.chooseSwapPresentMode (self._physicalDeviceSwapChainDetail.presents, self._vsync);        
        let sharingMode = if (self._device.getGraphicsQueue () == self._device.getPresentQueue ()) {
            VkSharingMode::VK_SHARING_MODE_EXCLUSIVE
        } else { VkSharingMode::VK_SHARING_MODE_CONCURRENT };

        let indices = if (self._device.getGraphicsQueue () != self._device.getPresentQueue ()) {
            self._device.getPhysicalDeviceFamilyIndices ()
        } else { [] };

        let mut createInfo = VkSwapchainCreateInfoKHR ();
        createInfo.sType                 = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
        createInfo.surface               = win:.getVulkanSurface ();
        
        createInfo.minImageCount         = self._imageCount;                
        createInfo.imageFormat           = self._surfaceFormat.format;
        createInfo.imageColorSpace       = self._surfaceFormat.colorSpace;
        createInfo.imageExtent           = self._extent;        
        createInfo.imageArrayLayers      = 1u32;
        createInfo.imageUsage            = cast!u32 (VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);
        createInfo.imageSharingMode      = sharingMode;

        createInfo.pQueueFamilyIndices   = indices.ptr;
        createInfo.queueFamilyIndexCount = cast!u32 (indices.len);
        
        createInfo.preTransform          = self._physicalDeviceSwapChainDetail.capabilities.currentTransform;
        createInfo.compositeAlpha        = VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
        createInfo.presentMode           = presentMode;
        createInfo.clipped               = VK_TRUE;

        if (vkCreateSwapchainKHR (self._device.getDeviceHandle (), &createInfo, null, alias &self._swapChain) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create swap chain");
        }

        let mut imageCreated = 0u32;
        vkGetSwapchainImagesKHR (self._device.getDeviceHandle (), self._swapChain, alias &imageCreated, null);

        self._images = copy [null ; imageCreated];
        vkGetSwapchainImagesKHR (self._device.getDeviceHandle (), self._swapChain, alias &imageCreated, alias self._images.ptr);
        
        log::debug #("Swapchain", "Created swap chain with :", self._images.len, "images");
        if (self._images.len != imageCount) {
            log::warn #("Swapchain", "Number of requested image count was not respected :", self._images.len, "instead of", imageCount);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =======================          CHOOSE FORMAT AND OTHER PARAMETERS          =======================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Choose a format for swap chain
     * @params:
     *      - presents: the list of available swap chain formats
     */
    fn chooseSwapSurfaceFormat (self, formats : [VkSurfaceFormatKHR])-> VkSurfaceFormatKHR
        throws BalderError
    {
        for f in formats {
            if (f.format == VkFormat::VK_FORMAT_B8G8R8_SRGB && f.colorSpace == VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
                return f;
            }
        }

        if (formats.len != 0us) return formats [0];

        throw copy BalderError ("No available format for swap chain");
    }

    /**
     * Choose a present mode for the swap chain
     * @params:
     *      - presents: the list of available present mode
     */
    fn chooseSwapPresentMode (self, presents : [VkPresentModeKHR], vsync : bool)-> VkPresentModeKHR
        throws BalderError
    {                    
        let bestVsync = [VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR,
                         VkPresentModeKHR::VK_PRESENT_MODE_FIFO_KHR,
                         VkPresentModeKHR::VK_PRESENT_MODE_MAILBOX_KHR];

        if vsync {
            for i in bestVsync {
                for z in presents { if z == i { return z; } }
            }

            log::warn #("Swapchain", "Vsync is activated but no available present mode manage vsync");
        }
        
        let bestNoVsync = [VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR,
                           VkPresentModeKHR::VK_PRESENT_MODE_MAILBOX_KHR];

        for i in bestNoVsync {
            for z in presents { if z == i { return z; } }
        }        

        log::error #("Swapchain", "No available present mode");
        throw copy BalderError ("No available present mode");
    }

    /**
     * Choose a size for the swap chain
     * @params:
     *     - win: the dimension of the window
     *     - cap: the capabilities of the physical used to create the swap chain
     */
    fn chooseSwapChainExtent (self, win : (u32, u32), cap : VkSurfaceCapabilitiesKHR)-> VkExtent2D {
        use std::algorithm::comparison;
        
        let mut ext = VkExtent2D ();
        let minExt = cap.minImageExtent;
        let maxExt = cap.maxImageExtent;
        
        ext.width = clamp (win._0, minExt.width, maxExt.width);
        ext.height = clamp (win._1, minExt.height, maxExt.height);

        ext
    }

    /**
     * Choose the number of image in the swap chain
     * */
    fn chooseImageCount (self, imageCount : u32)-> u32 {
        use std::algorithm::comparison;        
        
        let max = self._physicalDeviceSwapChainDetail.capabilities.maxImageCount;
        let min = self._physicalDeviceSwapChainDetail.capabilities.minImageCount;
    
        if max == 0 {
            return comparison::max (imageCount, min);
        }
                                
        return clamp (imageCount, min, max);          
    }

    /**
     * Get information about the support for swapchain for the device
     */
    fn querySwapChainSupport (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> SwapChainDetail {
        let mut capabilities = VkSurfaceCapabilitiesKHR ();
        vkGetPhysicalDeviceSurfaceCapabilitiesKHR (device, surface, alias &capabilities);

        let mut formatCount = 0u32;
        vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, null);

        let dmut formats : [VkSurfaceFormatKHR] = [];
        if (formatCount != 0u32) {
            formats = copy [VkSurfaceFormatKHR () ; formatCount];
            vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, alias formats.ptr);
        }

        let mut presentCount = 0u32;
        vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, null);

        let dmut presents : [VkPresentModeKHR] = [];
        if (presentCount != 0u32) {
            presents = copy [VkPresentModeKHR::VK_PRESENT_MODE_MAX_ENUM_KHR ; presentCount];
            vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, alias presents.ptr);
        }

        SwapChainDetail (capabilities-> capabilities, formats-> formats, presents-> presents)
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   IMAGE VIEWS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create the image views of each swap frame of the swapchain
     */
    fn createImageViews (mut self)
        throws BalderError
    {
        self._imageViews = copy [null ; self._images.len];
        let mut components = VkComponentMapping ();
        components.r = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
        components.g = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
        components.b = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
        components.a = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;

        let mut range = VkImageSubresourceRange ();
        range.aspectMask = cast!u32 (VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT);
        range.levelCount = 1u32;
        range.layerCount = 1u32;

        for i in 0us .. self._images.len {
            let mut createInfo = VkImageViewCreateInfo ();
            createInfo.sType            = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            createInfo.image            = self._images [i];
            createInfo.viewType         = VkImageViewType::VK_IMAGE_VIEW_TYPE_2D;
            createInfo.format           = self._surfaceFormat.format;
            createInfo.components       = components;
            createInfo.subresourceRange = range;

            if (vkCreateImageView (self._device.getDeviceHandle (), &createInfo, null, alias &self._imageViews[i]) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create image view");
            }
        }

        log::debug #("Swapchain", "Created image views : ", self._images.len);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          DEPTH RESOURCES          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the image containing depth
     * */
    fn createDepthResources (mut self)
        throws BalderError
    {
        let format = self._depthFormat;
        let dmut image = copy OutputTexture (alias self._device,
                                             format,
                                             self._extent.width,
                                             self._extent.height,                                             
                                             depth-> true,
                                             forSubpass-> false,
                                             nbImages-> (cast!u32 (self._images.len)?));

        self._depthImage = (alias image)?;
    }

    /**
     * Find the format of the depth buffer for the device
     * */
    pub fn findDepthFormat (self)-> VkFormat
        throws BalderError
    {
        let candidates = [VkFormat::VK_FORMAT_D32_SFLOAT, VkFormat::VK_FORMAT_D32_SFLOAT_S8_UINT, VkFormat::VK_FORMAT_D24_UNORM_S8_UINT];
        let feature = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT;
        for f in candidates {
            let mut props = VkFormatProperties ();
            vkGetPhysicalDeviceFormatProperties (self._device.getPhysicalDeviceHandle (), f, &props);
            if (props.optimalTilingFeatures & feature) == feature {
                return f;
            }
        }

        throw copy BalderError ("No depth format available for device");
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    fn destroy (mut self) {
        if let Ok (dmut rend) = alias self._renderPass {
            rend:.destroy ();            
        }
        
        if let Ok (dmut depth) = alias self._depthImage {
            depth:.dispose ();
            self._depthImage = none;
        }
        
        for image in self._imageViews {
            vkDestroyImageView (self._device.getDeviceHandle (), image, null);
        }
        self._imageViews = [];

        if (self._swapChain != null) {
            vkDestroySwapchainKHR (self._device.getDeviceHandle (), self._swapChain, null);
            self._swapChain = null;
            self._extent = VkExtent2D ();
            self._surfaceFormat = VkSurfaceFormatKHR ();
            self._images = [];
            log::debug #("Swapchain", "Swap chain disposed");
        }
    }
    
    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut rend) = alias self._renderPass {
                rend:.dispose ();
                self._renderPass = none;
            }
            
            self:.destroy ();
        }
    }



}
