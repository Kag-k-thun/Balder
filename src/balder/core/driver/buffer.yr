in buffer;

use balder::core::driver::{device, mem_alloc};
use balder::core::{error, dispose};
use balder::utils::log;

use vulkan::_;

extern (C) fn memcpy (src : *void, dst : *void, size : usize);

pub class Buffer {

    // The device on which the buffer is allocated
    let dmut _device : &VulkanDevice;

    // The allocator used to allocate the buffer memory
    let dmut _allocator : &MemoryAllocator;
    
    // The buffer handle
    let dmut _buffer : VkBuffer = null;
    
    // The size of the allocation
    let dmut _size : VkDeviceSize = 0u64;

    // The memory allocation of the buffer (description used by MemoryAllocator)
    let dmut _memAlloc : MemoryAllocation;
    
    // The descriptor of the buffer
    let dmut _descriptor : VkDescriptorBufferInfo = VkDescriptorBufferInfo ();

    // True iif the buffer is mapped to a CPU pointer
    let mut _mapped : bool = false;

    // If self._mapped, this pointer can be used to get or modified the content of the buffer
    let dmut _mappedData : *void = null;

    // True if the buffer is local to host 
    let _isLocal : bool;

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * Create a buffer using a device
     * @params:
     *    - device: the device used for the allocation
     *    - size: the size of the allocation
     *    - usage: the usage of the memory that will be allocated
     */
    pub self (dmut alloc : &MemoryAllocator, memAlloc : MemoryAllocation, dmut buffer : VkBuffer, isLocal : bool)        
        with  _allocator = alias alloc
        , _device = alloc:.getDevice ()
        , _size = memAlloc.size
        , _buffer = alias buffer
        , _memAlloc = memAlloc
        , _descriptor = VkDescriptorBufferInfo ()
        , _isLocal = isLocal
    {
        self._descriptor.buffer = buffer;
        self._descriptor.offset = 0u64;
        self._descriptor.range = memAlloc.size;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the handle on the vulkan buffer
     */
    pub fn getVulkanBuffer (mut self)-> dmut VkBuffer {
        alias self._buffer
    }

    /**
     * @returns: the device responsible of the allocation of the buffer
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the size of the buffer in memory
     */
    pub fn getSize (self)-> VkDeviceSize {
        self._size
    }

    /**
     * @returns: the pointer to the mapped addr, null if the buffer is not mapped
     */
    pub fn getMapAddress (mut self)-> dmut *void {
        alias self._mappedData
    }

    /**
     * @returns: true if the buffer is mapped into CPU memory
     */
    pub fn isMapped (self)-> bool {
        self._mappedData != null
    }

    /**
     * @returns: the address of the descriptor buffer info
     */
    pub fn getDescriptorInfo (mut self)-> dmut *VkDescriptorBufferInfo {
        alias &self._descriptor
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */


    /**
     * Map the buffer onto CPU memory , so it can be updated
     * @assume: the buffer was not disposed
     */
    pub fn map (mut self)-> VkResult {
        if (self._mappedData == null) {
            vkMapMemory (self._device:.getDeviceHandle (),
                         self._memAlloc.mem,
                         self._memAlloc.offset,
                         self._memAlloc.size,
                         0u32,
                         alias &(self._mappedData))
        } else {
            VkResult::VK_SUCCESS
        }
    }

    /**
     * Unmap the buffer from CPU memory
     */
    pub fn unmap (mut self) {
        if (self._mappedData != null) {
            vkUnmapMemory (self._device:.getDeviceHandle (), self._memAlloc.mem);
            self._mappedData = null;
        }
    }

    /**
     * Update the buffer from CPU datas
     */
    pub fn update {T of [U], U} (mut self, datas : T)
        throws BalderError
    {
        if (self._isLocal) {
            if (self:.map  () == VkResult::VK_SUCCESS) {
                memcpy (self._mappedData, cast!{*void} (datas.ptr), datas.len * U::size);
                self:.unmap ();
            } else throw copy BalderError ("Failed to map memory");
        } else {
            let dmut stagingBuf = self._device:.getMemoryAllocator ():.allocBuffer (
                self._size,
                cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT),
                cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
                          VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT));

            stagingBuf:.map ();
            memcpy (stagingBuf._mappedData, cast!{*void} (datas.ptr), datas.len * U::size);
            stagingBuf:.unmap ();

            self:.copyFrom (alias stagingBuf);
            stagingBuf:.dispose ();
        }
    }

    /**
     * Update the buffer from CPU datas
     */
    pub fn update {T} (mut self, datas : T)
        throws BalderError
    {
        let d = copy [datas];
        self:.update (d);
    }

    /**
     * Copy the buffer 'src' into the self buffer
     * @params:
     *    - src: the buffer to copy from
     */
    prv fn copyFrom (mut self, dmut src : &Buffer) {
        let dmut cmd = self._device:.beginSingleTimeCommand ();
        let mut copyRegion = VkBufferCopy ();

        copyRegion.srcOffset = 0u64;
        copyRegion.dstOffset = 0u64;
        copyRegion.size = self._size;

        vkCmdCopyBuffer (cmd, src._buffer, self._buffer, 1u32, &copyRegion);
        self._device:.endSingleTimeCommand (alias cmd);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==============================================   DISPOSING  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            if (self._buffer != null) {
                self:.unmap ();
                self._allocator:.free (alias self._buffer, self._memAlloc);
                
                self._buffer = null;
                self._size = 0u64;
            }
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}
