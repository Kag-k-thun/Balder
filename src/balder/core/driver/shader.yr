in shader;

use balder::core::driver::_;
use balder::core::{error, dispose};
use balder::math::vector;

use vulkan::_;
use std::{conv, fs::_};

/**
 * Ancestor of all kind of shaders
 */
@abstract
pub class Shader {

    // The layout of the shader
    let dmut _pipelineLayout : &PipelineLayout;
    
    // The vulkan device holding the shader
    let dmut _device : &VulkanDevice;

    // The descriptor allocator used to create descriptor sets
    let dmut _allocator : (&DescriptorAllocator)? = none;
    
    // The vulkan handle
    let mut _program : VkPipeline = null;
    
    prot self (dmut device : &VulkanDevice, dmut pipelineLayout : &PipelineLayout)
        with _device = alias device
        , _pipelineLayout = alias pipelineLayout
    {}

    /**
     * @returns: the device used by the shader
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the pipeline layout of the shader
     */
    pub fn getLayout (mut self)-> dmut &PipelineLayout {
        alias self._pipelineLayout
    }

    /**
     * @returns: the allocator of the shader to allocate a descriptor set
     */
    pub fn getAllocator (mut self)-> dmut &DescriptorAllocator {
        if let Ok (dmut x) = alias self._allocator {
                return alias x;
        }

        panic;
    }

    /**
     * Use the shader for the next drawings
     */
    pub fn select (mut self) {
        vkCmdBindPipeline (self._device:.getCommandBuffer (), VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS, self._program);

        let extent = self._device.getSwapchainExtent ();
        let mut viewport = VkViewport ();

        viewport.width = cast!f32 (extent.width);
        viewport.height = cast!f32 (extent.height);
        viewport.maxDepth = 1.0f;

        vkCmdSetViewport (self._device:.getCommandBuffer (), 0u32, 1u32, &viewport);

        let mut scissor = VkRect2D ();
        scissor.extent = extent;

        vkCmdSetScissor (self._device:.getCommandBuffer (), 0u32, 1u32, &scissor);        
    }
    
    impl Disposable {
        pub over dispose (mut self) {}
    }
    
}
   
/**
 * A shader
 * @template: 
 *    - IN: the input type of the shader 
 *    - UN: the uniform type of the shader
 */
pub class Shader {record IN, record UN} over Shader {

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * @params: 
     *    - device: the device used to allocate the shader
     *    - pipelineLayout: the layout describing the shader uniform content
     *    - vertSrc: the path of the vertex shader
     *    - fragSrc: the path of the fragment shader
     */
    pub self simplePass (dmut device : &VulkanDevice, vertSrc : Path, fragSrc : Path)
        with super (alias device, copy PipelineLayout!{UN} (alias device))
        throws BalderError
    {
        if let dmut l : &PipelineLayout!{UN} = alias self._pipelineLayout {
            self._allocator = (copy DescriptorAllocator!{UN} (alias l))?;
        }
        
        let vertContent = self.readFile (vertSrc);
        let fragContent = self.readFile (fragSrc);

        let vertShader = self:.createShaderModule (vertContent);
        let fragShader = self:.createShaderModule (fragContent);

        let mut vertShaderStageInfo = VkPipelineShaderStageCreateInfo ();
        vertShaderStageInfo.sType  = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        vertShaderStageInfo.stage  = VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT;
        vertShaderStageInfo.module = vertShader;
        vertShaderStageInfo.pName  = std::conv::toStringZ ("main");

        let mut fragShaderStageInfo = VkPipelineShaderStageCreateInfo ();
        fragShaderStageInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        fragShaderStageInfo.stage = VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT;
        fragShaderStageInfo.module = fragShader;
        fragShaderStageInfo.pName = std::conv::toStringZ ("main");

        let shaderStages = copy [vertShaderStageInfo, fragShaderStageInfo];
        self._program = self:.createPipeline (shaderStages);
        
        vkDestroyShaderModule (self._device:.getDeviceHandle (), vertShader, null);
        vkDestroyShaderModule (self._device:.getDeviceHandle (), fragShader, null);                
    }

    /**
     * @returns: the content of a shader file
     */
    fn readFile (self, src : Path)-> [u8]
        throws BalderError
    {
        {
            let dmut f = File::open (src);
            f:.readBytesAll ()
        } catch {
            _ => throw copy BalderError ("Shader file not found : " ~ src.toStr ());
        }
    }

    /**
     * Create a shader module from bytecode of the shader
     * @returns: the shader module
     */
    fn createShaderModule (mut self, bytecode : [u8])-> VkShaderModule
        throws BalderError
    {
        let mut createInfo = VkShaderModuleCreateInfo ();
        createInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
        createInfo.codeSize = bytecode.len;
        createInfo.pCode = cast!{*u32} (cast!{*void} (bytecode.ptr));

        let dmut module : VkShaderModule = null;
        if (vkCreateShaderModule (self._device:.getDeviceHandle (), &createInfo, null, alias &module) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create shader module");
        }

        module
    }

    /**
     * Create the pipeline of the shader
     */
    fn createPipeline (mut self, stages : [VkPipelineShaderStageCreateInfo])-> dmut VkPipeline
        throws BalderError
    {
        let (attrDescr, bindDescr) = self.createAttributeDescription ();

        let mut vertexInputInfo = VkPipelineVertexInputStateCreateInfo ();
        vertexInputInfo.sType                           = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
        vertexInputInfo.vertexBindingDescriptionCount   = 1u32;
        vertexInputInfo.pVertexBindingDescriptions      = &bindDescr;
        vertexInputInfo.vertexAttributeDescriptionCount = cast!u32 (attrDescr.len);
        vertexInputInfo.pVertexAttributeDescriptions    = attrDescr.ptr;

        let mut inputAssembly = VkPipelineInputAssemblyStateCreateInfo ();
        inputAssembly.sType                  = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
        inputAssembly.topology               = VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        inputAssembly.primitiveRestartEnable = VK_FALSE;

        let mut viewport = VkViewport ();
        viewport.x        = 0.0f;
        viewport.y        = 0.0f;
        viewport.width    = cast!f32 (self._device.getSwapchainExtent ().width);
        viewport.height   = cast!f32 (self._device.getSwapchainExtent ().height);
        viewport.minDepth = 0.0f;
        viewport.maxDepth = 1.0f;

        let mut scissors = VkRect2D ();
        scissors.extent = self._device.getSwapchainExtent ();

        let dynStateList = copy [VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT,
                                 VkDynamicState::VK_DYNAMIC_STATE_SCISSOR];

        let mut dynState = VkPipelineDynamicStateCreateInfo ();
        dynState.sType              = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
        dynState.dynamicStateCount  = cast!u32 (dynStateList.len);
        dynState.pDynamicStates     = dynStateList.ptr;

        let mut viewportState = VkPipelineViewportStateCreateInfo ();
        viewportState.sType         = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
        viewportState.viewportCount = 1u32;
        viewportState.pViewports    = &viewport;
        viewportState.scissorCount  = 1u32;
        viewportState.pScissors     = &scissors;

        let mut rasterizer = VkPipelineRasterizationStateCreateInfo ();
        rasterizer.sType                   = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
        rasterizer.depthClampEnable        = VK_FALSE;
        rasterizer.rasterizerDiscardEnable = VK_FALSE;
        rasterizer.polygonMode             = VkPolygonMode::VK_POLYGON_MODE_FILL;
        rasterizer.cullMode                = cast!u32 (VkCullMofnlagBits::VK_CULL_MODE_BACK_BIT);
        rasterizer.frontFace               = VkFrontFace::VK_FRONT_FACE_CLOCKWISE;
        rasterizer.depthBiasEnable         = VK_FALSE;
        rasterizer.lineWidth               = 1.0f;

        let mut multisampling = VkPipelineMultisampleStateCreateInfo ();
        multisampling.sType                 = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
        multisampling.sampleShadingEnable   = VK_FALSE;
        multisampling.rasterizationSamples  = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        multisampling.minSampleShading      = 1.0f;
        multisampling.alphaToCoverageEnable = VK_FALSE;
        multisampling.alphaToOneEnable      = VK_FALSE;

        let mut colorBlendAttachement = VkPipelineColorBlendAttachmentState ();
        colorBlendAttachement.colorWriteMask      = cast!u32 (VkColorComponentFlagBits::VK_COLOR_COMPONENT_R_BIT |
                                                              VkColorComponentFlagBits::VK_COLOR_COMPONENT_G_BIT |
                                                              VkColorComponentFlagBits::VK_COLOR_COMPONENT_B_BIT |
                                                              VkColorComponentFlagBits::VK_COLOR_COMPONENT_A_BIT);
        colorBlendAttachement.blendEnable         = VK_TRUE;
        colorBlendAttachement.srcColorBlendFactor = VkBlendFactor::VK_BLEND_FACTOR_SRC_ALPHA;
        colorBlendAttachement.dstColorBlendFactor = VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR;
        colorBlendAttachement.colorBlendOp        = VkBlendOp::VK_BLEND_OP_ADD;
        colorBlendAttachement.srcAlphaBlendFactor = VkBlendFactor::VK_BLEND_FACTOR_ONE;
        colorBlendAttachement.dstAlphaBlendFactor = VkBlendFactor::VK_BLEND_FACTOR_ZERO;
        colorBlendAttachement.alphaBlendOp        = VkBlendOp::VK_BLEND_OP_ADD;

        let mut colorBlending = VkPipelineColorBlendStateCreateInfo ();
        colorBlending.sType           = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
        colorBlending.logicOpEnable   = VK_FALSE;
        colorBlending.logicOp         = VkLogicOp::VK_LOGIC_OP_COPY;
        colorBlending.attachmentCount = 1u32;
        colorBlending.pAttachments    = &colorBlendAttachement;

        let renderPass = self._device:.getRenderPass ();

        let mut pipelineInfo = VkGraphicsPipelineCreateInfo ();
        pipelineInfo.sType               = VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
        pipelineInfo.stageCount          = cast!u32 (stages.len);
        pipelineInfo.pStages             = stages.ptr;
        pipelineInfo.pVertexInputState   = &vertexInputInfo;
        pipelineInfo.pInputAssemblyState = &inputAssembly;
        pipelineInfo.pViewportState      = &viewportState;
        pipelineInfo.pRasterizationState = &rasterizer;
        pipelineInfo.pMultisampleState   = &multisampling;
        pipelineInfo.pDepthStencilState  = null;
        pipelineInfo.pColorBlendState    = &colorBlending;
        pipelineInfo.pDynamicState       = &dynState;
        pipelineInfo.renderPass          = renderPass;
        pipelineInfo.layout              = self._pipelineLayout:.getVulkanHandle ();
        pipelineInfo.subpass             = 0u32;
        pipelineInfo.basePipelineHandle  = null;
        pipelineInfo.basePipelineIndex   = -1;

        let dmut pipeline : VkPipeline = null;
        if (vkCreateGraphicsPipelines (self._device:.getDeviceHandle (), null, 1u32, &pipelineInfo, null, alias &pipeline) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create graphic pipeline");
        }

        alias pipeline
    }


    /**
     * Create the vertex description of the input vertex type of the shader
     */
    fn createAttributeDescription (self)-> ([VkVertexInputAttributeDescription], VkVertexInputBindingDescription) {
        let infos = __pragma!field_infos (IN);
        let dmut res = copy [VkVertexInputAttributeDescription () ; infos.len];

        cte for i in 0us .. infos.len {
            let mut attrDesc = VkVertexInputAttributeDescription ();
            attrDesc.binding  = 0;
            attrDesc.location = i;
            attrDesc.format   = getFormat!{IN, (__pragma!field_type (IN, infos [i].name))} ();
            attrDesc.offset   = infos [i].offset;
            res[i] = attrDesc;
        }


        let mut bind = VkVertexInputBindingDescription ();
        bind.binding   = 0u32;
        bind.stride    = IN::size;
        bind.inputRate = VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX;

        (res, bind)
    }

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut m) = alias self._allocator {
                m:.dispose ();
            }
            
            self._pipelineLayout:.dispose ();

            if (self._program != null) {
                vkDestroyPipeline (self._device:.getDeviceHandle (), self._program, null);
                self._program = null;
            }
            
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
}


