in desc_alloc;

use balder::core::driver::_;
use balder::core::{error, dispose};
use balder::utils::log;

use ::vulkan::core;

@final
pub class DescriptorAllocator {
    
    // The vulkan device used for allocation
    let dmut _device : &VulkanDevice;

    // The set of used pools
    let dmut _usedPools : [[VkDescriptorType] => [VkDescriptorPool]] = copy [];

    // The set of free pools
    let dmut _freePools : [[VkDescriptorType] => VkDescriptorPool] = copy [];

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE   =======================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
    {}

    /**
     * @returns: the device used to allocate descriptor sets
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ALLOCATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Allocate a descriptor set
     */
    pub fn allocate (mut self, dmut layout : VkDescriptorSetLayout, sizes : [VkDescriptorType])-> dmut [VkDescriptorSet]
        throws BalderError
    {
        let dmut pool = self:.getPool (sizes);
        let dmut set : [VkDescriptorSet] = copy [null ; self._device.getSwapchainNbFrames ()];
        let mut layouts : [mut VkDescriptorSetLayout] = copy [layout ; self._device.getSwapchainNbFrames ()];

        let mut allocInfo = VkDescriptorSetAllocateInfo ();
        allocInfo.sType              = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
        allocInfo.descriptorPool     = pool;
        allocInfo.descriptorSetCount = cast!u32 (layouts.len);
        allocInfo.pSetLayouts        = layouts.ptr;

        let mut res = vkAllocateDescriptorSets (self._device.getDeviceHandle (), &allocInfo, alias set.ptr);
        if (res == VkResult::VK_ERROR_FRAGMENTED_POOL || res == VkResult::VK_ERROR_OUT_OF_POOL_MEMORY) {
            self:.setUsed (alias pool, sizes);

            log::debug ("Pool is full, try to reallocate in a new one");
            allocInfo.descriptorPool = self:.getPool (forceFree-> true, sizes);
            res = vkAllocateDescriptorSets (self._device.getDeviceHandle (), &allocInfo, alias set.ptr);
        }

        if (res != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to allocate a descriptor set."s8);
        }

        return alias set;
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   PRIVATE   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: a usable pool for set allocation
     */
    fn getPool (mut self, forceFree : bool = false, config : [VkDescriptorType])-> dmut VkDescriptorPool
        throws BalderError
    {
        if !forceFree {
            for z, dmut p in alias self._freePools {
                if z == config {
                    return alias p;
                }
            }
        }

        return self:.createDescriptorPool (config);
    }

    /**
     * Set the pool in the used set to be destroyed later on
     * */
    fn setUsed (mut self, dmut pool : VkDescriptorPool, config : [VkDescriptorType]) {
        self._freePools:.remove (config);
        if let Ok (dmut lst) = alias self._usedPools [config] {
            self._usedPools [config] = lst ~ [alias pool];
        } else {
            self._usedPools [config] = copy [alias pool];
        }
    }

    /**
     * Create a new descriptor pool
     */
    fn createDescriptorPool (mut self, sizes : [VkDescriptorType])-> dmut VkDescriptorPool
        throws BalderError
    {
        let dmut descs = copy [VkDescriptorPoolSize () ; sizes.len];
        for i, t in sizes {
            descs [i].type = t;
            descs [i].descriptorCount = self._device.getSwapchainNbFrames ();
        }

        let mut poolInfo = VkDescriptorPoolCreateInfo ();
        poolInfo.sType         = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        poolInfo.poolSizeCount = cast!u32 (descs.len);
        poolInfo.pPoolSizes    = descs.ptr;
        poolInfo.maxSets       = self._device.getSwapchainNbFrames ();

        let dmut descPool : VkDescriptorPool = null;
        if (vkCreateDescriptorPool (self._device.getDeviceHandle (), &poolInfo, null, alias &descPool) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("failed to create descriptor pool."s8);
        }

        self._freePools [sizes] = alias descPool;
        return alias descPool;
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================  CLEANING   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            log::debug ("Disposing descriptor allocator");
            for _, z in self._freePools {
                vkDestroyDescriptorPool (self._device.getDeviceHandle (), z, null);
            }

            for _, dmut lst in alias self._usedPools {
                for dmut z in alias lst {
                    vkDestroyDescriptorPool (self._device.getDeviceHandle (), z, null);
                }
            }

            self._freePools = copy [];
            self._usedPools = copy [];
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }
}
