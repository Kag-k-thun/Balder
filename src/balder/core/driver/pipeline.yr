in pipeline;

use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;

enum
| REDRAW    = 1
| DRAWING   = 2
| SWAPPED   = 3
 -> FrameDrawing;

class PassContent {
    pub let dmut pass : &VulkanSubpass;
    pub let mut sems : [mut [VkSemaphore]] = [];
    pub let dmut stages : [u32] = [];

    pub self (dmut pass : &VulkanSubpass)
        with pass = alias pass
    {}            
}


/**
 * A pass pipeline is a DAG of subpasses ending with the swapchain renderpass
 * The DAG of a pipeline has a particularity, nodes have only one output node, they can have mutliple entries but only one exit edge
 * */
@final
pub class VulkanPipeline {
    
    // The device to which the pipeline is attached
    let dmut _device : &VulkanDevice;


    prot { // pass redrawing
        
        // The frames that have been swapped already
        let dmut _updated : [FrameDrawing] = [];

        // The number of frames to redraw
        let mut _redrawFrames : u32 = 0;
    }

    prot { // pass graph

        // The list of subpasses (name => index in passgraph)
        let dmut _passes : [[c8] => u32] = copy [];

        // The pass Directed Acyclic Graph
        let dmut _DAG : [[c8] => [c8]] = copy []; 
        
        // The DAG of passes sorted by dependences
        let dmut _passGraph : [&PassContent] = [];

        // The compose pass (out node of the pipeline DAG)
        let dmut _compose : &PassContent;        
    }

    prot {
        // The garbage bin used for cleaning
        let dmut _bin : &GarbageBin = copy GarbageBin ();
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
        , _compose = copy PassContent (alias self._device:.getSwapchain ():.getRenderPass ())
    {
        let sems = self._device.getImageAvailableSemaphores ();
        
        self._compose.stages = copy [VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT];
        self._compose.sems = copy [copy [sems [i]] for i in 0 .. sems.len];

        self._updated = copy [FrameDrawing::REDRAW ; sems.len];
    }    

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          TRASH BIN          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @return: the garbage bin used to recycle resources when all their references have disappeared
     * */
    pub fn getBin (mut self)-> dmut &GarbageBin {
        alias self._bin
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          SYNCHRONIZATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */        
    
    /**
     * Wait for the previous frame of the pipeline to be presented to the screen
     * */
    pub fn waitPreviousFrame (mut self) {                        
        if self._device.needResize () {
            self._device:.recreateSwapchain ();
            self:.forceRedraw ();
        } catch {
            err => {
                log::error #("VulkanPipeline", "Failed to recreate swapchain", err);
                return;
            }
        }

        let frame = self._device.getCurrentFrameIndex ();
        // for dmut pass in alias self._passGraph {
        //     pass.pass:.await (frame);
        // }
        
        self._compose.pass:.await (frame);        
    }

    /**
     * Submit the current frame to the graphics and compute queues
     * */
    pub fn submitFrame (mut self) {
        let frame = self._device.getCurrentFrameIndex ();

        if self._updated [frame] != FrameDrawing::SWAPPED {
            log::debug #("VulkanPipeline", "Outdated frame : ", frame);
            if (self:.submitRedraw (frame)) {
                self._bin:.emptyTrash ();
            }            
        } else {
            self:.submitNoDraw (frame);

        }
    }

    /**
     * Redraw the current frame in the pipeline and submit the rendering 
     * */
    prot fn submitRedraw (mut self, frame : u32)-> bool {
        atomic self {
            self._updated [frame] = FrameDrawing::DRAWING;
        }
                        
        { // Redraw all subpasses for the current frame
            for dmut pass in alias self._passGraph {
                pass.pass:.redraw (frame);
            }
            self._compose.pass:.redraw (frame);
        }

        {
            self._updated [frame] = FrameDrawing::SWAPPED;        
            self._redrawFrames -= 1;            
        }
        
        self:.submitNoDraw (frame);
                
        return self._redrawFrames == 0;                    
    }

    /**
     * Submit the frame to be drawn on screen without needing to redraw it
     * */
    prot fn submitNoDraw (mut self, frame : u32) {
        for dmut pass in alias self._passGraph {
            pass.pass:.submit (frame, pass.stages, pass.sems [frame]);
        }
        
        self._compose.pass:.submit (frame,                                   
                                    self._compose.stages,
                                    self._compose.sems [frame]);
    }
    
    /**
     * Force the subpass to be redrawn
     * */
    pub fn forceRedraw (mut self) {
        atomic self {
            for i in 0 .. self._updated.len {
                self._updated [i] = FrameDrawing::REDRAW;
                self._redrawFrames = cast!u32 (self._updated.len);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          DAG MANAGEMENT          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a subpass in the DAG
     * */
    pub fn registerSubPass (mut self, name : [c8], dmut pass : &VulkanSubpass)
        throws BalderError
    {
        name;
        pass;
        throw copy BalderError ("TODO"); 
    }    

    /**
     * Remove a subpass in the DAG
     * @warning: connect the passes having 'name' as output to the output of 'name'
     * */
    pub fn removeSubPass (mut self, name : [c8]) {
        name;
    }

    /**
     * Change the output pass of the pass 'name'
     * @throws: if a cycle is detected or the pass don't exist
     * */
    pub fn setPassOutput (mut self, name : [c8], output : [c8])
        throws BalderError
    {
        name;
        output;
        throw copy BalderError ("TODO");
    }

    /**
     * Set the pass output as the swapchain final pass
     * @throws: if the pass doesn't exist
     * */
    pub fn setPassOutputToSwap (mut self, name : [c8])
        throws BalderError
    {
        name;
        throw copy BalderError ("TODO");
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {        
            atomic self {
                self._device:.waitIdle ();
                for dmut pass in alias self._passGraph {
                    pass.pass:.dispose ();
                }
                self._compose.pass:.resetCommands ();
                self._compose.pass:.resetDrawSignal ();
                
                self._passGraph = [];
                self._passes = copy [];
                self._DAG = copy [];
                
                self:.forceRedraw ();
            }
            
            self._bin:.emptyTrash ();
        }
    }
}
