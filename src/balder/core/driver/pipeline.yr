in pipeline;

use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;


/**
 * A pass pipeline is a DAG of subpasses ending with the swapchain renderpass
 * */
@final
pub class VulkanPipeline {
    
    // The device to which the pipeline is attached
    let dmut _device : &VulkanDevice;


    prot { // Synchronization between passes

        // Semaphore to waits before submitting the swapchain render pass to graphics queue
        let mut _swapChainWaits : [[VkSemaphore]] = [];

        // Stages of semaphore to wait before submitting the swapchain render pass to graphics queue
        let dmut _swapChainStages : [u32] = [];

        // True if the swapchain draw pass need a redraw before submit
        let mut _swapNeedRedraw : bool = false;
    }

    prot { // passes

        // The list of subpasses (name => index in passgraph)
        let dmut _passes : [[c8] => u32] = copy [];

        // The DAG of passes sorted by priority
        // (.0 => the pass,
        //  .1 => the list of semaphore to wait for the pass,
        //  .2 => the state of the previous passes to wait
        //  .3 => true iif need a redraw)        
        let dmut _passGraph : [(&VulkanSubpass, [[VkSemaphore]], [u32])] = [];

        // The draw pass of the swap chain
        let dmut _composePass : &VulkanSubpass;
        
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
        , _composePass = alias self._device:.getSwapchain ():.getRenderPass ()
    {
        let sems = self._device.getImageAvailableSemaphores ();
        self._swapChainStages = copy [VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT];
        self._swapChainWaits = copy [copy [sems [i]] for i in 0 .. sems.len];
    }    

    __dtor (mut self) {
        self:.dispose ();
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          SYNCHRONIZATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */        
    
    /**
     * Wait for the previous frame of the pipeline to be presented to the screen
     * */
    pub fn waitPreviousFrame (mut self) {                        
        if self._device.needResize () {
            self._device:.recreateSwapchain ();
            self._composePass:.forceRedraw ();
        } catch {
            err => {
                log::error #("VulkanPipeline", "Failed to recreate swapchain", err);
                return;
            }
        }
        
        self._composePass:.await (self._device.getCurrentFrameIndex ());        
    }

    /**
     * Submit the current frame to the graphics and compute queues
     * */
    pub fn submitFrame (mut self) {
        let frame = self._device.getCurrentFrameIndex ();
                
        self._composePass:.execute (frame,
                                    self._swapChainStages,
                                    self._swapChainWaits [frame]);    
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {}
    }
}
