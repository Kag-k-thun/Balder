in pipeline;

use ::vulkan::core;

use balder::core::{_, driver::_, memory::_, application::_, shader::_};
use balder::utils::log;

use std::io;

enum
| REDRAW    = 1
| DRAWING   = 2
| SWAPPED   = 3
 -> FrameDrawing;

record PassContent {    
    pub let dmut pass : &VulkanSubpass;
    pub let mut sems : [mut [VkSemaphore]] = [];
    pub let dmut stages : [u32] = [];
    pub let mut isEntry : bool = false;
    
    pub self (dmut pass : &VulkanSubpass)
        with pass = alias pass
    {}            
}


/**
 * A pass pipeline is a DAG of subpasses ending with the swapchain renderpass
 * The DAG of a pipeline has a particularity, nodes have only one output node, they can have mutliple entries but only one exit edge
 * */
@final
pub class VulkanPipeline {
    
    // The device to which the pipeline is attached
    let dmut _device : &VulkanDevice;


    prot { // pass redrawing
        
        // The frames that have been swapped already
        let dmut _updated : [FrameDrawing] = [];

        // The number of frames to redraw
        let mut _redrawFrames : u32 = 0;
    }

    prot { // pass graph

        // The list of subpasses (name => index in passgraph)
        let dmut _passes : [[c8] => &VulkanSubpass] = copy [];

        // The pass Directed Acyclic Graph
        let mut _DAG : [[c8] => mut [c8]] = copy [];        
        
        // The DAG of passes sorted by dependences
        let dmut _passGraph : [PassContent] = [];

        // The list of entry passes
        let dmut _entryPasses : [PassContent] = [];

        // The compose pass (out node of the pipeline DAG)
        let dmut _compose : &VulkanSubpass;        
    }

    prot {
        // The garbage bin used for cleaning
        let dmut _bin : &GarbageBin = copy GarbageBin ();
    }

    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
        , _compose = alias self._device:.getSwapchain ():.getRenderPass ()
    {
        self:.resetToDefault ();
    }        

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          TRASH BIN          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @return: the garbage bin used to recycle resources when all their references have disappeared
     * */
    pub fn getBin (mut self)-> dmut &GarbageBin {
        alias self._bin
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          SYNCHRONIZATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */        
    
    /**
     * Wait for the previous frame of the pipeline to be presented to the screen
     * */
    pub fn waitPreviousFrame (mut self) {                        
        if self._device.needResize () {
            self._device:.recreateSwapchain ();
            self:.forceRedraw ();
        } catch {
            err => {
                log::error #("VulkanPipeline", "Failed to recreate swapchain", err);
                return;
            }
        }

        let frame = self._device.getCurrentFrameIndex ();                
        for dmut pass in alias self._entryPasses {
            pass.pass:.await (frame);
        }                    
    }

    /**
     * Submit the current frame to the graphics and compute queues
     * */
    pub fn submitFrame (mut self) {
        let frame = self._device.getCurrentFrameIndex ();

        if self._updated [frame] != FrameDrawing::SWAPPED {
            log::debug #("VulkanPipeline", "Outdated frame : ", frame);
            if (self:.submitRedraw (frame)) {
                self._bin:.emptyTrash ();
            }            
        } else {
            self:.submitNoDraw (frame);

        }
    }

    /**
     * Redraw the current frame in the pipeline and submit the rendering 
     * */
    prot fn submitRedraw (mut self, frame : u32)-> bool {
        atomic self {
            self._updated [frame] = FrameDrawing::DRAWING;
        }
                        
        { // Redraw all subpasses for the current frame
            for dmut pass in alias self._passGraph {
                pass.pass:.redraw (frame);
            }            
        }

        {
            self._updated [frame] = FrameDrawing::SWAPPED;        
            self._redrawFrames -= 1;            
        }
        
        self:.submitNoDraw (frame);
                
        return self._redrawFrames == 0;                    
    }

    /**
     * Submit the frame to be drawn on screen without needing to redraw it
     * */
    prot fn submitNoDraw (mut self, frame : u32) {
        for dmut pass in alias self._passGraph {
            if !pass.isEntry {
                pass.pass:.await (frame);
            }
            
            pass.pass:.submit (frame, pass.stages, pass.sems [frame]);
        }        
    }
    
    /**
     * Force the subpass to be redrawn
     * */
    pub fn forceRedraw (mut self) {
        atomic self {
            for i in 0 .. self._updated.len {
                self._updated [i] = FrameDrawing::REDRAW;
                self._redrawFrames = cast!u32 (self._updated.len);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          DAG MANAGEMENT          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a subpass in the DAG
     * */
    pub fn registerSubPass (mut self, name : [c8], dmut pass : &VulkanSubpass)
        throws BalderError
    {
        atomic self {        
            if name == "" {
                throw copy BalderError ("Empty pass name");
            }
            
            self._passes [name] = alias pass;
            self._DAG [name] = ""; // compose pass
        }
    }

    /**
     * Remove a subpass in the DAG
     * @warning: connect the passes having 'name' as output to the output of 'name'
     * */
    pub fn removeSubPass (mut self, name : [c8])
        throws BalderError
    {
        atomic self {                
            self._passes:.remove (name);        

            // Connect the predecessor of 'name' to the output of 'name'        
            if let Ok (out) = self._DAG [name] {
                
                let mut result : [[c8] => mut [c8]] = copy [];
                for i, o in self._DAG if i != name {                
                    if o == name {
                        result [i] = out;
                    } else {
                        result [i] = o;
                    }
                }
                self._DAG = alias result;
                self:.constructGraph ();
            }                
        }
    }

    /**
     * Change the output pass of the pass 'name'
     * @throws: if a cycle is detected or the pass don't exist
     * */
    pub fn setPassOutput (mut self, name : [c8], output : [c8]) 
        throws BalderError
    {
        atomic self {
            if name == "" throw copy BalderError ("Empty pass name");
            if output == "" throw copy BalderError ("Empty pass name");
            
            if output !in self._passes throw copy BalderError ("No pass named " ~ output);
            if name !in self._passes throw copy BalderError ("No pass named " ~ name);
            
            self._DAG [name] = output;            
        
            self:.constructGraph (); 
        }
    }

    /**
     * Set the pass output as the swapchain final pass
     * @throws: if the pass doesn't exist
     * */
    pub fn setPassOutputToSwap (mut self, name : [c8])
        throws BalderError
    {
        atomic self {
            if name == "" throw copy BalderError ("Empty pass name");
            if name !in self._passes throw copy BalderError ("No pass named " ~ name);
            
            self._DAG [name] = "";
            self:.constructGraph ();        
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          CONSTRUCTION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Reset the drawing pipeline to its default state (only the final compose pass)
     * */
    fn resetToDefault (mut self) atomic self {                                
        let dmut content = PassContent (alias self._compose);        
        let sems = self._device.getImageAvailableSemaphores ();
        
        content.stages = copy [VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT];
        content.sems = copy [copy [sems [i]] for i in 0 .. sems.len];
        content.isEntry = true;
        
        self._entryPasses = copy [alias content];
        self._passGraph = copy [content];    
        self._updated = copy [FrameDrawing::REDRAW ; sems.len];
        self._passes [""] = alias self._compose;
    }
    
    /**
     * Construct the graph of pass dependencies, and construct the semaphores lists
     * */
    fn constructGraph (mut self)
        throws BalderError
    {        
        let (sortedPass, deps) = self.constructSortedList ();
        let nbFrames = self._device:.getSwapchain ().nbFrames;
        let dmut result : [PassContent] = [];
        let dmut entryPasses : [PassContent] = [];        
        
        for pname in sortedPass {
            let mut sems : [mut [VkSemaphore]] = copy [[] ; nbFrames];
            let dmut stages : [u32] = [];

            // List the semaphores of predecessor passes
            if let Ok (lst) = deps [pname] for previous in lst {
                if let Ok (pass : &DrawSubpass) = self._passes [previous] {
                    stages ~= [VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT];
                    for f in 0 .. nbFrames {                    
                        sems [f] ~= [pass.getSemaphore (f)];
                    }
                } else if let Ok (pass : &ComputeSubpass) = self._passes [previous] {
                    stages ~= [VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT];
                    for f in 0 .. nbFrames {
                        sems [f] ~= [pass.getSemaphore (f)];
                    }
                } else {
                    log::error #("VulkanPipeline", "Undefined subpass kind :", previous, " ", self._passes [previous]);
                    throw copy BalderError ("Failed to contrusct pass graph");
                }
            }            

            let mut entry = false;
            // Then it's an entry node, and it depends on image available
            if stages.len == 0 {
                let deviceSems = self._device.getImageAvailableSemaphores ();                                
                stages = copy [VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT];
                sems = copy [copy [deviceSems [f]] for f in 0 .. deviceSems.len];
                entry = true;
            }

            // Adding it on the result graph
            if let Ok (dmut p) = alias self._passes [pname] {
                let dmut content = PassContent (alias p);
                content.sems = alias sems;
                content.stages = alias stages;
                content.isEntry = entry;
                
                result ~= [alias content];
                if entry { entryPasses ~= [alias content]; }
            } else {
                log::error #("VulkanPipeline", "malformed graph", self._passes, '(', pname, ')');
                panic;
            }             
        }

        self:.forceRedraw ();
        self._passGraph = alias result;
        self._entryPasses = alias entryPasses;
    }

    /**
     * Sorted the passes by dependencies
     * */
    fn constructSortedList (self)-> ([[c8]], [[c8] => [[c8] => ()]])
        throws BalderError
    {
        let dmut reversed = self.reverseGraph (self._DAG);        
        let dmut deps = dcopy reversed;
                
        let dmut result : [[c8]] = [];

        while reversed.len != 0 {
            let mut fnd : [c8] = "";
            let mut hasFnd = false;
            for i, lst in reversed {
                if lst.len == 0 {
                    result ~= [i];
                    hasFnd = true;
                    fnd = i;
                    break;
                }
            }
                
            if !hasFnd {
                log::error #("Pipeline", "failed", reversed);
                throw copy BalderError ("Failed to construct graph, cycle detected");
            }

            // Remove the node from dependencies
            reversed:.remove (fnd);            
            for _, dmut lst in alias reversed {                
                lst:.remove (fnd);            
            }                                
        }

        (result, deps)
    }

    /**
     * @returns: the reversed graph, where every node list its predecessors
     * */
    fn reverseGraph (self, graph : [[c8] => [c8]])-> dmut [[c8] => [[c8] => ()]] {
        let dmut result : [[c8] => [[c8] => ()]] = copy [];
        for i, out in graph {
            if let Ok (dmut lst) = alias result [out] {
                lst [i] = ();                 
            } else {
                result [out] = copy [i => ()];
            }

            if i !in result {
                result [i] = copy [];
            }
        }

        alias result
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {        
            atomic self {
                self._device:.waitIdle ();
                for dmut pass in alias self._passGraph {
                    if pass.pass !is self._compose {
                        pass.pass:.dispose ();
                    }
                }                
                
                self:.resetToDefault ();
                self._compose:.resetCommands ();
                self._compose:.resetDrawSignal ();
                                                
                self:.forceRedraw ();
            }
            
            self._bin:.emptyTrash ();
        }
    }
}
