in shader;

use std::{config::_, fs::_, stream};

use balder::math::_;
use balder::core::error;

use ::vulkan::core;

pub record UniformInfo {
    pub let mut binding : u32 = 0;
    pub let mut size : u64 = 0;
    pub let mut stage : VkShaderStageFlags = VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS;
    pub self () {}
}

pub enum
| ALBEDO = "albedo"
| DEPTH = "depth"
 -> TextureKind;

pub enum
| NORMALS = "normals"
| TANGENTS = "tangents"
| COLORS = "colors"
| TEX_UV = "uv"
| TEX_UV2 = "uv2"
| BONES = "bones"
| WEIGHTS = "weights"
 -> VertexEntry;

pub record TextureInfo {
    pub let mut binding : u32 = 0;
    pub let mut stage : VkShaderStageFlags = VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS;
    pub let mut magFilter : VkFilter = VkFilter::VK_FILTER_LINEAR;
    pub let mut minFilter : VkFilter = VkFilter::VK_FILTER_LINEAR;
    pub let mut addressModeU : VkSamplerAddressMode = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
    pub let mut addressModeV : VkSamplerAddressMode = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
    pub let mut addressModeW : VkSamplerAddressMode = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
    pub let mut anisotropyEnable : bool = true;
    pub let mut maxAnisotropy : f32 = 1000.f;
    pub let mut unnormalizedCoordinates : bool = false;
    pub let mut compareEnable : bool = false;
    pub let mut compareOp : VkCompareOp = VkCompareOp::VK_COMPARE_OP_ALWAYS;
    pub let mut mipmapMode : VkSamplerMipmapMode = VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR;
    pub let mut borderColor : VkBorderColor = VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    pub let mut kind : [c8] = "albedo";

    pub self () {}
}

pub record ShaderPass {
    pub let mut stage : VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
    pub let mut mainFunc : [c8] = "main";
    pub let mut shaderFile : [c8] = "";

    pub self () {}
}

@final
pub class ShaderConfig {
    let dmut _depth : bool = true;

    let dmut _normals : bool = false; // vec3
    let dmut _tangents : bool = false; // vec3

    let dmut _colors : bool = false; // vec3
    let dmut _textureUVs : bool = false;  // vec2
    let dmut _textureUVs2 : bool = false; // vec2

    let dmut _bones : bool = false; // vec4
    let dmut _weights : bool = false; // vec4

    let dmut _passes : [ShaderPass] = [];
    let dmut _uniforms : [[c8] => UniformInfo] = copy [];
    let dmut _textures : [[c8] => TextureInfo] = copy [];

    pub self (config : [c8])
        throws BalderError
    {
        let dmut file = File::open (balder::utils::path::projectPath (config));
        let cfg = std::config::toml::parse (file:.readAll ());

        self:.selectVertexEntries (cfg);
        self:.selectPasses (cfg);

        if let Ok (d : &Dict) = cfg ["uniform"]? {
            for p, c in d[] {
                let mut un = UniformInfo ();
                un.binding = c ["binding"].to!{u32} ();
                un.size = c ["size"].to!{u64} ();
                un.stage = self.selectUniformStage (if let Ok (v) = c ["stage"].to![c8] ()? { v } else { "A" });

                self._uniforms [p] = un;
            }
        }

        if let Ok (d : &Dict) = cfg ["texture"]? {
            for p, c in d[] {
                let mut un = TextureInfo ();
                un.binding = c ["binding"].to!{u32} ();
                un.stage = self.selectUniformStage (if let Ok (Str (value-> v)) = c ["stage"]? { v } else { "A" });

                un.magFilter = self.selectFilter (if let Ok (Str (value-> v)) = c ["mag-filter"]? { v } else { "linear" });
                un.minFilter = self.selectFilter (if let Ok (Str (value-> v)) = c ["min-filter"]? { v } else { "linear" });
                un.addressModeU = self.selectAddressMode (if let Ok (v) = c ["addressModeU"].to![c8] ()? { v } else if let Ok (v) = c ["addressMode"].to![c8] ()? { v } else { "repeat" });
                un.addressModeV = self.selectAddressMode (if let Ok (v) = c ["addressModeV"].to![c8] ()? { v } else if let Ok (v) = c ["addressMode"].to![c8] ()? { v } else { "repeat" });
                un.addressModeW = self.selectAddressMode (if let Ok (v) = c ["addressModeW"].to![c8] ()? { v } else if let Ok (v) = c ["addressMode"].to![c8] ()? { v } else { "repeat" });

                un.anisotropyEnable = if let Ok (b) = c ["anisotropy"].to!{bool} ()? { b } else { true };
                un.maxAnisotropy = if let Ok (f) = c ["max-anisotropy"].to!{f32} ()? { f } else { 16.f };
                un.unnormalizedCoordinates = if let Ok (b) = c ["unnormalizedCoordinates"].to!{bool} ()? { b } else { false };
                un.compareEnable = if let Ok (b) = c ["compare"].to!{bool} ()? { b } else { false };
                un.compareOp = self.selectCompareOp (if let Ok (b) = c ["compare-op"].to!{[c8]} ()? { b } else { "always" });
                un.mipmapMode = self.selectMipMapMode (if let Ok (b) = c ["mipmap"].to!{[c8]} ()? { b } else { "near" });
                un.borderColor = self.selectBorderColor (if let Ok (b) = c ["border-color"].to!{[c8]} ()? { b } else { "f-opaque-black" });
                un.kind = if let Ok (Str (value-> v)) = c ["kind"]? { v } else { TextureKind::ALBEDO };

                self._textures [p] = un;
            }
        }
    } catch {
        err => {
            throw copy BalderError (std::format::format ("Failed to read shader configuration file => \n\t{}", err));
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn getUniforms (self)-> [[c8] => UniformInfo] {
        self._uniforms
    }

    pub fn getTextures (self)-> [[c8] => TextureInfo] {
        self._textures
    }

    pub fn getPasses (self)-> [ShaderPass] {
        self._passes
    }

    @field
    pub fn normals (self)-> bool {
        self._normals
    }

    @field
    pub fn tangents (self)-> bool {
        self._tangents
    }

    @field
    pub fn colors (self)-> bool {
        self._colors
    }

    @field
    pub fn textureUVs (self)-> bool {
        self._textureUVs
    }

    @field
    pub fn textureUVs2 (self)-> bool {
        self._textureUVs2
    }

    @field
    pub fn bones (self)-> bool {
        self._bones
    }

    @field
    pub fn weights (self)-> bool {
        self._weights
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn selectStage (self, stage : [c8])-> VkShaderStageFlagBits
        throws BalderError
    {
        match stage {
            "vertex" => { VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT }
            "fragment" => { VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT }
            "geometry" => { VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT }
            "compute" => { VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT }
            "tessel_ctrl" => { VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT }
            "tessel_eval" => { VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT }
            _ => {
                throw copy BalderError ("Unknwon shader stage " ~ stage);
            }
        }
    }

    fn selectUniformStage (self, name : [c8])-> VkShaderStageFlags
        throws BalderError
    {
        let mut stage : u32 = 0u32;
        for i in 0 .. name.len {
            match name [i] {
                'f' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT); }
                'v' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT); }
                'g' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT); }
                'c' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT); }
                'a' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS); }
                'A' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL); }
                _ => { throw copy BalderError ("Unknwon uniform shader stage " ~ name [i .. i + 1]); }
            }
        }

        stage
    }

    fn selectFilter (self, name : [c8])-> VkFilter {
        match name {
            "nearest" => { VkFilter::VK_FILTER_NEAREST }
            "linear" => { VkFilter::VK_FILTER_LINEAR }
            "cubic" => { VkFilter::VK_FILTER_CUBIC_IMG }
            "cubic-ext" => { VkFilter::VK_FILTER_CUBIC_EXT }
            _ => { VkFilter::VK_FILTER_NEAREST }
        }
    }

    fn selectAddressMode (self, name : [c8])-> VkSamplerAddressMode {
        match name {
            "repeat"            => { VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT }
            "mirrored"          => { VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT }
            "clamp-edge"        => { VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE }
            "clamp-border"      => { VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER }
            "mirror-clamp-edge" => { VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE }
            _                   => { VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT }
        }
    }

    fn selectCompareOp (self, name : [c8])-> VkCompareOp {
        match name {
            "never"    => { VkCompareOp::VK_COMPARE_OP_NEVER }
            "less"     => { VkCompareOp::VK_COMPARE_OP_LESS }
            "equal"    => { VkCompareOp::VK_COMPARE_OP_EQUAL }
            "less-eq"  => { VkCompareOp::VK_COMPARE_OP_LESS_OR_EQUAL }
            "great"    => { VkCompareOp::VK_COMPARE_OP_GREATER }
            "great-eq" => { VkCompareOp::VK_COMPARE_OP_GREATER_OR_EQUAL }
            "always"   => { VkCompareOp::VK_COMPARE_OP_ALWAYS }
            _ => { VkCompareOp::VK_COMPARE_OP_ALWAYS }
        }
    }

    fn selectMipMapMode (self, name : [c8])-> VkSamplerMipmapMode {
        match name {
            "near"   => { VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST }
            "linear" => { VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR }
            _        => { VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST }
        }
    }

    fn selectBorderColor (self, name : [c8])-> VkBorderColor {
        match name {
            "f-transparent-black" => { VkBorderColor::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK }
            "i-transparent-black" => { VkBorderColor::VK_BORDER_COLOR_INT_TRANSPARENT_BLACK }
            "f-opaque-black"      => { VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK }
            "i-opaque-black"      => { VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_BLACK }
            "f-opaque-white"      => { VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE }
            "i-opaque-white"      => { VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_WHITE }
            "f-custom"            => { VkBorderColor::VK_BORDER_COLOR_FLOAT_CUSTOM_EXT }
            "i-custom"            => { VkBorderColor::VK_BORDER_COLOR_INT_CUSTOM_EXT }
            _                     => { VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK }
        }
    }

    fn selectVertexEntries (mut self, cfg : &Config)
        throws BalderError
    {
        if let Ok (d : &Array) = cfg ["vertex"]? {
            for a in d[] {
                if let Str (value-> s) = a match s {
                    VertexEntry::NORMALS => { self._normals = true; }
                    VertexEntry::TANGENTS => { self._tangents = true; }
                    VertexEntry::COLORS => { self._colors = true; }
                    VertexEntry::TEX_UV => { self._textureUVs = true; }
                    VertexEntry::TEX_UV2 => { self._textureUVs2 = true; }
                    VertexEntry::BONES => { self._bones = true; }
                    VertexEntry::WEIGHTS => { self._weights = true; }
                    _ => {
                        throw copy BalderError ("Unexpected vertex entry " ~ s);
                    }
                } else throw copy BalderError ("Unexpected vertex entry " ~ to!{[c8]} (a));
            }
        }
    }

    fn selectPasses (mut self, cfg : &Config)
        throws BalderError
    {
        if let Ok (d : &Dict) = cfg ["pass"]? {
            self._passes = copy [ShaderPass () ; d[].len];
            for p, c in d[] {
                let mut sh = ShaderPass ();
                sh.stage = self.selectStage (p);
                sh.mainFunc = if let Ok (v) = c ["function"].to![c8] ()? { v } else { "main" };
                sh.shaderFile = c ["shader"].to![c8] ();
                let index = c ["index"].to!{u32} ();

                self._passes [index] = sh;
            }
        }
    } catch {
        err => {
            throw copy BalderError (std::format::format ("Failed to read shader configuration file => \n\t{}", err));
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Streamable;
}
