in loader;

use balder::core::error;


use std::conv;
use std::{config::_, fs::_, stream, format::_};

use balder::core::config::shader::_;
use balder::utils::log;

use ::vulkan::core;

/**
 * Load a shader config from a toml file
 * */
pub fn loadShaderConfig (name : [c8])-> dmut &ShaderConfig
    throws BalderError
{
    let cfg = {
        let dmut file = File::open (balder::utils::path::projectPath (name));
        std::config::toml::parse (file:.readAll ())
    } catch {
        fs => {
            throw copy BalderError ("Failed to read configuration file " ~ to!{[c8]} (fs));
        }
    }

    match cfg ["kind"]? {
        Ok (Str (value-> "compute")) => {
            return loadCompute (name, cfg);
        }
        Ok (Str (value-> "raster")) => {
            return loadRaster (name, cfg);
        }
        Ok (z) => {
            throw copy BalderError ("Malformed shader configuration - undefined 'kind' " ~ to!{[c8]} (z));
        }
        _ => {
            throw copy BalderError ("Malformed shader configuration - missing 'kind'");
        }
    }    
}

/**
 * Load a shader config from a toml file (forcing it to be a raster shader)
 * */
pub fn loadRasterShaderConfig (name : [c8])-> dmut &RasterShaderConfig
    throws BalderError
{
    let cfg = {
        let dmut file = File::open (balder::utils::path::projectPath (name));
        std::config::toml::parse (file:.readAll ())
    } catch {
        fs => {
            throw copy BalderError ("Failed to read configuration file " ~ to!{[c8]} (fs));
        }
    }
    
    match cfg ["kind"]? {
        Ok (Str (value-> "raster")) => {
            return loadRaster (name, cfg);
        }
        Ok (z) => {
            throw copy BalderError ("Malformed shader configuration - expected 'raster' " ~ to!{[c8]} (z));
        }
        _ => {
            throw copy BalderError ("Malformed shader configuration - missing 'kind'");
        }
    }
}

/**
 * Load a shader config from a toml file (forcing it to be a raster shader)
 * */
pub fn loadComputeShaderConfig (name : [c8])-> dmut &ComputeShaderConfig
    throws BalderError
{
    let cfg = {
        let dmut file = File::open (balder::utils::path::projectPath (name));
        std::config::toml::parse (file:.readAll ())
    } catch {
        fs => {
            throw copy BalderError ("Failed to read configuration file " ~ to!{[c8]} (fs));
        }
    }
    
    match cfg ["kind"]? {
        Ok (Str (value-> "compute")) => {
            return loadCompute (name, cfg);
        }
        Ok (z) => {
            throw copy BalderError ("Malformed shader configuration - expected 'compute' " ~ to!{[c8]} (z));
        }
        _ => {
            throw copy BalderError ("Malformed shader configuration - missing 'kind'");
        }
    }
}


/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          RASTER          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Load a rasterization shader config
 * */
fn loadRaster (name : [c8], cfg : &Config)-> dmut &RasterShaderConfig
    throws BalderError
{
    let dmut result = copy RasterShaderConfig (name);

    // Raster
    result.depth = (cfg ["depth"]?).toOr!{bool} (true);
    result.blend = loadBlend (cfg);
    result.entries = loadVertexEntries (cfg);
    result.passes = loadRasterPasses (cfg);

    // Common
    result.descSet = loadDescriptorSets (cfg);
    result.pushConstant = loadPushConstant (cfg);

    alias result
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          COMPUTE          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Load a compute shader config
 * */
fn loadCompute (name : [c8], cfg : &Config)-> dmut &ComputeShaderConfig
    throws BalderError
{
    let dmut result = copy ComputeShaderConfig (name);

    // Compute
    result.groupSizes = loadGroupSizes (cfg);
    result.pass = loadComputePass (cfg);
    
    // Common
    result.descSet = loadDescriptorSets (cfg);
    result.pushConstant = loadPushConstant (cfg);

    alias result
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          BLENDING          ====================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadBlend (cfg : &Config)-> BlendInfo
    throws BalderError
{
    let mut blend = BlendInfo ();
    if let Ok (d : &Dict) = cfg ["blend"]? {
        for p, c in d[] match p {
            "enabled"          => { blend.enabled = c.to!{bool} (); }
            "color-op"         => { blend.colorBlendOp = loadBlendOp (c.to![c8] ()); }
            "alpha-op"         => { blend.alphaBlendOp = loadBlendOp (c.to![c8] ()); }
            "src-color-factor" => { blend.srcColorBlendFactor = loadBlendFactor (c.to![c8] ()); }
            "dst-color-factor" => { blend.dstColorBlendFactor = loadBlendFactor (c.to![c8] ()); }
            "src-alpha-factor" => { blend.srcAlphaBlendFactor = loadBlendFactor (c.to![c8] ()); }
            "dst-alpha-factor" => { blend.dstAlphaBlendFactor = loadBlendFactor (c.to![c8] ()); }
            _ => {
                throw copy BalderError ("Unexpected blend configuration " ~ p);
            }
        }
    }

    blend
} catch {
    b : &BalderError => throw b;
    _ => {
        throw copy BalderError ("Malformed blend configuration");
    }
}

fn loadBlendOp (name : [c8])-> VkBlendOp {
    match name {
        "add"         => { VkBlendOp::VK_BLEND_OP_ADD }
        "sub"         => { VkBlendOp::VK_BLEND_OP_SUBTRACT }
        "reverse-sub" => { VkBlendOp::VK_BLEND_OP_REVERSE_SUBTRACT }
        "min"         => { VkBlendOp::VK_BLEND_OP_MIN }
        "max"         => { VkBlendOp::VK_BLEND_OP_MAX }
        _             => { VkBlendOp::VK_BLEND_OP_ADD }
    }
}

fn loadBlendFactor (name : [c8])-> VkBlendFactor {
    match name {
        "zero"                => { VkBlendFactor::VK_BLEND_FACTOR_ZERO }
        "one"                 => { VkBlendFactor::VK_BLEND_FACTOR_ONE }
        "src-color"           => { VkBlendFactor::VK_BLEND_FACTOR_SRC_COLOR }
        "one-minus-src-color" => { VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR }
        "dst-color"           => { VkBlendFactor::VK_BLEND_FACTOR_DST_COLOR }
        "one-minus-dst-color" => { VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR }
        "src-alpha"           => { VkBlendFactor::VK_BLEND_FACTOR_SRC_ALPHA }
        "one-minus-src-alpha" => { VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA }
        "dst-alpha"           => { VkBlendFactor::VK_BLEND_FACTOR_DST_ALPHA }
        "one-minus-dst-alpha" => { VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA }
        _                     => { VkBlendFactor::VK_BLEND_FACTOR_ZERO }
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ==================================          VERTEX ENTRY          ==================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadVertexEntries (cfg : &Config)-> dmut [VertexEntry => (VkFormat, u32)]
    throws BalderError
{    
    let d = if let Ok (d : &Dict) = cfg ["vertex"]? { d }
    else {
        throw copy BalderError ("Vertex description must be a dictionnary");
    };
        
    let dmut entries : [VertexEntry => (VkFormat, u32)] = copy [];        
    for a, k in d[] {
        if let Str (value-> e) = k {
            let entry = loadVertexEntry (a);
            let type = loadEntry (e);
            
            entries [entry] = type;
        } else {
            throw copy BalderError ("Entry type must be a string " ~ to!{[c8]} (k));
        }        
    }

    return alias entries;        
}

fn loadVertexEntry (entry : [c8])-> VertexEntry
    throws BalderError
{
    for _, name in VertexEntry::__members__ {
        if name == entry { return name; }
    }
    
    throw copy BalderError ("Unexpected vertex entry " ~ entry);
}

fn loadEntry (entry : [c8])-> (VkFormat, u32)
    throws BalderError
{
    for name in EntryTypes::__members__ {
        if name._0 == entry {
            return (name._1, name._2);
        }
    }

    throw copy BalderError ("Unexpected entry type " ~ entry);
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          PASSES          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadRasterPasses (cfg : &Config)-> dmut [ShaderPass]
    throws BalderError
{
    let d = if let Ok (d : &Dict) = cfg ["pass"]? { d }
    else {
        throw copy BalderError ("Raster shader passes, must be a dictionnary");
    }

    if d[].len == 0 {
        throw copy BalderError ("Raster shader must have a least one pass");
    }
    
    let dmut passes = copy [ShaderPass () ; d[].len];
    let dmut set = copy [false ; d[].len];
    for p, c in d[] {
        let index = c ["index"].to!{u32} ();
        if set [index] {
            throw copy BalderError ("Pass " ~ to!{[c8]} (index) ~ " set multiple times");
        }

        set [index] = true;
        
        let mut sh = ShaderPass ();
        sh.stage = loadStage (p);
        sh.mainFunc = if let Ok (v) = c ["function"].to![c8] ()? { v } else { "main" };
        sh.shaderFile = c ["shader"].to![c8] ();
        
        if index == 0 && sh.stage != VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT {
            throw copy BalderError ("Raster shader always start with a vertex pass");
        }
        
        passes [index] = sh;
    }

    alias passes        
} catch {    
    err => {
        throw copy BalderError (std::format::format ("Failed to read shader configuration file => \n\t{}", err));
    }
}


fn loadComputePass (cfg : &Config)-> ShaderPass
    throws BalderError
{
    let d = if let Ok (d : &Dict) = cfg ["pass"]? { d }
    else {
        throw copy BalderError ("Raster shader passes, must be a dictionnary");
    }

    if d[].len != 1 {
        throw copy BalderError ("Compute shader must contain exactly one compute pass");
    }

    for p, c in d[] {        
        let mut sh = ShaderPass ();
        sh.stage = loadStage (p);
        sh.mainFunc = if let Ok (v) = c ["function"].to![c8] ()? { v } else { "main" };
        sh.shaderFile = c ["shader"].to![c8] ();
        
        if sh.stage != VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT {
            throw copy BalderError ("Compute shader always start with a compute pass");
        }
        
        return sh;
    }

    log::error #("ShaderConfigLoader", "??");
    panic;
} catch {    
    err => {
        throw copy BalderError (std::format::format ("Failed to read shader configuration file => \n\t{}", err));
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ==================================          GROUP SIZES          ===================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadGroupSizes (cfg : &Config)-> [u32 ; 3]
    throws BalderError
{
    let dmut result : [u32 ; 3] = [1 ; 3]; 
    if let Ok (d : &Dict) = cfg ["local-groups"]? {        
        for a, k in d[] {                    
            if a == "x" { result [0] = cast!u32 (k.to!{i64} ()); }
            else if a == "y" { result [1] = cast!u32 (k.to!{i64} ()); }
            else if a == "z" { result [2] = cast!u32 (k.to!{i64} ()); }
            else {
                throw copy BalderError ("No group size named : " ~ a);
            }
        }
    }

    else if "local-groups" in cfg {    
        throw copy BalderError ("Group size description must be a dictionnary");    
    }

    result
    
} catch {
    err : &BalderError => { throw err; }
    _ => { throw copy BalderError ("Malformed group size configuration"); }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          DESCRIPTOR SET          =================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadDescriptorSets (cfg : &Config)-> dmut [DescriptorContext => DescriptorSetConfig]
    throws BalderError
{
    let d = if let Ok (d : &Dict) = cfg ["set"]? { d }
    else {
        if "set" in cfg {
            throw copy BalderError ("Descriptor set configuration must be a dictionnary");
        }
        else return copy [];
    };


    let mut i = 0u32;
    let dmut result : [DescriptorContext => DescriptorSetConfig] = copy [];
    for a, k in d[] {
        let context = loadSetContext (a);        
        let mut sub = loadSubSet (k);
        sub.id = i;
        i += 1;
        
        result [context] = sub;
    }
    
    alias result
}

fn loadSubSet (cfg : &Config)-> DescriptorSetConfig
    throws BalderError
{
    let mut result = DescriptorSetConfig ();    
    if let Ok (d : &Dict) = cfg ["uniform"]? {
        result.uniforms = loadUniforms (d);
    }
    
    if let Ok (d : &Dict) = cfg ["buffer"]? {
        result.buffers = loadBuffers (d);
    }
    
    if let Ok (d : &Dict) = cfg ["texture"]? {
        result.textures = loadTextures (d);
    }

    if let Ok (d : &Dict) = cfg ["storage-texture"]? {
        result.storageTextures = loadStorageTextures (d);
    }

    let mut size : [VkDescriptorType] = [];                    
    size ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER         ; result.uniforms.len];                        
    size ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER         ; result.buffers.len];                                    
    size ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER ; result.textures.len];                                    
    size ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_IMAGE          ; result.storageTextures.len];
    
    result.size = size;
    
    result
}

fn loadSetContext (ctx : [c8])-> DescriptorContext
    throws BalderError
{
    for _, name in DescriptorContextNames::__members__ {
        if name._0 == ctx { return name._1 }
    }

    let msg = {
        format ("Unknwon descriptor set context '{}' => {}", ctx , (i._0 for i in DescriptorContextNames::__members__,))
    } catch {
        _ => panic;
    }
    
    throw copy BalderError (msg);   
}

fn loadUniforms (d : &Dict)-> [[c8] => UniformInfo]
    throws BalderError
{
    let dmut uniforms : [[c8] => UniformInfo] = copy [];
    for p, c in d[] {
        let mut un = UniformInfo ();
        un.binding = c ["binding"].to!{u32} ();
        un.size = c ["size"].to!{u64} ();
        un.stage = loadUniformStage ((c ["stage"]?).toOr!{[c8]} ("A"));
        
        uniforms [p] = un;
    }

    uniforms
} catch {
    err => {
        throw copy BalderError ("Malformed uniform configuration " ~ to!{[c8]} (err));
    }
}

fn loadBuffers (d : &Dict)-> [[c8] => BufferInfo]
    throws BalderError
{
    let dmut buffers : [[c8] => BufferInfo] = copy [];
    for p, c in d[] {
        let mut bu = BufferInfo ();
        bu.binding = c ["binding"].to!{u32} ();
        bu.stage = loadUniformStage ((c ["stage"]?).toOr!{[c8]} ("A"));
        
        buffers [p] = bu;
    }

    buffers
} catch {
    err => {
        throw copy BalderError ("Malformed buffer configuration " ~ to!{[c8]} (err));
    }
}

fn loadTextures (d : &Dict)-> [[c8] => TextureInfo]
    throws BalderError
{
    let dmut textures : [[c8] => TextureInfo] = copy [];            
    for p, c in d[] {
        let mut un = TextureInfo ();
        un.binding = c ["binding"].to!{u32} ();
        un.sampler =  if let Ok (v) = c ["sampler"]? { v.to!{u32} () } else { un.binding };
        un.stage = loadUniformStage ((c ["stage"]?).toOr ("A"));
                
        un.magFilter = loadFilter ((c ["mag-filter"]?).toOr (TextureFilter::LINEAR._0));
        un.minFilter = loadFilter ((c ["min-filter"]?).toOr (TextureFilter::LINEAR._0));
        
        un.addressModeU = loadAddressMode (if let Ok (v) = c ["addressModeU"].to![c8] ()? { v } else if let Ok (v) = c ["addressMode"].to![c8] ()? { v } else { TextureAddressMode::REPEAT._0 });
        un.addressModeV = loadAddressMode (if let Ok (v) = c ["addressModeV"].to![c8] ()? { v } else if let Ok (v) = c ["addressMode"].to![c8] ()? { v } else { TextureAddressMode::REPEAT._0 });
        un.addressModeW = loadAddressMode (if let Ok (v) = c ["addressModeW"].to![c8] ()? { v } else if let Ok (v) = c ["addressMode"].to![c8] ()? { v } else { TextureAddressMode::REPEAT._0 });        

        un.anisotropyEnable = (c ["anisotropy"]?).toOr (true);
        un.maxAnisotropy = (c ["max-anisotropy"]?).toOr (16.f);
        
        un.unnormalizedCoordinates = (c ["unnormalizedCoordinates"]?).toOr (false);
        un.compareEnable = (c ["compare"]?).toOr (false);
        
        un.compareOp = loadCompareOp ((c ["compare-op"]?).toOr (TextureCompareOp::ALWAYS._0));
        
        un.mipmapMode = loadMipMapMode ((c ["mipmap"]?).toOr (TextureMipmapMode::NEAR._0));
        un.borderColor = loadBorderColor ((c ["border-color"]?).toOr (TextureBorderColor::FLOAT_OPAQUE_B._0));
        un.kind = loadTextureKind ((c ["kind"]?).toOr (TextureKind::ALBEDO));
        
        textures [p] = un;
    }

    textures
} catch {
    err => {
        throw copy BalderError ("Malformed texture configuration " ~ to!{[c8]} (err));
    }
}

fn loadStorageTextures (d : &Dict)-> [[c8] => StorageTextureInfo]
    throws BalderError
{
    let dmut textures : [[c8] => StorageTextureInfo] = copy [];            
    for p, c in d[] {
        let mut un = StorageTextureInfo ();
        un.binding = c ["binding"].to!{u32} ();        
        un.stage = loadUniformStage ((c ["stage"]?).toOr ("A"));
                
        textures [p] = un;
    }

    textures
} catch {
    err => {
        throw copy BalderError ("Malformed storage texture configuration " ~ to!{[c8]} (err));
    }
}


/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          PUSH CONSTANT          ==================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadPushConstant (cfg : &Config)-> mut PushConstantConfig
    throws BalderError
{
    let d = if let Ok (d : &Dict) = cfg ["push"]? {
        d
    } else {
        if "push" in cfg {
            throw copy BalderError ("Push constant configuration must be a dictionnary");
        }

        return PushConstantConfig()
    };

    {    
        let mut result = PushConstantConfig ();
        for p, c in d[] {
            let mut bu = PushConstantInfo ();
            bu.offset = c ["offset"].to!{u32} ();
            bu.size = c ["size"].to!{u32} ();

            result.set [p] = bu;
            if (result.size < bu.offset + bu.size) {
                result.size = (bu.offset + bu.size);
            }
        }

        alias result
    }  catch {
        err => {
            throw copy BalderError ("Malformed storage texture configuration " ~ to!{[c8]} (err));
        }
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =====================================          COMMON          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn loadStage (stage : [c8])-> VkShaderStageFlagBits
    throws BalderError
{
    for _, name in ShaderStage::__members__ {
        if name._0 == stage { return name._1 }
    }

    let msg = {
        format ("Unknwon shader stage '{}' => {}", stage, (i._0 for i in ShaderStage::__members__,))
    } catch {
        _ => panic;
    };
    
    throw copy BalderError (msg);    
}

fn loadUniformStage (name : [c8])-> VkShaderStageFlags
    throws BalderError
{
    let mut stage : u32 = 0u32;    
    
    for i in 0 .. name.len {
        let mut done = false;
        for _, us in UniformStages::__members__ {
            if us._0 == name [i] {
                stage = stage | cast!u32 (us._1);
                done = true;
                break;
            }
        }

        if !done {
            let msg = {
                format ("Unknwon uniform shader stage '{}' => {}", name [i], (z._0 for z in UniformStages::__members__,))
            } catch {
                _ => panic;
            }
            
            throw copy BalderError (msg); 
        }                
    }

    stage
}

fn loadFilter (name : [c8])-> VkFilter 
    throws BalderError
{
    for _, fil in TextureFilter::__members__ {
        if fil._0 == name { return fil._1; } 
    }
    
    let msg = {
        format ("Unknwon texture filter '{}' => {}", name, (i._0 for i in TextureFilter::__members__,))
    } catch {
        _ => panic;
    }
    
    throw copy BalderError (msg);    
}

fn loadAddressMode (name : [c8])-> VkSamplerAddressMode
    throws BalderError
{
    for _, fil in TextureAddressMode::__members__ {
        if fil._0 == name { return fil._1; } 
    }

    let msg = {
        format ("Unknwon texture address mode '{}' => {}", name, (i._0 for i in TextureAddressMode::__members__,))
    } catch {
        _ => panic;
    }
            
    throw copy BalderError (msg);    
}

fn loadCompareOp (name : [c8])-> VkCompareOp
    throws BalderError
{
    for _, fil in TextureCompareOp::__members__ {
        if fil._0 == name { return fil._1; } 
    }

    let msg = {
        format ("Unknwon texture compare op '{}' => {}", name, (i._0 for i in TextureCompareOp::__members__,))
    } catch {
        _ => panic;
    }
    
    throw copy BalderError (msg);
}

fn loadMipMapMode (name : [c8])-> VkSamplerMipmapMode
    throws BalderError
{
    for _, fil in TextureMipmapMode::__members__ {
        if fil._0 == name { return fil._1; } 
    }

    let msg = {
        format ("Unknwon texture mipmap mode '{}' => {}", name, (i._0 for i in TextureMipmapMode::__members__,))
    } catch {
        _ => panic;        
    }
    
    throw copy BalderError (msg);
}

fn loadBorderColor (name : [c8])-> VkBorderColor
    throws BalderError
{
    for _, fil in TextureBorderColor::__members__ {
        if fil._0 == name { return fil._1; } 
    }

    let msg = {
        format ("Unknwon texture border color '{}' => {}", name, (i._0 for i in TextureBorderColor::__members__,))
    } catch {
        _ => panic;
    }
    
    throw copy BalderError (msg);    
}

fn loadTextureKind (name : [c8])-> TextureKind
    throws BalderError
{
    for _, fil in TextureKind::__members__ {
        if fil == name { return fil; } 
    }

    let msg = {
        format ("Unknwon texture kind '{}' => {}", name, (i for i in TextureKind::__members__,))
    } catch {
        _ => panic;
    }
    
    throw copy BalderError (msg);    
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ======================================          CONV          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

fn toOr {T} (a : &Config?, or : T)-> T
    throws BalderError
{
    if let Ok (z) = a {
        {            
            return std::config::conv::to!{T} (z);
        } catch {
            _ => {
                throw copy BalderError ("Wrong configuration type : " ~ to!{[c8]} (z) ~ " != " ~ T::typeid);
            }
        }
    }

    return or;
} 

