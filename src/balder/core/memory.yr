in memory;

pub mod ::free_list;
pub mod ::segment;
pub mod ::image2D;
pub mod ::buffer;

use balder::core::{_, driver::_, memory::_};
use balder::utils::log;
use vulkan::_;

use std::algorithm::comparison;
use std::io;

/**
 * Memory allocator used to manage the memory of a vulkan device
 */
@final
pub class MemoryAllocator {

    // The device used by the allocator
    let dmut _device : &VulkanDevice;

    // The last uniq id given to a free list
    let mut _lastId = 0us;

    // The allocated memory segments
    let dmut _allocations : [usize => &FreeList] = copy [];

    // The size of a memory segment
    let mut _memorySegmentSize : u64 = 0u64;

    /**
     * @params:
     *   - device: the device used to allocate memory
     */
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
    {
        let dmut properties = VkPhysicalDeviceProperties ();
        let mut memProperties = VkPhysicalDeviceMemoryProperties ();
        vkGetPhysicalDeviceProperties (self._device:.getPhysicalDeviceHandle (), alias &properties);
        vkGetPhysicalDeviceMemoryProperties (self._device:.getPhysicalDeviceHandle (), alias &memProperties);

        let nbAllocations = cast!u64 (min (4096u32, properties.limits.maxMemoryAllocationCount));
        self._memorySegmentSize = memProperties.memoryHeaps [0us].size / nbAllocations;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   GETTERS   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the device used by the allocator
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          BUFFER ALLOCATION          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Allocate a buffer
     * @params:
     *    - size: the size of the buffer to allocate
     *    - bufferUsage: the type of buffer to allocate
     */
    pub fn allocBuffer (mut self, size : u64, bufferUsage : VkBufferUsageFlags, memoryFlags : VkMemoryPropertyFlags)-> dmut &Buffer
        throws BalderError
    {
        let mut isLocal = (memoryFlags & cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) == 1u32);
        isLocal = isLocal || (memoryFlags & cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 1u32);

        let mut bufferInfo = VkBufferCreateInfo ();
        bufferInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = size;
        bufferInfo.usage = bufferUsage;
        bufferInfo.sharingMode = VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;

        let dmut buf : VkBuffer = null;
        if (vkCreateBuffer (self._device:.getDeviceHandle (), &bufferInfo, null, alias &buf) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create buffer.");
        }

        let memAlloc = self:.findSuitableMemoryBuffer (buf, memoryFlags);
        return copy Buffer (alias self, memAlloc, alias buf, isLocal-> isLocal);
    }


    /**
     * Find a suitable free memory segment to bind to the buffer
     * @params:
     *    - buf: the buffer to bind
     *    -
     */
    fn findSuitableMemoryBuffer (mut self, buf : VkBuffer, memoryFlags : VkMemoryPropertyFlags)-> MemoryAllocation
        throws BalderError
    {
        let dmut memReq = VkMemoryRequirements ();
        vkGetBufferMemoryRequirements (self._device:.getDeviceHandle (), buf, alias &memReq);

        let type = self:.findMemoryType (memReq.memoryTypeBits, memoryFlags);
        for _, dmut list in alias self._allocations {
            if let Ok (res) = self:.allocateBufferInList (alias list, type, buf, memReq) {
                return res;
            }
        }

        let allocSize = max (self._memorySegmentSize, memReq.size);
        let dmut mem = self:.allocateNewMemorySegment (type, allocSize);
        if let Ok (res) = self:.allocateBufferInList (alias mem, type, buf, memReq) {
            return res;
        }

        throw copy BalderError ("Failed to allocate memory");
    }

    /**
     * Tries to allocate a segment in the list
     * @params:
     *    - index: the index of the free list in the list of available segments
     *    - list: the list used to try the allocation
     *    - buf: the buffer to bind
     *    - bufferInfo: the buffer creation information
     *    - memReq: the memory requirements of the allocation
     * @returns: the allocated memory segment (or none if failed)
     * */
    fn allocateBufferInList (mut self, dmut list : &FreeList, type : u32,  buf : VkBuffer, memReq : VkMemoryRequirements)-> (MemoryAllocation)?
         throws BalderError
    {
        // Cannot allocate in mismatching allocation type
        if (list.getType () != type) return none;

        let (succ, off, segIndex) = list:.findFreeSegment (memReq.size, memReq.alignment);
        if (succ) {
            list:.reserve (segIndex, off, memReq.size);
            let res = MemoryAllocation (
                type-> type,
                index-> list.getUniqId (),
                offset-> off,
                size-> memReq.size,
                mem-> list:.getMemory ());

            if (vkBindBufferMemory (self._device:.getDeviceHandle (), buf, list:.getMemory (), off) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to bind buffer memory");
            }

            return res?;
        }

        none
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          IMAGE ALLOCATION          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Allocate a 2D image in memory
     * @params:
     *    - width: the width of the image
     *    - height: the height of the image
     *    - imageUsage: the usage of the mmeo
     * */
    pub fn allocImage2D (mut self, width : u32, height : u32, format : VkFormat, tiling : VkImageTiling, usage : VkImageUsageFlags, memoryFlags : VkMemoryPropertyFlags)-> dmut &Image2D
        throws BalderError
    {
        let mut imageInfo = VkImageCreateInfo ();
        imageInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        imageInfo.imageType = VkImageType::VK_IMAGE_TYPE_2D;
        imageInfo.extent.width = width;
        imageInfo.extent.height = height;
        imageInfo.extent.depth = 1;
        imageInfo.mipLevels = 1;
        imageInfo.arrayLayers = 1;
        imageInfo.format = format;
        imageInfo.tiling = tiling;
        imageInfo.initialLayout = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        imageInfo.usage = usage;
        imageInfo.samples = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT;
        imageInfo.sharingMode = VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;

        let dmut image : VkImage = null;
        if vkCreateImage (self._device:.getDeviceHandle (), &imageInfo, null, alias &image) != VkResult::VK_SUCCESS {
            throw copy BalderError ("Failed to create image");
        }

        let memAlloc = self:.findSuitableMemoryImage (image, memoryFlags);
        copy Image2D (width, height, format, alias self, memAlloc, alias image)
    }

    /**
     * Find a suitable free memory segment to bind to the image
     * @params:
     *    - image: the buffer to bind
     *    -
     */
    fn findSuitableMemoryImage (mut self, image : VkImage, memoryFlags : VkMemoryPropertyFlags)-> MemoryAllocation
        throws BalderError
    {
        let dmut memReq = VkMemoryRequirements ();
        vkGetImageMemoryRequirements (self._device:.getDeviceHandle (), image, alias &memReq);

        let type = self:.findMemoryType (memReq.memoryTypeBits, memoryFlags);
        for _, dmut list in alias self._allocations {
            if let Ok (res) = self:.allocateImageInList (alias list, type, image, memReq) {
                return res;
            }
        }

        let allocSize = max (self._memorySegmentSize, memReq.size);
        let dmut mem = self:.allocateNewMemorySegment (type, allocSize);
        if let Ok (res) = self:.allocateImageInList (alias mem, type, image, memReq) {
            return res;
        }

        throw copy BalderError ("Failed to allocate memory");
    }

    /**
     * Tries to allocate a segment in the list
     * @params:
     *    - index: the index of the free list in the list of available segments
     *    - list: the list used to try the allocation
     *    - buf: the buffer to bind
     *    - bufferInfo: the buffer creation information
     *    - memReq: the memory requirements of the allocation
     * @returns: the allocated memory segment (or none if failed)
     * */
    fn allocateImageInList (mut self, dmut list : &FreeList, type : u32,  image : VkImage, memReq : VkMemoryRequirements)-> (MemoryAllocation)?
    throws BalderError
    {
        // Cannot allocate in mismatching allocation type
        if (list.getType () != type) return none;

        let (succ, off, segIndex) = list:.findFreeSegment (memReq.size, memReq.alignment);
        if (succ) {
            list:.reserve (segIndex, off, memReq.size);
            let res = MemoryAllocation (
                type-> type,
                index-> list.getUniqId (),
                offset-> off,
                size-> memReq.size,
                mem-> list:.getMemory ());

            if (vkBindImageMemory (self._device:.getDeviceHandle (), image, list:.getMemory (), off) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to bind buffer memory");
            }

            return res?;
        }

        none
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          NEW MEMORY ALLOCATION          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Allocate a new memory segment
     * @params:
     *    - type: the type of memory to allocate
     *    - size: the size of the memory to allocate
     * @returns: the allocated memory segment
     */
    fn allocateNewMemorySegment (mut self, type : u32, size : u64)-> dmut &FreeList
        throws BalderError
    {
        let mut memInfo = VkMemoryAllocateInfo ();
        memInfo.sType           = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        memInfo.allocationSize  = size;
        memInfo.memoryTypeIndex = type;

        let dmut mem : VkDeviceMemory = null;
        if (vkAllocateMemory (self._device:.getDeviceHandle (), &memInfo, null, alias &mem) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to allocate buffer memory."s8);
        }

        let uid = self._lastId;
        self._lastId += 1;

        let dmut memDesc = copy FreeList (uid, type, alias mem, size);
        self._allocations [uid] = alias memDesc;

        return alias memDesc;
    }

    /**
     * Find a memory type that can be bound to the buffer
     */
    fn findMemoryType (mut self, typeFilter : u32, properties : VkMemoryPropertyFlags)-> u32
        throws BalderError
    {
        let dmut memProperties = VkPhysicalDeviceMemoryProperties ();
        vkGetPhysicalDeviceMemoryProperties (self._device:.getPhysicalDeviceHandle (), alias &memProperties);

        for i in 0u32 .. memProperties.memoryTypeCount {
            if ((typeFilter & (1u32 << i)) != 0u32 && ((memProperties.memoryTypes [i].propertyFlags & properties) != 0u32)) {
                return i;
            }
        }

        throw copy BalderError ("Failed to find suitable memory type."s8);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   CLEANING   ===========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Remove a buffer allocation
     */
    pub fn freeBuffer (mut self, dmut buf : VkBuffer, memAlloc : MemoryAllocation) {
        vkDestroyBuffer (self._device:.getDeviceHandle (), buf, null);

        if let Ok (dmut list) = alias self._allocations [memAlloc.index] {
            list:.free (memAlloc.offset, memAlloc.size);
            if list.isEmpty () {
                vkFreeMemory (self._device:.getDeviceHandle (), list:.getMemory (), null);
                self._allocations:.remove (list.getUniqId ());
                log::debug ("Disposing allocation : ", list.getUniqId ());
            }
        }
    }

    /**
     * Remove an image allocation
     * */
    pub fn freeImage (mut self, dmut buf : VkImage, memAlloc : MemoryAllocation) {
        vkDestroyImage (self._device:.getDeviceHandle (), buf, null);

        if let Ok (dmut list) = alias self._allocations [memAlloc.index] {
            list:.free (memAlloc.offset, memAlloc.size);
            if list.isEmpty () {
                vkFreeMemory (self._device:.getDeviceHandle (), list:.getMemory (), null);
                self._allocations:.remove (list.getUniqId ());
                log::debug ("Disposing allocation : ", list.getUniqId ());
            }
        }
    }

    impl Disposable {
        pub over dispose (mut self) {
            if self._allocations.len != 0 {
                log::debug ("Disposing pending allocators");
            }

            for _, dmut list in alias self._allocations {
                vkFreeMemory (self._device:.getDeviceHandle (), list:.getMemory (), null);
            }

            self._allocations = copy [];
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}
