/**
 * @authors: Emile Cadorel
 */
mod balder::core::application;

import std::fs::_; // File, FsError
import std::config::_; // Config, toml
import std::io;
import std::time::_;

import balder::concurrency::timer;
import balder::core::error;
import balder::core::window;
import balder::core::input;
import balder::core::activity;

import balder::core::vulkan::_;

/**
 * Main part of a Balder application
 * @example:
 * ===
 * // Create an application from toml configuration file
 * // Config path is relative to `${pwd}/res/`
 * with dmut app = Application::new (Path::new ("path/to/config.toml"s8)) {
 *     app:.run (); // start the application with the default activity
 * } // Application is disposable
 * ===
 * @info: application can handle only one window
 */
pub class Application {

    // The window rendering the application 
    let dmut _window = Window::new ();

    // The timer to cap the activity update frequency
    let dmut _timer = Timer::new ();

    // The duration of a step of the application (one update of the activity)
    let mut _stepDuration = dur::millis (16u64) + dur::micros (666u64);
    
    // While _isRunning is true the app is running
    let mut _isRunning : bool = true;
    
    // The list of input manager for each activities
    let dmut _inputs : [&InputManager] = [];

    // The list of activities that controlling the application
    let dmut _activities : [&Activity] = [];


    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    prot self empty () {}
    
    /**
     * Create a new application from a file configuration
     * @params:
     *    - path: the path of the configuration file
     */
    pub self (path : &Path)
        throws &BalderError
    {
        let conf = self.readTomConfig (path);

        self:.configure (conf);
    }    

    prv {
        
        /**
         * Configure the application with a given configuration
         * @params: 
         *    - conf: the configuration of the window
         */
        def configure (mut self, conf : &Config)
            throws &BalderError
        {
            self:.configureWindow (conf);

            let step = (to!i32 (conf["timer"]["ips"])?).getOr (60);
            self._stepDuration = dur::seconds (1) / step;            
        }

        /**
         * Configure the window of the application using the configuration `conf["window"]`
         * @params: 
         *    - conf: the configuration of the application
         */
        def configureWindow (mut self, conf : &Config)
            throws &BalderError
        {
            let winConfO = conf["window"]?;
            let fps = cast!u32 ((to!i32 (conf["timer"]["fps"])?).getOr (60));
            match winConfO {
                Ok (winConf : _) => {
                    self._window:.setDimension ((to!u32 (winConf["width"])?).getOr (1024u32),
                                                (to!u32 (winConf["height"])?).getOr (768u32));
                    
                    self._window:.setName ((config::conv::to![c8] (winConf["name"])?).getOr ("Balder"s8));
                    self._window:.configureVulkan (winConf, fps, resizable-> (config::conv::to!bool (winConf["resizable"])?).getOr (false));
                }
                Err () => {
                    self._window:.setDimension (1024u32, 768u32);
                    self._window:.setName ("Balder"s8);
                    self._window:.configureVulkan (Dict::new (), fps, resizable-> false);
                }
            }
        }

        /**
         * Parse the content of the configuration file and return the configuration
         * @params: 
         *    - path: the path of the configuration file (relative to `${pwd}/res`)
         * @throws:
         *   - &BalderError: 
         *      + the parsing failed 
         *      + the file does not exist
         */
        def readTomConfig (self, path : &Path)-> &Config
            throws &BalderError
        {
            import std::syntax::_; // SyntaxError
            import std::env; // currentDir
            
            let completePath = env::currentDir ().push ("res"s8).push (path);
            let content = with dmut f = File::open (completePath) {
                toml::parse (f:.readAll ())
            } catch {
                _ : &FsError => {
                    throw BalderError::new ("File not found : "s8 ~ completePath.toStr ());
                }
                s : &SyntaxError => {
                    import std::conv;
                    throw BalderError::new ("Configuration format : "s8 ~ s.msg.(std::conv::to)![c8]() ~ ":("s8 ~ s.line.(std::conv::to)![c8] () ~ ","s8 ~ s.col.(std::conv::to)![c8] () ~ ")"s8);
                }
            }

            content
        } 

    }

    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE    ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {
        
        /**
         * Start the application 
         */
        def run (mut self) {
            self._window:.show ();
            self._window:.startRendering ();
            
            while self._isRunning {
                self:.waitClock ();
                self._inputs [$ - 1us]:.pollEvents ();

                self:.callActivity ();
            }

            self._window:.stopRendering ();
        }


        /**
         * Close the application
         */
        def quit (mut self) {
            self._isRunning = false;
        }
        
    }

    
    /**
     * Wait until the next update of the activity should be called.
     * @info: update the clock count.
     */
    prv def waitClock (mut self) {        
        let tick = self._timer.timeSinceStart ();
        let x = instant::now ();
        let r = self._stepDuration - tick - dur::micros (1u64);
        sleep (r);
        self._timer:.reset ((instant::now () - x) - r);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   ACTIVITY    =======================================
     * ======================================================================================================
     * ======================================================================================================
     */
    

    pub {

        /**
         * Open an activity in the application and start it.
         * @info: put the current activity in Pause mode.
         */
        def openActivity {T over &Activity} (mut self) {
            if self._activities.len != 0us
                self._activities [$ - 1us]:.onPause ()?;

            self._inputs = alias (self._inputs ~ [InputManager::new ()]);

            let dmut act : &Activity = T::new (alias self);
            self._activities = alias (self._activities ~ [alias act]);
        }

        /**
         * Open an activity in the application and start it.
         * @info: put the current activity in Pause mode.
         */
        def openActivity {T over &Activity, P...} (mut self, p : P) {
            if self._activities.len != 0us
                self._activities [$ - 1us]:.onPause ()?;

            self._inputs = alias (self._inputs ~ [InputManager::new ()]);
            self._activities = alias (self._activities ~ [alias cast!{&Activity} (T::new (alias self, expand p))]);
        }

        /**
         * Close the current activity
         * @info: resume the previous activity if there was one
         */
        def closeActivity (mut self) {
            {
                if self._activities.len != 0us {
                    self._activities [$ - 1us]:.dispose ();
                    self._activities = self._activities [0us .. $ - 1us];
                    self._inputs = self._inputs [0us .. $ - 1us];
                }
            }

            {
                if self._activities.len == 0us {
                    self._isRunning = false;
                    self._inputs = alias (self._inputs ~ [InputManager::new ()]);
                    self._activities = alias (self._activities ~ [alias cast!{&Activity} (EmptyActivity::new (alias self))]);
                } else {
                    self._activities [$ - 1us]:.onResume ();
                }
            } 
        }
        
    }   
    
    /**
     * Call the activity update and draw routine.
     */
    prv def callActivity (mut self) {
        self._activities[$ - 1us]:.onUpdate ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS    ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    pub {
        
        /**
         * @returns: the input manager of the current activity
         */
        def getInputManager (mut self) -> dmut &InputManager
        {
            alias self._inputs [$ - 1us]
        }

        /**
         * @returns: the input manager of the current activity
         */
        def getInputManager (self) -> &InputManager
        {
            self._inputs [$ - 1us]
        }
        
        /**
         * @returns: the window of the application
         */
        def getWindow (mut self)-> dmut &Window {
            alias self._window
        }

        /**
         * @returns: the window of the application
         */
        def getWindow (self)-> &Window {
            self._window
        }

    }
       
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   DISPOSING    =========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            self._window:.dispose ();
        }        
    }

    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
    
}

