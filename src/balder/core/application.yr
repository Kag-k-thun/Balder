/**
 * @authors: Emile Cadorel
 */
mod balder::core::application;

import std::fs::_; // File, FsError
import std::config::_; // Config, toml
import std::io;

import balder::core::error;
import balder::core::window;

/**
 * Main part of a Balder application
 * @example:
 * ===
 * // Create an application from toml configuration file
 * // Config path is relative to `${pwd}/res/`
 * with dmut app = Application::new (Path::new ("path/to/config.toml"s8)) {
 *     app:.run (); // start the application with the default activity
 * } // Application is disposable
 * ===
 * @info: application can handle only one window
 */
pub class Application {

    // The window rendering the application 
    let dmut _window = Window::new ();

    /**
     * Create a new application from a file configuration
     * @params:
     *    - path: the path of the configuration file
     */
    pub self (path : &Path)
        throws &BalderError
    {
        let conf = self.readTomConfig (path);

        self:.configure (conf);
    }

    /**
     * Start the application 
     */
    pub def run (mut self) {
    }
    
    /**
     * Configure the application with a given configuration
     * @params: 
     *    - conf: the configuration of the window
     */
    prv def configure (mut self, conf : &Config)
        throws &BalderError
    {
        __pragma!fake_throw (&BalderError);
        conf;
    }

    /**
     * Parse the content of the configuration file and return the configuration
     * @params: 
     *    - path: the path of the configuration file (relative to `${pwd}/res`)
     * @throws:
     *   - &BalderError: 
     *      + the parsing failed 
     *      + the file does not exist
     */
    prv def readTomConfig (self, path : &Path)-> &Config
        throws &BalderError
    {
        import std::syntax::_; // SyntaxError
        import std::env; // currentDir
        
        let completePath = env::currentDir ().push ("res"s8).push (path);
        let content = with dmut f = File::open (completePath) {
            toml::parse (f:.readAll ())
        } catch {
            _ : &FsError => {
                throw BalderError::new ("File not found : "s8 ~ completePath.toStr ());
            }
            s : &SyntaxError => {
                import std::conv;
                throw BalderError::new ("Configuration format : "s8 ~ s.msg.(std::conv::to)![c8]() ~ ":("s8 ~ s.line.(std::conv::to)![c8] () ~ ","s8 ~ s.col.(std::conv::to)![c8] () ~ ")"s8);
            }
        }

        content
    } 

    
    impl Disposable {
        pub over dispose (mut self) {
            self._window:.dispose ();
        }        
    }

    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
    
}
