/**
 * @authors: Emile Cadorel
 */
in application;

pub mod ::activity;
pub mod ::input;
pub mod ::window;
pub mod ::timer;

use std::{config::_, fs::_, io, time::_, syntax::_};

use balder::core::{_, application::_};
use balder::core::driver::_;

/**
 * Main part of a Balder application
 * @example:
 * ===
 * // Create an application from toml configuration file
 * // Config path is relative to `${pwd}/res/`
 * let dmut app = copy Application (Path ("path/to/config.toml"));
 * app:.run (); // start the application with the fnault activity
 * app:.dispose (); // Application is disposable
 * ===
 * @info: application can handle only one window
 */
@final
pub class Application {

    // The window rendering the application 
    let dmut _window = copy Window ();

    // The timer to cap the activity update frequency
    let mut _timer = Timer ();

    // The timer between two onUpdate Calls
    let mut _stepTimer = Timer ();

    // The duration of a step of the application (one update of the activity)
    let mut _stepDuration = dur::millis (16u64) + dur::micros (666u64);

    // While _isRunning is true the app is running
    let mut _isRunning : bool = true;
    
    // The list of input manager for each activities
    let dmut _inputs : [&InputManager] = [];

    // The list of activities that controlling the application
    let dmut _activities : [&Activity] = [];

    // The configuration of the application
    let mut _cfg : &BalderConfig;

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    prot self empty ()
        with _cfg = copy BalderConfig::default ()
    {}
    
    /**
     * Create a new application from a file configuration
     * @params:
     *    - path: the path of the configuration file
     */
    pub self (cfg : &BalderConfig)
        with _cfg = cfg
        throws BalderError
    {
        self:.configure ();
    }    

    /**
     * Configure the application with a given configuration
     * @params:
     *    - conf: the configuration of the window
     */
    prv fn configure (mut self)
        throws BalderError
    {
        self:.configureWindow ();
        self._stepDuration = dur::seconds (1) / cast!{u64} (self._cfg.timer.ips);
    }

    /**
     * Configure the window of the application using the configuration `conf["window"]`
     * @params:
     *    - conf: the configuration of the application
     */
    prv fn configureWindow (mut self)
        throws BalderError
    {
        self._window:.setDimension (self._cfg.window.width, self._cfg.window.height);
        self._window:.setName (self._cfg.window.name);
        self._window:.configureVulkan (self._cfg);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE    ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    /**
     * Start the application
     */
    pub fn run (mut self) {
        self._window:.show ();
        self._window:.startRendering ();

        self._timer:.reset ();
        self._stepTimer:.reset ();
        while self._isRunning {
            self:.callActivity ();
            self._inputs [$ - 1us]:.pollEvents ();
            self:.waitClock ();
        }
    }

    /**
     * Close the application
     */
    pub fn quit (mut self) {
        self._isRunning = false;
    }
    
    /**
     * Wait until the next update of the activity should be called.
     * @info: update the clock count.
     */
    prv fn waitClock (mut self) {
        let tick = self._timer.timeSinceStart ();
        if (self._stepDuration > tick - dur::micros (10)) {
            let x = Instant::now ();
            let r = self._stepDuration - tick - dur::micros (10);
            sleep (r);
            let z = (Instant::now () - x) - r;
            self._timer:.reset (z);
        } else {
            let z = tick - self._stepDuration;
            self._timer:.reset (z);
        }
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   ACTIVITY    =======================================
     * ======================================================================================================
     * ======================================================================================================
     */
    

    /**
     * Open an activity in the application and start it.
     * @info: put the current activity in Pause mode.
     */
    pub fn openActivity {T over &Activity} (mut self) {
        if self._activities.len != 0us
            self._activities [$ - 1us]:.onPause ()?;

        let dmut input = copy InputManager ();
        input:.connectResize (&self._window:.onResize);

        self._inputs = alias (self._inputs ~ [alias input]);

        let dmut act : &Activity = copy T (alias self);
        self._activities = alias (self._activities ~ [alias act]);
    }

    /**
     * Open an activity in the application and start it.
     * @info: put the current activity in Pause mode.
     */
    pub fn openActivity {T over &Activity, P...} (mut self, p : P) {
        if self._activities.len != 0us {
            self._activities [$ - 1us]:.onPause ()?;
        }

        let dmut input = copy InputManager ();
        input:.connectResize (&self._window:.onResize);

        self._inputs = alias (self._inputs ~ [alias input]);
        self._activities = alias (self._activities ~ [alias cast!{&Activity} (copy T (alias self, expand p))]);
    }

    /**
     * Close the current activity
     * @info: resume the previous activity if there was one
     */
    pub fn closeActivity (mut self) {
        if self._activities.len != 0us {
            self._window:.killRendering ();
            self._window:.resetComposePass ()?;
            self._activities [$ - 1us]:.dispose ();
            self._activities = alias self._activities [0us .. $ - 1us];
            self._inputs = alias self._inputs [0us .. $ - 1us];
        }

        if self._activities.len == 0us {
            self._isRunning = false;
            self._inputs = copy [copy InputManager ()];
            self._activities = copy [copy EmptyActivity (alias self)];
        } else {
            self._window:.startRendering ();
            self._activities [$ - 1us]:.onResume ();
        }
    }

    /**
     * Call the activity update and draw routine.
     */
    prv fn callActivity (mut self) {
        self._activities[$ - 1us]:.onUpdate (self._stepTimer.timeSinceStart ());
        self._stepTimer:.reset ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS    ========================================
     * ======================================================================================================
     * ======================================================================================================
     */


    /**
     * @returns: the input manager of the current activity
     */
    pub fn getInputManager (mut self) -> dmut &InputManager {
        alias self._inputs [$ - 1us]
    }

    /**
     * @returns: the input manager of the current activity
     */
    pub fn getInputManager (self) -> &InputManager {
        self._inputs [$ - 1us]
    }

    /**
     * @returns: the window of the application
     */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the window of the application
     */
    pub fn getWindow (self)-> &Window {
        self._window
    }

    /**
     * @returns: the configuration of the application
     * */
    pub fn getConfiguration (self)-> &BalderConfig {
        self._cfg
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   DISPOSING    =========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            self._window:.dispose ();
        }        
    }

    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
    
}

