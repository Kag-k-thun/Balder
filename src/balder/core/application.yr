/**
 * @authors: Emile Cadorel
 */
in application;

pub mod ::activity;
pub mod ::input;
pub mod ::window;
pub mod ::timer;

use std::{config::_, fs::_, io, time::_, syntax::_};

use balder::core::{_, application::_};
use balder::core::driver::_;

/**
 * Main part of a Balder application
 * @example:
 * ===
 * // Create an application from toml configuration file
 * // Config path is relative to `${pwd}/res/`
 * let dmut app = copy Application (Path ("path/to/config.toml"));
 * app:.run (); // start the application with the fnault activity
 * app:.dispose (); // Application is disposable
 * ===
 * @info: application can handle only one window
 */
@final
pub class Application {

    // The window rendering the application 
    let dmut _window = copy Window ();

    // The timer to cap the activity update frequency
    let mut _timer = Timer ();

    // The timer between two onUpdate Calls
    let mut _stepTimer = Timer ();

    // The duration of a step of the application (one update of the activity)
    let mut _stepDuration = dur::millis (16u64) + dur::micros (666u64);

    // While _isRunning is true the app is running
    let mut _isRunning : bool = true;
    
    // The list of input manager for each activities
    let dmut _inputs : [&InputManager] = [];

    // The list of activities that controlling the application
    let dmut _activities : [&Activity] = [];


    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    prot self empty () {}
    
    /**
     * Create a new application from a file configuration
     * @params:
     *    - path: the path of the configuration file
     */
    pub self (path : [c8])
        throws BalderError
    {
        let conf = self.readTomlConfig (path);

        self:.configure (conf);
    }    

    /**
     * Configure the application with a given configuration
     * @params:
     *    - conf: the configuration of the window
     */
    prv fn configure (mut self, conf : &Config)
        throws BalderError
    {
        self:.configureWindow (conf);
        let step = if let Ok (Int (value-> f)) =  conf["timer"]["ips"]? { cast!u64 (f) } else { 60 };

        self._stepDuration = dur::seconds (1) / step;
    }

    /**
     * Configure the window of the application using the configuration `conf["window"]`
     * @params:
     *    - conf: the configuration of the application
     */
    prv fn configureWindow (mut self, conf : &Config)
        throws BalderError
    {
        let fps = if let Ok (Int (value-> f)) = conf ["timer"]["fps"]? { cast!u32 (f) } else { 60 };

        if let Ok (winConf) = conf ["window"]? {
            let w = if let Ok (Int (value-> f)) = winConf ["width"]? { cast!u32 (f) } else { 1024 };
            let h = if let Ok (Int (value-> f)) = winConf ["height"]? { cast!u32 (f) } else { 768 };
            let name = if let Ok (Str (value-> s)) = winConf ["name"]? { s } else { "Balder" };
            let resizable = if let Ok (Bool (value-> b)) = winConf ["resizable"]? { b } else { false };

            self._window:.setDimension (w, h);
            self._window:.setName (name);
            self._window:.configureVulkan (winConf, fps, resizable-> resizable);
        } else {
            self._window:.setDimension (1024u32, 768u32);
            self._window:.setName ("Balder");
            self._window:.configureVulkan (copy Dict (), fps, resizable-> false);
        }
    }

    /**
     * Parse the content of the configuration file and return the configuration
     * @params:
     *    - path: the path of the configuration file (relative to `${pwd}/res`)
     * @throws:
     *   - &BalderError:
     *      + the parsing failed
     *      + the file does not exist
     */
    prv fn readTomlConfig (self, path : [c8])-> &Config
        throws BalderError
    {
        let completePath = balder::utils::path::projectPath (path);
        let content = {
            let dmut f = File::open (completePath);
            toml::parse (f:.readAll ())
        } catch {
            _ : &FsError => {
                throw copy BalderError ("File not found : " ~ completePath.toStr ());
            }
            s : &SyntaxError => {
                throw copy BalderError ("Configuration format : " ~ s.msg ~ ":(" ~ std::conv::to!{[c8]} (s.line) ~ "," ~ std::conv::to!{[c8]} (s.col) ~ ")");
            }
        }

        content
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE    ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    /**
     * Start the application
     */
    pub fn run (mut self) {
        self._window:.show ();
        self._window:.startRendering ();

        self._timer:.reset ();
        self._stepTimer:.reset ();
        while self._isRunning {
            self:.callActivity ();
            self._inputs [$ - 1us]:.pollEvents ();
            self:.waitClock ();
        }
    }

    /**
     * Close the application
     */
    pub fn quit (mut self) {
        self._isRunning = false;
    }
    
    /**
     * Wait until the next update of the activity should be called.
     * @info: update the clock count.
     */
    prv fn waitClock (mut self) {
        let tick = self._timer.timeSinceStart ();
        if (self._stepDuration > tick - dur::micros (10)) {
            let x = Instant::now ();
            let r = self._stepDuration - tick - dur::micros (10);
            sleep (r);
            let z = (Instant::now () - x) - r;
            self._timer:.reset (z);
        } else {
            let z = tick - self._stepDuration;
            self._timer:.reset (z);
        }
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   ACTIVITY    =======================================
     * ======================================================================================================
     * ======================================================================================================
     */
    

    /**
     * Open an activity in the application and start it.
     * @info: put the current activity in Pause mode.
     */
    pub fn openActivity {T over &Activity} (mut self) {
        if self._activities.len != 0us
            self._activities [$ - 1us]:.onPause ()?;

        let dmut input = copy InputManager ();
        input:.connectResize (&self._window:.onResize);

        self._inputs = alias (self._inputs ~ [alias input]);

        let dmut act : &Activity = copy T (alias self);
        self._activities = alias (self._activities ~ [alias act]);
    }

    /**
     * Open an activity in the application and start it.
     * @info: put the current activity in Pause mode.
     */
    pub fn openActivity {T over &Activity, P...} (mut self, p : P) {
        if self._activities.len != 0us {
            self._activities [$ - 1us]:.onPause ()?;
        }

        let dmut input = copy InputManager ();
        input:.connectResize (&self._window:.onResize);

        self._inputs = alias (self._inputs ~ [alias input]);
        self._activities = alias (self._activities ~ [alias cast!{&Activity} (copy T (alias self, expand p))]);
    }

    /**
     * Close the current activity
     * @info: resume the previous activity if there was one
     */
    pub fn closeActivity (mut self) {
        if self._activities.len != 0us {
            self._window:.killRendering ();
            self._window:.resetDrawing ()?;
            self._activities [$ - 1us]:.dispose ();
            self._activities = alias self._activities [0us .. $ - 1us];
            self._inputs = alias self._inputs [0us .. $ - 1us];
        }

        if self._activities.len == 0us {
            self._isRunning = false;
            self._inputs = copy [copy InputManager ()];
            self._activities = copy [copy EmptyActivity (alias self)];
        } else {
            self._window:.startRendering ();
            self._activities [$ - 1us]:.onResume ();
        }
    }

    /**
     * Call the activity update and draw routine.
     */
    prv fn callActivity (mut self) {
        self._activities[$ - 1us]:.onUpdate (self._stepTimer.timeSinceStart ());
        self._stepTimer:.reset ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS    ========================================
     * ======================================================================================================
     * ======================================================================================================
     */


    /**
     * @returns: the input manager of the current activity
     */
    pub fn getInputManager (mut self) -> dmut &InputManager {
        alias self._inputs [$ - 1us]
    }

    /**
     * @returns: the input manager of the current activity
     */
    pub fn getInputManager (self) -> &InputManager {
        self._inputs [$ - 1us]
    }

    /**
     * @returns: the window of the application
     */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the window of the application
     */
    pub fn getWindow (self)-> &Window {
        self._window
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   DISPOSING    =========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            self._window:.dispose ();
        }        
    }

    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
    
}

