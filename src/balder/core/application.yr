/**
 * @authors: Emile Cadorel
 */
in application;

pub mod ::activity;
pub mod ::input;
pub mod ::window;
pub mod ::timer;
pub mod ::refcount;
pub mod ::bin;

mod ::pass;

use std::{config::_,
          fs::_,
          io,
          time::_,
          syntax::_,
          concurrency::signal};

use balder::core::{_, application::_};
use balder::core::driver::_;

/**
 * Main part of a Balder application
 * @example:
 * ===
 * // Create an application from toml configuration file
 * // Config path is relative to `${pwd}/res/`
 * let dmut app = copy Application (Path ("path/to/config.toml"));
 * app:.run (); // start the application with the fnault activity
 * app:.dispose (); // Application is disposable
 * ===
 * @info: application can handle only one window
 */
@final
pub class Application {

    // The timer to cap the activity update frequency
    let mut _timer = Timer ();

    // The timer between two onUpdate Calls
    let mut _stepTimer = Timer ();

    // The duration of a step of the application (one update of the activity)
    let mut _stepDuration = dur::millis (16u64) + dur::micros (666u64);

    // While _isRunning is true the app is running
    let mut _isRunning : bool = true;
    
    // The list of input manager for each activities
    let dmut _input : &InputManager = copy InputManager ();

    prot { // activities

        // The list of activities that controlling the application
        let dmut _running : [usize => (&Activity, &Window)] = copy [];

        // The list of activity opened but not started
        let dmut _opened : [usize => (&Activity, &Window)] = copy [];

        // The list of activities to close (in running)
        let dmut _closed : [usize => ()] = copy [];

        // The uid of the last open activity
        let mut _lastActId : usize = 0us;

    }

    prot { // Signals

        // Signal emitted each UI frame
        let dmut _uiTick = Signal!{Duration} ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create a new application
     * @params:
     *    - ips: the duration of a step between activity updates
     */
    pub self (ips : u64 = 144) {
        self._stepDuration = dur::seconds (1) / ips;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          OPEN ACTIVITY          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Open a new activity
     * @params:
     *    - cfg: the configuration of the window
     * */
    pub fn open {T over &Activity} (mut self, cfg : &BalderConfig)-> dmut T
        throws BalderError
    {
        atomic self {
            self._lastActId += 1;
            let uid = self._lastActId;

            let dmut win = self:.openWindow (cfg);
            let dmut act = copy T (uid, alias self, alias win);
            self._opened [uid] = (alias act, alias win);

            alias act
        }
    }

    /**
     * Close a running activity
     * */
    pub fn close (mut self, dmut t : &Activity) {
        atomic self {
            self._closed [t.uid] = ();
        }
    }

    /**
     * Configure the application with a given configuration
     * @params:
     *    - conf: the configuration of the window
     */
    fn openWindow (mut self, cfg : &BalderConfig)-> dmut &Window
        throws BalderError
    {
        let dmut win = copy Window (alias self);

        win:.setDimension (cfg.window.width, cfg.window.height);
        win:.setName (cfg.window.name);
        win:.configureVulkan (cfg);

        win:.configureInputEvents ();

        alias win
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE    ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    /**
     * Start the application
     */
    pub fn run (mut self) {
        self._timer:.reset ();
        self._stepTimer:.reset ();
        self._input:.pollEvents ();

        while self._isRunning {
            self:.performActivityOpening ();

            let delta = self._stepTimer.timeSinceStart ();
            self._stepTimer:.reset ();

            // No need for atomic, this collection cannot be changed within this call
            for _, dmut w in alias self._running {
                w._0:.onUpdate (delta);
            }

            self._uiTick.emit (delta);

            self._input:.pollEvents ();
            self:.performActivityClose ();
            self:.waitClock ();
        }

        self:.dispose ();
    }

    /**
     * Open the activity opened in previous iteration
     * */
    fn performActivityOpening (mut self) {
        if self._opened.len != 0 {
            let dmut toOpen = atomic self {
                let dmut res = alias self._opened;
                self._opened = copy [];
                alias res
            };

            for _, dmut t in alias toOpen {
                let (dmut a, dmut w) = alias t;
                a:.onStart ();
                w:.show ();

                // No need for atomic, this is only called in run iteration
                self._running [a.uid] = alias t;
            }
        }
    }

    /**
     * Close the activities that are marked to be closed
     * */
    fn performActivityClose (mut self) {
        if self._closed.len != 0 {
            let toClose = atomic self {
                let res = self._closed;
                self._closed = copy [];
                res
            };

            for uid in toClose {
                if let Ok ((dmut act, dmut win)) = alias self._running [uid] {
                    act:.onClose ();
                    act:.dispose ();
                    win:.dispose ();

                    // No need for atomic, this is only called in run iteration
                    self._running:.remove (uid);
                }
            }

            // Quit when no activity are left
            if self._running.len == 0us {
                self:.quit ();
            }
        }
    }

    /**
     * Close the application
     */
    pub fn quit (mut self) {
        self._isRunning = false;
    }
    
    /**
     * Wait until the next update of the activity should be called.
     * @info: update the clock count.
     */
    prv fn waitClock (mut self) {
        let tick = self._timer.timeSinceStart ();
        if (self._stepDuration > tick) {
            let x = Instant::now ();
            let r = self._stepDuration - tick - dur::micros (1);

            sleep (r);
            let z = (Instant::now () - x) - r;
            self._timer:.reset (z);
        } else {
            let z = tick - self._stepDuration;
            self._timer:.reset (z);
        }
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS    ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the input manager of the current activity
     */
    pub fn getInputManager (mut self) -> dmut &InputManager {
        alias self._input
    }

    /**
     * @returns: the input manager of the current activity
     */
    pub fn getInputManager (self) -> &InputManager {
        self._input
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SIGNALS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect to the signal that is emitted when a new UI frame is being computed
     * @info: an UI frame is executed at a given frequency (defined by 'ips') to poll input events, and updating main activity
     * */
    pub fn connectUITick (mut self, f : dg (Duration)-> void) {
        self._uiTick:.connect (f);
    }

    /**
     * Disconnect to the signal that is emitted when a new UI frame is being computed
     * */
    pub fn disconnectUITick (mut self, f : dg (Duration)-> void) {
        self._uiTick:.disconnect (f);
    }


    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   DISPOSING    =========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            for _, dmut w in alias self._opened {
                w._0:.dispose ();
                w._1:.dispose ();
            }

            for _, dmut w in alias self._running {
                w._0:.dispose ();
                w._1:.dispose ();
            }

            self._opened = copy [];
            self._running = copy [];
            self._closed = copy [];
        }        
    }

    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
    
}

