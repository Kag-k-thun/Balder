in image2D;

use balder::core::{memory, memory::_, driver::device};
use balder::core::{error, dispose};
use balder::utils::log;

use vulkan::_;

extern (C) fn memcpy (src : *void, dst : *void, size : usize);

__version DEBUG {
    lazy dmut __UID__ = copy [0us];
}

@final
pub class Image2D {

    // The device on which the buffer is allocated
    let dmut _device : &VulkanDevice;

    // The allocator used to allocate the buffer memory
    let dmut _allocator : &MemoryAllocator;

    // The buffer handle
    let dmut _image : VkImage = null;

    // The size of the allocation
    let dmut _size : VkDeviceSize = 0u64;

    // The memory allocation of the buffer (description used by MemoryAllocator)
    let dmut _memAlloc : MemoryAllocation;

    // The width of the allocated buffer
    let mut _width : u32;

    // The height of the allocated buffer
    let mut _height : u32;

    // The format of the image
    let _format : VkFormat;


    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create a buffer using a device
     * @params:
     *    - device: the device used for the allocation
     *    - size: the size of the allocation
     *    - usage: the usage of the memory that will be allocated
     */
    pub self (width : u32, height : u32, format : VkFormat, dmut alloc : &MemoryAllocator, memAlloc : MemoryAllocation, dmut image : VkImage)
        with  _allocator = alias alloc
        , _width = width
        , _height = height
        , _format = format
        , _device = alloc:.getDevice ()
        , _size = memAlloc.size
        , _image = alias image
        , _memAlloc = memAlloc
    {}

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the handle on the vulkan buffer
     */
    pub fn getVulkanImage (mut self)-> dmut VkImage {
        alias self._image
    }

    /**
     * @returns: the device responsible of the allocation of the buffer
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the size of the buffer in memory
     */
    pub fn getSize (self)-> VkDeviceSize {
        self._size
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SET DATA          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the buffer from CPU datas
     */
    pub fn update {T of [U], U} (mut self, datas : T, aspect : VkImageAspectFlags = VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT)
        throws BalderError
    {
        let dmut stagingBuf = self._device:.getMemoryAllocator ():.allocBuffer (
            self._size,
            cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT),
            cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
                      VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT));

        stagingBuf:.map ();
        memcpy (stagingBuf._mappedData, cast!{*void} (datas.ptr), datas.len * U::size);
        stagingBuf:.unmap ();

        self:.copyFrom (alias stagingBuf, aspect);
        stagingBuf:.dispose ();
    }

    /**
     * Update the buffer from CPU datas
     */
    pub fn update {T} (mut self, datas : T)
        throws BalderError
    {
        let d = copy [datas];
        self:.update (d);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          STAGING BUFFER          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Copy the buffer 'src' into the self buffer
     * @params:
     *    - src: the buffer to copy from
     */
    prv fn copyFrom (mut self, dmut src : &Buffer, aspect : VkImageAspectFlags) {
        let dmut cmd = self._device:.beginSingleTimeCommand ();
        let mut copyRegion = VkBufferImageCopy ();

        copyRegion.imageSubresource.aspectMask = aspect;
        copyRegion.imageSubresource.mipLevel = 0u64;
        copyRegion.imageSubresource.layerCount = 1;
        copyRegion.imageExtent.width = self._width;
        copyRegion.imageExtent.height = self._height;
        copyRegion.imageExtent.depth = 1;

        vkCmdCopyBufferToImage (cmd, src:.getVulkanBuffer (), self._image, VkImageLayout::VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1u32, &copyRegion);
        self._device:.endSingleTimeCommand (alias cmd);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==============================================   DISPOSING  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            if (self._image != null) {
                self._allocator:.freeImage (alias self._image, self._memAlloc);

                self._image = null;
                self._size = 0u64;
                self._width = 0;
                self._height = 0;
            }
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}
