in image2D;

use balder::core::{memory, memory::_, driver::device};
use balder::core::{error, dispose};
use balder::utils::log;

use ::vulkan::core;
use std::io;

extern (C) fn memcpy (src : *void, dst : *void, size : usize);

__version DEBUG {
    lazy dmut __UID__ = copy [0us];
}

@final
pub class Image2D {

    // The device on which the buffer is allocated
    let dmut _device : &VulkanDevice;

    // The allocator used to allocate the buffer memory
    let dmut _allocator : &MemoryAllocator;

    // The buffer handle
    let dmut _image : VkImage = null;

    // The memory allocation of the buffer (description used by MemoryAllocator)
    let dmut _memAlloc : MemoryAllocation;

    // The width of the allocated buffer
    let mut _width : u32;

    // The height of the allocated buffer
    let mut _height : u32;

    // The format of the image
    let _format : VkFormat;

    prot { // information about image memory access stage
        let mut _currentLayout : VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
        let mut _currentAccess : u32 = 0;
        let mut _currentStage : u32 = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * Create a buffer using a device
     * @params:
     *    - device: the device used for the allocation
     *    - size: the size of the allocation
     *    - usage: the usage of the memory that will be allocated
     */
    pub self (width : u32, height : u32, format : VkFormat, dmut alloc : &MemoryAllocator, memAlloc : MemoryAllocation, dmut image : VkImage)
        with  _allocator = alias alloc
        , _width = width
        , _height = height
        , _format = format
        , _device = alloc:.getDevice ()
        , _image = alias image
        , _memAlloc = memAlloc        
    {}
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: the handle on the vulkan buffer
     */
    pub fn getVulkanImage (self)-> VkImage {
        self._image
    }

    /**
     * @returns: the device responsible of the allocation of the buffer
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the size of the buffer in memory
     */
    pub fn getSize (self)-> usize {
        self._memAlloc.size
    }

    /**
     * @returns: the format of the image
     * */
    pub fn getFormat (self)-> VkFormat {
        self._format
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          SET FROM BUFFER          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Copy the buffer 'src' into the self buffer
     * @params:
     *    - src: the buffer to copy from
     */
    pub fn copyFrom (mut self, cmd : VkCommandBuffer, dmut src : &Buffer, aspect : VkImageAspectFlags) {                            
        self:.transitionToTransfer (cmd, aspect);            
        
        let mut copyRegion = VkBufferImageCopy ();                
        copyRegion.imageSubresource.aspectMask = aspect;
        copyRegion.imageSubresource.mipLevel = 0u64;
        copyRegion.imageSubresource.layerCount = 1;
        copyRegion.imageExtent.width = self._width;
        copyRegion.imageExtent.height = self._height;
        copyRegion.imageExtent.depth = 1;
        
        vkCmdCopyBufferToImage (cmd,
                                src.getVulkanBuffer (),
                                self._image,
                                VkImageLayout::VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                1u32, &copyRegion);
            
        self:.transitionToRead (cmd, aspect);                            
    }

    /**
     * Transition the image to be used to write content in the texture from a copy transfer
     * */
    pub fn transitionToTransfer (mut self, cmd : VkCommandBuffer, aspect : VkImageAspectFlags) {                
        let mut barrier = VkImageMemoryBarrier ();
        barrier.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        barrier.oldLayout = self._currentLayout;
        barrier.newLayout = VkImageLayout::VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        
        barrier.image = alias self._image;
        barrier.subresourceRange.aspectMask = aspect;
        barrier.subresourceRange.baseMipLevel = 0;
        barrier.subresourceRange.levelCount = 1;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = 1;

        barrier.srcAccessMask = self._currentAccess;
        barrier.dstAccessMask = VkAccessFlagBits::VK_ACCESS_TRANSFER_WRITE_BIT;

        let oldStage = self._currentStage;
        self._currentAccess = barrier.dstAccessMask;
        self._currentLayout = barrier.newLayout;
        self._currentStage = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFER_BIT;
        
        vkCmdPipelineBarrier (cmd,
                              oldStage,
                              self._currentStage,
                              0, 0,
                              null,
                              0,
                              null,
                              1,
                              &barrier);
    }

    /**
     * Transition the image to be used to read content in the texture
     * */
    pub fn transitionToRead (mut self, cmd : VkCommandBuffer, aspect : VkImageAspectFlags) {                
        let mut barrier = VkImageMemoryBarrier ();
            
        barrier.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        barrier.oldLayout = self._currentLayout;
        barrier.newLayout = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        
        barrier.image = alias self._image;
        barrier.subresourceRange.aspectMask = aspect;
        barrier.subresourceRange.baseMipLevel = 0;
        barrier.subresourceRange.levelCount = 1;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = 1;

        barrier.srcAccessMask = self._currentAccess;
        barrier.dstAccessMask = VkAccessFlagBits::VK_ACCESS_SHADER_READ_BIT;

        let oldStage = self._currentStage;
        self._currentAccess = barrier.dstAccessMask;
        self._currentLayout = barrier.newLayout;
        self._currentStage = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
        
        vkCmdPipelineBarrier (cmd,                              
                              oldStage,
                              self._currentStage,
                              0, 0,
                              null,
                              0,
                              null,
                              1,
                              &barrier);                
    }
    
    /**
     * Transition to the image to be writable from a compute shader
     * */
    pub fn transitionToWrite (mut self, cmd : VkCommandBuffer, aspect : VkImageAspectFlags) {                
        let mut barrier = VkImageMemoryBarrier ();
        barrier.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        barrier.oldLayout = self._currentLayout;
        barrier.newLayout = VkImageLayout::VK_IMAGE_LAYOUT_GENERAL;
        
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        
        barrier.image = alias self._image;
        barrier.subresourceRange.aspectMask = aspect;
        barrier.subresourceRange.baseMipLevel = 0;
        barrier.subresourceRange.levelCount = 1;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = 1;

        barrier.srcAccessMask = self._currentAccess;
        barrier.dstAccessMask = VkAccessFlagBits::VK_ACCESS_SHADER_WRITE_BIT;

        let oldStage = self._currentStage;
        self._currentAccess = barrier.dstAccessMask;
        self._currentLayout = barrier.newLayout;
        self._currentStage = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
        
        vkCmdPipelineBarrier (cmd,
                              oldStage,
                              self._currentStage,
                              0, 0,
                              null,
                              0,
                              null,
                              1,
                              &barrier);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==============================================   DISPOSING  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            if (self._image != null) {
                self._allocator:.freeImage (alias self._image, self._memAlloc);
                
                
                self._image = null;
                self._width = 0;
                self._height = 0;
            }
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}
