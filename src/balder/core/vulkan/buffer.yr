mod balder::core::vulkan::buffer;

import balder::core::vulkan::device;
import balder::core::error;
import vulkan::_;


pub class Buffer {

    // The device on which the buffer is allocated
    let dmut _device : &VulkanDevice;
    
    // The buffer handle
    let dmut _buffer : VkBuffer = null;

    // The allocation of the buffer from VMA
    let dmut _alloc : VmaAllocation = null;

    // The size of the allocation
    let dmut _size : VkDeviceSize = 0u64;

    // The memory associated to the buffer
    let dmut _memory : VkDeviceMemory = null;

    // True iif the buffer is mapped to a CPU pointer
    let mut _mapped : bool = false;

    // If self._mapped, this pointer can be used to get or modified the content of the buffer
    let dmut _mappedData : &u8 = null;

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * Create a buffer using a device
     * @params:
     *    - device: the device used for the allocation
     *    - size: the size of the allocation
     *    - usage: the usage of the memory that will be allocated
     *    - flags: the flags to pass to VMA during allocation
     */
    pub self (dmut device : &VulkanDevice, size : VkDeviceSize, bufferUsage : VkBufferUsageFlags, memoryUsage : VmaMemoryUsage, flags : VmaAllocationCreateFlags)        
        with _device = alias device, _size = size
        throws &BalderError
    {
        let useFlags = flags & cast!u32 (~VmaAllocationCreateFlagBits::VMA_ALLOCATION_CREATE_MAPPED_BIT);



        let fam = device.getPhysicalDeviceFamilyIndices ();
        let bufferInfo = if (fam.len >= 2us) {
            VkBufferCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
                usage-> bufferUsage,
                size-> size,
                sharingMode-> VkSharingMode::VK_SHARING_MODE_CONCURRENT,
                queueFamilyIndexCount-> cast!u32 (fam.len),
                pQueueFamilyIndices-> fam.ptr
            )
        } else {
            VkBufferCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
                usage-> bufferUsage,
                size-> size
            )
        };

        let memInfo = VmaAllocationCreateInfo (
            flags-> useFlags,
            usage-> memoryUsage
            );

        let mut allocInfo = VmaAllocationInfo ();
        
        if (vmaCreateBuffer (self._device:.getVmaAllocator (), &bufferInfo, &memInfo, alias &self._buffer, alias &self._alloc, alias &allocInfo) != VkResult::VK_SUCCESS) {
            throw BalderError::new ("Failed to allocate buffer"s8);
        }
        
        self._memory = alias allocInfo.deviceMemory;
    }


    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * @returns: the handle on the vma allocation
         */
        def getVmaAllocation (mut self)-> dmut VmaAllocation {
            alias self._alloc
        }

        /**
         * @returns: the handle on the vulkan buffer
         */
        def getVulkanBuffer (mut self)-> dmut VkBuffer {
            alias self._buffer
        }

        /**
         * @returns: the handle of the memory segment allocated for the buffer
         */
        def getVulkanMemory (mut self)-> VkDeviceMemory {
            alias self._memory
        }
        
        /**
         * @returns: the device responsible of the allocation of the buffer
         */
        def getDevice (mut self)-> dmut &VulkanDevice {
            alias self._device
        }

        /**
         * @returns: the size of the buffer in memory
         */
        def getSize (self)-> VkDeviceSize {
            self._size
        }
        
        /**
         * @returns: the pointer to the mapped addr, null if the buffer is not mapped
         */
        def getMapAddress (mut self)-> dmut &u8 {
            alias self._mappedData
        }

        /**
         * @returns: true if the buffer is mapped into CPU memory
         */
        def isMapped (self)-> bool {
            self._mappedData !is null
        }
        
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * Flush the buffer allocation, to syncronize it with the GPU buffer
         * @assume: the buffer was not disposed
         */
        def flush (mut self) {
            vmaFlushAllocation (self._device:.getVmaAllocator (), alias self._alloc, 0u64, self._size);
        }

        /**
         * Map the buffer onto CPU memory , so it can be updated
         * @assume: the buffer was not disposed
         */
        def map (mut self)-> VkResult {
            if (self._mappedData is null) {
                let dmut m : &void = null;
                let r = vmaMapMemory (self._device:.getVmaAllocator (), alias self._alloc, alias &m);
                if (r == VkResult::VK_SUCCESS) {
                    self._mappedData = alias (cast!{&u8} (m));
                }
                
                r
            } else VkResult::VK_SUCCESS
        }

        /**
         * Unmap the buffer from CPU memory
         */
        def unmap (mut self) {
            if (self._mappedData !is null) {
                vmaUnmapMemory (self._device:.getVmaAllocator (), alias self._alloc);
                self._mappedData = null;
            }
        }

    }
        

    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==============================================   DISPOSING  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */


    impl Disposable {

        pub over dispose (mut self) {
            if (self._alloc !is null) {
                self:.unmap ();

                vmaDestroyBuffer (self._device:.getVmaAllocator (), alias self._buffer, alias self._alloc);
                self._alloc = null;
                self._buffer = null;
                self._memory = null;
                self._size = 0u64;
            }
        }
        
    }
        
    __dtor (mut self) {
        self:.dispose ();
    }
    
    
}
    
