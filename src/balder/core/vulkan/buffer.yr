mod balder::core::vulkan::buffer;

import balder::core::vulkan::device;
import balder::core::vulkan::mem_alloc;
import balder::core::error;
import vulkan::_;

extern (C) def memcpy (src : &void, dst : &void, size : usize);

pub class Buffer {

    // The device on which the buffer is allocated
    let dmut _device : &VulkanDevice;

    // The allocator used to allocate the buffer memory
    let dmut _allocator : &MemoryAllocator;
    
    // The buffer handle
    let dmut _buffer : VkBuffer = null;
    
    // The size of the allocation
    let dmut _size : VkDeviceSize = 0u64;

    // The memory allocation of the buffer (description used by MemoryAllocator)
    let dmut _memAlloc : MemoryAllocation;
    
    // The descriptor of the buffer
    let dmut _descriptor : VkDescriptorBufferInfo = VkDescriptorBufferInfo ();

    // True iif the buffer is mapped to a CPU pointer
    let mut _mapped : bool = false;

    // If self._mapped, this pointer can be used to get or modified the content of the buffer
    let dmut _mappedData : &void = null;

    // True if the buffer is local to host 
    let _isLocal : bool;

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * Create a buffer using a device
     * @params:
     *    - device: the device used for the allocation
     *    - size: the size of the allocation
     *    - usage: the usage of the memory that will be allocated
     */
    pub self (dmut alloc : &MemoryAllocator, memAlloc : MemoryAllocation, dmut buffer : VkBuffer, isLocal : bool)        
        with  _allocator = alias alloc, _device = alloc:.getDevice (),
    _size = memAlloc.size,
    _buffer = alias buffer,
    _memAlloc = memAlloc,
    _descriptor = VkDescriptorBufferInfo (
        buffer-> buffer,
        offset-> 0u64,
        range-> memAlloc.size
        ),
    _isLocal = isLocal
    {}

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   GETTERS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * @returns: the handle on the vulkan buffer
         */
        def getVulkanBuffer (mut self)-> dmut VkBuffer {
            alias self._buffer
        }
        
        /**
         * @returns: the device responsible of the allocation of the buffer
         */
        def getDevice (mut self)-> dmut &VulkanDevice {
            alias self._device
        }

        /**
         * @returns: the size of the buffer in memory
         */
        def getSize (self)-> VkDeviceSize {
            self._size
        }
        
        /**
         * @returns: the pointer to the mapped addr, null if the buffer is not mapped
         */
        def getMapAddress (mut self)-> dmut &void {
            alias self._mappedData
        }

        /**
         * @returns: true if the buffer is mapped into CPU memory
         */
        def isMapped (self)-> bool {
            self._mappedData !is null
        }

        /**
         * @returns: the address of the descriptor buffer info
         */
        def getDescriptorInfo (mut self)-> dmut &VkDescriptorBufferInfo {
            alias &self._descriptor
        }        
        
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ================================================   USAGE  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * Map the buffer onto CPU memory , so it can be updated
         * @assume: the buffer was not disposed
         */
        def map (mut self)-> VkResult {
            if (self._mappedData is null) {
                vkMapMemory (self._device:.getDeviceHandle (),
                             self._memAlloc.mem,
                             self._memAlloc.offset,
                             self._memAlloc.size,
                             0u32,
                             alias &(self._mappedData))
            } else {
                VkResult::VK_SUCCESS
            }
        }

        /**
         * Unmap the buffer from CPU memory
         */
        def unmap (mut self) {
            if (self._mappedData !is null) {
                vkUnmapMemory (self._device:.getDeviceHandle (), self._memAlloc.mem);
                self._mappedData = null;
            }
        }

        /**
         * Update the buffer from CPU datas
         */
        def update {T of [U], U} (mut self, datas : T)
            throws &BalderError
        {
            if (self._isLocal) {
                self:.map  ();
                memcpy (self._mappedData, cast!{&void} (datas.ptr), datas.len * sizeof (U));
                self:.unmap ();
            } else {
                let dmut stagingBuf = self._device:.getMemoryAllocator ():.allocBuffer (
                    self._size,
                    cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT),
                    cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
                              VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT));

                stagingBuf:.update (datas);
                self:.copyFrom (alias stagingBuf);
                stagingBuf:.dispose ();
            }
        }

        /**
         * Update the buffer from CPU datas
         */
        def update {T} (mut self, datas : T)
            throws &BalderError
        {
            let d = [datas ; 1u32];
            self:.update (d[]);            
        }
        
    }
    
    prv {
        
        /**
         * Copy the buffer 'src' into the self buffer
         * @params:
         *    - src: the buffer to copy from
         */
        def copyFrom (mut self, dmut src : &Buffer) {
            let dmut cmd = self._device:.beginSingleTimeCommand ();
            let copyRegion = VkBufferCopy (
                srcOffset-> 0u64,
                dstOffset-> 0u64,
                size-> self._size                
                );

            vkCmdCopyBuffer (cmd, src._buffer, self._buffer, 1u32, &copyRegion);            
            self._device:.endSingleTimeCommand (alias cmd);
        }
        
    }
        

    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==============================================   DISPOSING  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */


    impl Disposable {

        pub over dispose (mut self) {
            if (self._buffer !is null) {
                self:.unmap ();
                self._allocator:.free (alias self._buffer, self._memAlloc);
                
                self._buffer = null;
                self._size = 0u64;
            }
        }
        
    }
        
    __dtor (mut self) {
        self:.dispose ();
    }
    
    
}
    
