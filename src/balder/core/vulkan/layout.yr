mod balder::core::vulkan::layout;

import balder::core::vulkan::device;
import balder::core::error;
import balder::math::vector;

import vulkan::_;

/**
 * Ancestor of all pipeline layout classes
 */
pub class @abstract PipelineLayout {

    // The pipeline layout for vulkan shader
    let dmut _layout : VkPipelineLayout = null;

    // The descriptor set layout describing the uniform values that can be bound to the shader
    let dmut _descriptorSetLayout : VkDescriptorSetLayout = null;

    // The device containing the pipeline layout
    let dmut _device : &VulkanDevice ;
    
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
    {}

    /**
     * @returns: the vulkan handle of the pipeline layout
     */
    pub def getVulkanHandle (mut self)-> dmut VkPipelineLayout {
        alias self._layout
    }

    /**
     * @returns: the descriptor set layout usable for descriptor set allocation
     */
    pub def getDescriptorSetLayout (mut self)-> dmut VkDescriptorSetLayout {
        alias self._descriptorSetLayout
    }
    
    /**
     * @returns: the device used by the pipeline layout
     */
    pub def getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }
    
    impl Disposable {
        pub over dispose (mut self) {
            if (self._descriptorSetLayout !is null) {
                vkDestroyDescriptorSetLayout (self._device:.getDeviceHandle (), self._descriptorSetLayout, null);
                self._descriptorSetLayout = null;
            }

            if (self._layout !is null) {
                vkDestroyPipelineLayout (self._device:.getDeviceHandle (), self._layout, null);
                self._layout = null;
            }
        }        
    }
    
    __dtor (mut self) {
        self:.dispose ();
    }

    
}


/**
 * A pipeline layout describing a shader content
 * @params: 
 *    - T: the struct defining the content of a shader
 */
pub class PipelineLayout {struct T} over PipelineLayout {

    /**
     * @params: 
     *    - device: the device allocating the pipelinelayout 
     */
    pub self (dmut device : &VulkanDevice)
        with super (alias device)
        throws &BalderError
    {
        self._descriptorSetLayout = self:.createDescriptorSetLayout ();
        self._layout = self:.createPipelineLayout ();
    }
    
    /**
     * Create the descriptor set layout for the given T template struct
     * @returns: the descriptor set layout
     */
    prv def createDescriptorSetLayout (mut self)-> dmut VkDescriptorSetLayout
        throws &BalderError
    {
        let dmut res = [VkDescriptorSetLayoutBinding () ; new (__pragma!field_offsets (T)).len];
        cte for i in 0us .. (__pragma!field_offsets (T)).len {            
            res [i] = VkDescriptorSetLayoutBinding (
                descriptorCount-> 1u32,                
                descriptorType-> getDescriptorType!{__pragma!field_type (T, (__pragma!field_names (T))[i])} (),
                stageFlags-> getDescriptorStage ((__pragma!field_names(T))[i]),
                pImmutableSamplers-> null,
                binding-> cast!u32 (i)
            );
        }

        let layoutInfo = VkDescriptorSetLayoutCreateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            bindingCount-> cast!u32 (res.len),
            pBindings-> res.ptr
        );

        let dmut descSet : VkDescriptorSetLayout = null;
        if (vkCreateDescriptorSetLayout (self._device:.getDeviceHandle (), &layoutInfo, null, alias &descSet) != VkResult::VK_SUCCESS) {
            throw BalderError::new ("Failed to create descriptor set layout"s8);
        }

        return alias descSet;
    }

    /**
     * Create the pipeline layout from self._descriptorSetLayout
     */
    prv def createPipelineLayout (mut self)-> dmut VkPipelineLayout
        throws &BalderError
    {
        let dmut layout : VkPipelineLayout = null;
        let pipelineLayoutInfo = VkPipelineLayoutCreateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            setLayoutCount-> 1u32,
            pSetLayouts-> &self._descriptorSetLayout,
            pushConstantRangeCount-> 0u32,
            pPushConstantRanges-> null
        );


        if (vkCreatePipelineLayout (self._device:.getDeviceHandle (), &pipelineLayoutInfo, null, alias &layout) != VkResult::VK_SUCCESS) {
            throw BalderError::new ("Failed to create pipeline layout."s8);
        }

        return alias layout;
    }
        
}


/**
 * ======================================================================================================
 * ======================================================================================================
 * =======================================   GET DESCRIPTOR TYPES   =====================================
 * ======================================================================================================
 * ======================================================================================================
 */


/**
 * Image 2D are passed using image buffers to shader
 */
def getDescriptorType {T of Texture2D} ()-> VkDescriptorType {
    VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
}

/**
 * All other kind of data (vec, mat, etc.) are passed using uniform buffers
 */
def getDescriptorType {T} ()-> VkDescriptorType {
    VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
}

/**
 * @returns: the flag bits for the shader stage
 * @info: this is a convention in the name of the uniform, maybe there is a better way for doing that but for the moment it seems ok
 * @example: 
 * ====
 * let v_projection = ; // vertex shader
 * let vf_view = ; // vertex and frag shader
 * let f_color = ; // frag shader
 * let g_color = ; // geometry
 * let c_color = ; // compute
 * let a_color = ; // all graphics
 * let A_color = ; // all 
 * ====
 */
def getDescriptorStage (name : [c32])-> u32 {
    let mut stage : u32 = 0u32;
    for i in name {
        match i {
            'f' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT); }
            'v' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT); }
            'g' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT); }
            'c' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT); }
            'a' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS); }
            'A' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL); }
            '_' => { break {} }
        }
    };
        
    stage    
}
