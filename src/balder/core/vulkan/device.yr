mod balder::core::vulkan::device;

import vulkan::_;
import balder::core::_;

import std::io, std::conv;
import std::config::_;
import std::collection::set;
import std::collection::vec;
import std::time::_;

import sdl2::_;


struct
| capabilities : VkSurfaceCapabilitiesKHR = VkSurfaceCapabilitiesKHR ()
| formats : [VkSurfaceFormatKHR] = []
| presents : [VkPresentModeKHR] = []
 -> SwapChainDetail;

/**
 * A vulkan device used to manage vulkan rendering tools
 */
pub class VulkanDevice {

    // The pointer to the window holding the device
    let dmut _win : &(&Window) = null;
    
    // The vulkan instance used to configure vulkan lib
    let dmut _instance : &VulkanInstance = VulkanInstance::new ();

    prot {
        
        // The logical device handle of vulkan
        let dmut _device : VkDevice = null;
        
        // The graphics queue
        let dmut _graphicsQueue : VkQueue = null;

        // The present queue
        let dmut _presentQueue : VkQueue = null;
        
    }

    prot {    
        // The handle of the physical device of vulkan
        let dmut _physicalDevice : VkPhysicalDevice = null;
        
        // The name of the physical device in use
        let mut _physicalDeviceName = ""s8;

        // The indices for graphics and present 
        let mut _physicalDeviceFamilyIndices : [u32] = [];

        // The detail of the capabilities of the swap chain of the physical device
        let mut _physicalDeviceSwapChainDetail = SwapChainDetail ();
    }    

    prot {

        // The size of the swap chain
        let mut _swapChainExtent = VkExtent2D ();

        // The format of the swap chain
        let mut _swapChainFormat = VkFormat::VK_FORMAT_MAX_ENUM;

        // The swap chain of the device to render, and display using different images
        let dmut _swapChain : VkSwapchainKHR = null;

        // The image attached to the swap chain
        let dmut _swapChainImages : [VkImage] = [];
        
        // The view of the images attach to each frame of the swap chain
        let dmut _swapChainImageViews : [VkImageView] = [];

        // The framebuffers attached to the image view of the swap chain
        let dmut _swapChainFramebuffers : [VkFramebuffer] = [];

        // True when the window was resized and the swap chain needs to be recreated
        let mut _resizingWindow = false;
        
    }

    prot {

        // The render pass of the device
        let dmut _renderPass : VkRenderPass = null;

        // The color used when clearing an image of the swap chain;
        let dmut _clearColor : VkClearValue = VkClearValue (color-> VkClearColorValue (int32-> [0 ; 4]));

        // The begin info used when begining the render pass
        let dmut _renderPassBeginInfo : VkRenderPassBeginInfo = VkRenderPassBeginInfo ();

    }

    prot {
        
        // The command pool of the device
        let dmut _commandPool : VkCommandPool = null;

        // The command buffer for recording (one per frame in flight)
        let dmut _commandBuffers : [VkCommandBuffer] = [];

        // The maximum number of drawing frame before one is displayed
        let dmut _maxFrameInFlight = 0u32;

        // The fences to synchronize inflight frames
        let dmut _inFlightFences : [VkFence] = [];

        // Semaphore used to signal when an image is ready
        let dmut _imageAvailableSem : [VkSemaphore] = [];

        // Semaphore used to signal that an image is finished rendering
        let dmut _renderFinishedSem : [VkSemaphore] = [];
        
        // The memory allocator
        let dmut _vmaAllocator : VmaAllocator = null;

        // The index of the frame being drawn
        let mut _currentFrame = 0u32;
        
    }
    
    prot {
        // The configuration of the device
        let mut _config : &Config = Dict::new ();
        
        // The list of extension required by the vulkan device
        let dmut _requiredExtensions = HashSet!{[c8]}::new ();
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * @params: 
     *    - app: the application holding the vulkan device
     */
    pub self () {}

    /**
     * Configure the device using a given configuration
     * @params: 
     *    - config: the configuration to use for the device
     */
    pub def configure (mut self, dmut win : &Window, config : &Config)
        throws &BalderError
    {
        self:.dispose ();

        self._win = alias &win;        
        self._instance = alias win:.getVulkanInstance ();
        
        self._config = config;
        self._maxFrameInFlight = (self._config["max-frame-in-flight"].to!{u32} ()?).getOr (2u32);
        
        self._requiredExtensions:.insert (VK_KHR_SWAPCHAIN_EXTENSION_NAME);
        
        self:.selectPhysicalDevice (alias win);
        self:.createLogicalDevice (alias win);
        self:.createSwapchain (alias win);
        self:.createImageViews (alias win);
        self:.createRenderPass (alias win);
        self:.createFramebuffers (alias win);
        self:.createCommandPool (alias win);
        self:.createCommandBuffers (alias win);
        self:.createSyncObjects ();
        self:.createVmaAllocator (alias win);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================   GETTERS  ===========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * @returns: the vulkan handle of the physical device (might be null)
         */
        def getPhysicalDeviceHandle (mut self)-> dmut VkPhysicalDevice {
            alias self._physicalDevice
        }

        /**
         * @returns: the handle of the logical device (can be null)
         */
        def getDeviceHandle (mut self)-> dmut VkDevice {
            alias self._device
        }        
        
        /**
         * @returns: the extent of the current swap chain
         */
        def getSwapchainExtent (self)-> VkExtent2D {
            self._swapChainExtent
        }

        /**
         * @returns: the format used by the current swapchain
         */
        def getSwapchainFormat (self)-> VkFormat {
            self._swapChainFormat
        }

        /**
         * @returns: the vulkan handle of the render pass
         */
        def getRenderPass (mut self)-> dmut VkRenderPass {
            alias self._renderPass
        }

        /**
         * @returns: the command buffer of the rendering frame
         */
        def getCommandBuffer (mut self)-> dmut VkCommandBuffer {
            alias self._commandBuffers [self._currentFrame]
        }

        /**
         * @returns: the command pool used to create command buffers
         */
        def getCommandPool (mut self)-> dmut VkCommandPool {
            alias self._commandPool
        }

        /**
         * @returns: the graphics queue of the device
         */
        def getGraphicsQueue (mut self)-> dmut VkQueue {
            alias self._graphicsQueue
        }

        /**
         * @returns: the vma allocator of the device
         */
        def getVmaAllocator (mut self)-> dmut VmaAllocator {
            alias self._vmaAllocator
        }

        /**
         * @returns: the maximum number of frame that can be drawn at the same time
         */
        def getMaxFrameInflight (self)-> u32 {
            self._maxFrameInFlight
        }
                
        /**
         * @returns: the index of the frame being drawn (on which command are sent)
         */
        def getCurrentFrameIndex (self)-> u32 {
            self._currentFrame
        }

        /**
         * @returns: the indices of the queue family used by the physical device (basically graphics and present)
         */
        def getPhysicalDeviceFamilyIndices (self)-> [u32] {
            self._physicalDeviceFamilyIndices
        }
        
    }    
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================   USAGE  =============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * Wait for the previous frame to be finished rendering
         */
        def waitPreviousFrame (mut self) {            
            vkWaitForFences (self._device, 1u32, &self._inFlightFences[self._currentFrame], VK_TRUE, u64::max);
        }

        /**
         * Wait for the device to be idle
         */
        def waitIdle (mut self) {
            vkDeviceWaitIdle (self._device);
        }
        
        /**
         * The window size changed so we need to inform the device
         */
        def windowResize (mut self) {
            self._resizingWindow = true;
        }

        /**
         * Wait for an image to be available for rendering, and return its index
         */
        def acquireNextImage (mut self)-> i32 {        
            let mut imageIndex = 0u32;
            let result = vkAcquireNextImageKHR (self._device, self._swapChain, u64::max, self._imageAvailableSem[self._currentFrame], null, alias &imageIndex);

            if (result == VkResult::VK_ERROR_OUT_OF_DATE_KHR) {
                self:.recreateSwapchain ()?;
                return -1;
            }
            else if (result != VkResult::VK_SUCCESS && result != VkResult::VK_SUBOPTIMAL_KHR) {
                return -1;
            }

            vkResetFences (self._device, 1u32, alias &self._inFlightFences[self._currentFrame]);
            vkResetCommandBuffer (self._commandBuffers [self._currentFrame], 0u32);

            return cast!i32 (imageIndex);
        }
        
        /**
         * Start the recording of drawing
         */
        def startRecording (mut self)-> VkResult {
            let cmdBegin = VkCommandBufferBeginInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO               
                );

            vkBeginCommandBuffer (self._commandBuffers [self._currentFrame], &cmdBegin)
        }

        /**
         * Stop the recording of drawing
         * @assume the recording was started
         */
        def stopRecording (mut self)-> VkResult {
            vkEndCommandBuffer (self._commandBuffers [self._currentFrame])
        }

        /**
         * Start a the render pass
         * @params: 
         *    - imageIndex: the index of the image to use for rendering
         * @assume: imageIndex was acquired with self:.acquireNextImage ()
         */
        def startRenderPass (mut self, imageIndex : u32) {
            self._renderPassBeginInfo.framebuffer = self._swapChainFramebuffers[imageIndex];

            vkCmdBeginRenderPass (self._commandBuffers [self._currentFrame], &self._renderPassBeginInfo, VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE)
        }        

        /**
         * Stop the render pass
         * @assume: it was started
         */
        def stopRenderPass (mut self) {
            vkCmdEndRenderPass (self._commandBuffers [self._currentFrame]);
        }

        /**
         * Wait the inflight frame to be rendered and present it to the window surface
         */
        def presentScreen (mut self, image : u32)-> VkResult {
            let waitStages : u32 = cast!u32 (VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);
            
            let submitInfo = VkSubmitInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO,
                waitSemaphoreCount-> 1u32,
                pWaitSemaphores-> &self._imageAvailableSem [self._currentFrame],
                pWaitDstStageMask-> &waitStages,
                commandBufferCount-> 1u32,
                pCommandBuffers-> &self._commandBuffers [self._currentFrame],
                signalSemaphoreCount-> 1u32,
                pSignalSemaphores-> &self._renderFinishedSem [self._currentFrame]
                );
            
            let r = vkQueueSubmit (self._graphicsQueue, 1u32, &submitInfo, self._inFlightFences [self._currentFrame]);
            if (r != VkResult::VK_SUCCESS) return r;

            let presentInfo = VkPresentInfoKHR (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
                waitSemaphoreCount-> 1u32,
                pWaitSemaphores-> &self._renderFinishedSem [self._currentFrame],
                swapchainCount-> 1u32,
                pSwapchains-> &self._swapChain,
                pImageIndices-> &image);

            let r2 = vkQueuePresentKHR (self._presentQueue, &presentInfo);
            if (r2 == VkResult::VK_ERROR_OUT_OF_DATE_KHR || r2 == VkResult::VK_SUBOPTIMAL_KHR || self._resizingWindow) {
                self._resizingWindow = false;
                {
                    self:.recreateSwapchain ();
                } catch {
                    _ => return VkResult::VK_ERROR_UNKNOWN;
                }
                
            } else if (r2 != VkResult::VK_SUCCESS) return r2;

            self._currentFrame = (self._currentFrame + 1u32) % self._maxFrameInFlight;

            return VkResult::VK_SUCCESS;
        }
        
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   VMA ALLOCATOR  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    prv {

        def createVmaAllocator (mut self, dmut _ : &Window)
            throws &BalderError
        {
            let createInfo = VmaAllocatorCreateInfo (
                vulkanApiVersion-> cast!u32 (VK_API_VERSION_1_0),
                physicalDevice-> self._physicalDevice,
                device-> self._device,
                instance-> self._instance:.getHandle ()
                );

            if (vmaCreateAllocator (&createInfo, alias &self._vmaAllocator) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create vma allocator"s8);
            }            
        }               

    }    
    
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   COMMAND POOL  =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    prv {

        /**
         * Create a command pool for the device used to instantiate command buffers on the graphic queue
         */
        def createCommandPool (mut self, dmut _ : &Window)
            throws &BalderError
        {
            let poolInfo = VkCommandPoolCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
                flags-> cast!u32 (VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT),
                queueFamilyIndex-> self._physicalDeviceFamilyIndices [1]
                );

            if (vkCreateCommandPool (self._device, &poolInfo, null, alias &self._commandPool) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create the command poll"s8);
            }
        }

        /**
         * Create the command buffers of the device
         */
        def createCommandBuffers (mut self, dmut _ : &Window)
            throws &BalderError
        {
            self._commandBuffers = [null ; new self._maxFrameInFlight];
            let allocInfo = VkCommandBufferAllocateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
                commandPool-> self._commandPool,
                level-> VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY,
                commandBufferCount-> 1u32
                );

            for i in 0us .. self._commandBuffers.len {
                if (vkAllocateCommandBuffers (self._device, &allocInfo, alias &self._commandBuffers [i]) != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to allocate command buffers"s8); 
                }
            }            
        }

        /**
         * Create the synchronization object used to synchronize frame rendering and presenting
         */
        def createSyncObjects (mut self)
            throws &BalderError
        {
            self._inFlightFences = [null ; new self._maxFrameInFlight];
            self._imageAvailableSem = [null ; new self._maxFrameInFlight];
            self._renderFinishedSem = [null ; new self._maxFrameInFlight];

            let semInfo = VkSemaphoreCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
                );

            let fenceInfo = VkFenceCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
                flags-> cast!u32 (VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT)
                );

            for i in 0u32 .. self._maxFrameInFlight {
                let r1 = vkCreateSemaphore (self._device, &semInfo, null, alias &self._imageAvailableSem[i]);
                let r2 = vkCreateSemaphore (self._device, &semInfo, null, alias &self._renderFinishedSem[i]);
                let r3 = vkCreateFence (self._device, &fenceInfo, null, alias &self._inFlightFences[i]);
                if (r1 != VkResult::VK_SUCCESS || r2 != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to create semaphores"s8);
                }

                if (r3 != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to create fence"s8);
                }
            }
        }
        
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   RENDER PASS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    prv {

        /**
         * Create the render pass attached to the images of the swapchain
         */
        def createRenderPass (mut self, dmut _ : &Window)
            throws &BalderError
        {
            let colorAttachement = VkAttachmentDescription (
                format-> self._swapChainFormat,
                samples-> VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT,
                loadOp-> VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR,
                storeOp-> VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE, 
                stencilLoadOp-> VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                stencilStoreOp-> VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE,
                initialLayout-> VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED,
                finalLayout-> VkImageLayout::VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
                );

            let colorAttachementRef = VkAttachmentReference (
                layout-> VkImageLayout::VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
                );

            let subPass = VkSubpassDescription (
                pipelineBindPoint-> VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS,
                colorAttachmentCount-> 1u32,
                pColorAttachments-> &colorAttachementRef
                );

            let renderPassInfo = VkRenderPassCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
                attachmentCount-> 1u32,
                pAttachments-> &colorAttachement,
                subpassCount-> 1u32,
                pSubpasses-> &subPass
                );

            if (vkCreateRenderPass (self._device, &renderPassInfo, null, alias &self._renderPass) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create render pass"s8);
            }


            let dmut colors = [0 ; 4];
            colors [3] = 1;

            self._clearColor = VkClearValue (color-> VkClearColorValue (int32-> colors));
            
            self._renderPassBeginInfo = VkRenderPassBeginInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
                renderPass-> self._renderPass,
                renderArea-> VkRect2D (extent-> self._swapChainExtent),
                clearValueCount-> 1u32,
                pClearValues-> &self._clearColor
                );            
        }
        
    }
    

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   IMAGE VIEWS  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    prv {

        /**
         * Create the image views of each swap frame of the swapchain
         */
        def createImageViews (mut self, dmut _ : &Window)
            throws &BalderError
        {
            self._swapChainImageViews = [null ; new self._swapChainImages.len];
            let components = VkComponentMapping (
                r-> VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY,
                g-> VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY,
                b-> VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY,
                a-> VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY
                    );

            let range = VkImageSubresourceRange (
                aspectMask-> cast!u32 (VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT),
                levelCount-> 1u32,
                layerCount-> 1u32
                );

            for i in 0us .. self._swapChainImages.len {                
                let createInfo = VkImageViewCreateInfo (
                    sType-> VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
                    image-> self._swapChainImages[i],
                    viewType-> VkImageViewType::VK_IMAGE_VIEW_TYPE_2D,
                    format-> self._swapChainFormat,
                    components-> components,
                    subresourceRange-> range
                    );

                if (vkCreateImageView (self._device, &createInfo, null, alias &self._swapChainImageViews[i]) != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to create image view"s8);
                }
            }
        }
        
    }


    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   FRAMEBUFFERS  =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    prv {

        /**
         * Create the framebuffers of the image view in the swapchain       
         */
        def createFramebuffers (mut self, dmut _ : &Window)
            throws &BalderError
        {
            self._swapChainFramebuffers = [null ; new self._swapChainImageViews.len];
            for i in 0us .. self._swapChainImageViews.len {

                let framebufferInfo = VkFramebufferCreateInfo (
                    sType-> VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
                    renderPass-> self._renderPass,
                    attachmentCount-> 1u32,
                    pAttachments-> &self._swapChainImageViews[i],
                    width-> self._swapChainExtent.width,
                    height-> self._swapChainExtent.height,
                    layers-> 1u32
                    );

                if (vkCreateFramebuffer (self._device, &framebufferInfo, null, alias &self._swapChainFramebuffers[i]) != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to create framebuffers"s8);
                }
            }
        }        

    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   SWAP CHAIN  ==========================================
     * ======================================================================================================
     * ======================================================================================================
     */


    prv {
        
        /**
         * Create the swap chain the allows to render to the window in a fluid way
         */
        def createSwapchain (mut self, dmut win : &Window)
            throws &BalderError
        {
            let surfaceFormat = self.chooseSwapSurfaceFormat (self._physicalDeviceSwapChainDetail.formats);
            let presentMode = self.chooseSwapPresentMode (self._physicalDeviceSwapChainDetail.presents, (self._config["vsync"].(config::conv::to)!{bool} ()?).getOr (true));
            
            let imageCount = if (self._physicalDeviceSwapChainDetail.capabilities.maxImageCount > 0u32
                                 && self._physicalDeviceSwapChainDetail.capabilities.minImageCount == self._physicalDeviceSwapChainDetail.capabilities.maxImageCount) {
                self._physicalDeviceSwapChainDetail.capabilities.maxImageCount
            } else {
                self._physicalDeviceSwapChainDetail.capabilities.minImageCount + 1u32
            };

            self._swapChainFormat = surfaceFormat.format;
            self._swapChainExtent = self.chooseSwapChainExtent (win.getDimension (), self._physicalDeviceSwapChainDetail.capabilities);

            
            let sharingMode = if (self._graphicsQueue is self._presentQueue) {
                VkSharingMode::VK_SHARING_MODE_EXCLUSIVE
            } else { VkSharingMode::VK_SHARING_MODE_CONCURRENT };
            
            let indices =
                if (self._graphicsQueue is self._presentQueue) {
                    []
                } else { self._physicalDeviceFamilyIndices }
            
            let createInfo = VkSwapchainCreateInfoKHR (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
                surface-> win:.getVulkanSurface (),
                minImageCount-> imageCount,
                imageFormat-> self._swapChainFormat,
                imageColorSpace-> surfaceFormat.colorSpace,
                imageExtent-> self._swapChainExtent,
                imageArrayLayers-> 1u32,
                imageUsage-> cast!u32 (VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT),
                imageSharingMode-> sharingMode,
                pQueueFamilyIndices-> indices.ptr,
                queueFamilyIndexCount-> cast!u32 (indices.len),
                preTransform-> self._physicalDeviceSwapChainDetail.capabilities.currentTransform,
                compositeAlpha-> VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
                presentMode-> presentMode,
                clipped-> VK_TRUE
                );            


            if (vkCreateSwapchainKHR (self._device, &createInfo, null, alias &self._swapChain) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create swap chain"s8);
            }

            let mut imageCreated = 0u32;
            vkGetSwapchainImagesKHR (self._device, self._swapChain, alias &imageCreated, null);            
            self._swapChainImages = [null ; new imageCreated];
            vkGetSwapchainImagesKHR (self._device, self._swapChain, alias &imageCreated, alias self._swapChainImages.ptr);                        
        }

        /**
         * Choose a format for swap chain
         * @params: 
         *      - presents: the list of available swap chain formats
         */
        def chooseSwapSurfaceFormat (self, formats : [VkSurfaceFormatKHR])-> VkSurfaceFormatKHR
            throws &BalderError
        {
            for f in formats {
                if (f.format == VkFormat::VK_FORMAT_B8G8R8_SRGB && f.colorSpace == VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
                    return f;
                }
            }

            if (formats.len != 0us) return formats [0];

            throw BalderError::new ("No available format for swap chain"s8);
        }

        /**
         * Choose a present mode for the swap chain
         * @params: 
         *      - presents: the list of available present mode
         */
        def chooseSwapPresentMode (self, presents : [VkPresentModeKHR], vsync : bool)-> VkPresentModeKHR {
            let mut best = VkPresentModeKHR::VK_PRESENT_MODE_FIFO_KHR;
            for p in presents {
                if (!vsync) {
                    if (p == VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR) {
                        best = p;                        
                    } else if (best != VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR &&
                               p == VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR) {
                        best = p;
                    }
                } else {
                    if (p == VkPresentModeKHR::VK_PRESENT_MODE_MAILBOX_KHR) return p;
                }
            }

            best
        }        

        /**
         * Choose a size for the swap chain 
         * @params: 
         *     - win: the dimension of the window
         *     - cap: the capabilities of the physical used to create the swap chain
         */
        def chooseSwapChainExtent (self, win : (u32, u32), cap : VkSurfaceCapabilitiesKHR)-> VkExtent2D {
            import std::algorithm::comparison;
            
            if (cap.currentExtent.width != u32::max) {
                return cap.currentExtent;
            }
            
            let w = clamp (win._0, cap.minImageExtent.width, cap.maxImageExtent.width);
            let h = clamp (win._1, cap.minImageExtent.height, cap.maxImageExtent.height);


            VkExtent2D (width-> w, height-> h)
        }


        /**
         * Recreate the swapchain that became obsolete
         */
        def recreateSwapchain (mut self)
            throws &BalderError
        {
            vkDeviceWaitIdle (self._device);
            
            self:.disposeSwapchain ();
            if (self._win is null) throw BalderError::new ("Malformed device"s8);
            
            self:.createSwapchain (__pragma!trusted (alias *self._win));
            self:.createImageViews (__pragma!trusted (alias *self._win));
            self:.createFramebuffers (__pragma!trusted (alias *self._win));

            self._renderPassBeginInfo = VkRenderPassBeginInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
                renderPass-> self._renderPass,
                renderArea-> VkRect2D (extent-> self._swapChainExtent),
                clearValueCount-> 1u32,
                pClearValues-> &self._clearColor
                );            
        }        
    }    

    /**
     * Dispose the swap chain and its components
     */
    pub def disposeSwapchain (mut self) {
        if (self._swapChainFramebuffers.len != 0us) {
            for buf in self._swapChainFramebuffers {
                vkDestroyFramebuffer (self._device, buf, null);
            }
            
            self._swapChainFramebuffers = [];
        }
        
        if (self._swapChainImageViews.len != 0us) {
            for image in self._swapChainImageViews {
                vkDestroyImageView (self._device, image, null);
            }

            self._swapChainImageViews = [];
        }

        
        if (self._swapChain !is null) {                       
            vkDestroySwapchainKHR (self._device, self._swapChain, null);
            self._swapChain = null;
            self._swapChainExtent = VkExtent2D ();
            self._swapChainFormat = VkFormat::VK_FORMAT_MAX_ENUM;
            self._swapChainImages = [];
        }
    }
    
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===========================================   LOGICAL DEVICE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */


    prv {

        /**
         * Create the logical device to attach to the selected physical device to render things
         */
        def createLogicalDevice (mut self, dmut _ : &Window)
            throws &BalderError
        {            
            let mut priority = 1.0f;

            let dmut uniq = HashSet!{u32}::new ();
            let dmut v = Vec!{VkDeviceQueueCreateInfo}::new ();
            for i in self._physicalDeviceFamilyIndices {
                if (i !in uniq) {
                    v:.push (
                        VkDeviceQueueCreateInfo (
                            sType-> VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
                            queueFamilyIndex-> i,
                            queueCount-> 1u32,
                            pQueuePriorities-> &priority
                    ));

                    uniq:.insert (i);
                }
            }

            let mut queueCreateInfos = v[];
            let mut logFeatures = VkPhysicalDeviceFeatures ();
            if ((self._config["anisotropy"].(config::conv::to)!{bool} ()?).getOr (true)) {
                let mut phFeatures = VkPhysicalDeviceFeatures ();
                vkGetPhysicalDeviceFeatures (self._physicalDevice, alias &phFeatures);
                
                logFeatures = VkPhysicalDeviceFeatures (samplerAnisotropy-> phFeatures.samplerAnisotropy);                
            }

            let mut extensions : [mut &(c8)] = [cast!{&c8} (null) ; new self._requiredExtensions.len ()];
            let mut i = 0u32;
            for j in self._requiredExtensions {
                extensions [i] = j.ptr;
                i += 1u32;
            }

            let mut validationLayers : [&c8] = [];
            __version DEBUG {
                validationLayers = ["VK_LAYER_KHRONOS_validation"s8.ptr];
            }
            
            let createInfo = VkDeviceCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
                pQueueCreateInfos-> queueCreateInfos.ptr,
                queueCreateInfoCount-> cast!u32 (queueCreateInfos.len),
                pEnabledFeatures-> &logFeatures,
                enabledExtensionCount-> cast!u32 (extensions.len),
                ppEnabledExtensionNames-> extensions.ptr,
                enabledLayerCount-> cast!u32 (validationLayers.len),
                ppEnabledLayerNames-> validationLayers.ptr
                );

            if (vkCreateDevice (self._physicalDevice, &createInfo, null, alias &self._device) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create logical device"s8);
            }

            
            vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [0], 0u32, alias &self._graphicsQueue);
            vkGetDeviceQueue (self._device, self._physicalDeviceFamilyIndices [1], 0u32, alias &self._presentQueue);

            if (self._graphicsQueue is null) throw BalderError::new ("Failed to retreive graphics queue"s8);
            if (self._presentQueue is null) throw BalderError::new ("Failed to retreive present queue"s8);            
        }
        
    }

    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===========================================   PHYSICAL DEVICE  =======================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    prv {
        
        /**
         * List all available devices and select the best one for rendering
         */
        def selectPhysicalDevice (mut self, dmut win : &Window)
            throws &BalderError
        {
            let mut deviceCount = 0u32;
            if (self._instance:.getHandle () is null) throw BalderError::new ("Invalid vulkan instance"s8);
            
            vkEnumeratePhysicalDevices (self._instance:.getHandle (), alias &deviceCount, null);
            if (deviceCount == 0u32) throw BalderError::new ("No available devices"s8);

            let dmut devices : [VkPhysicalDevice] = [null ; new deviceCount]; 
            vkEnumeratePhysicalDevices (self._instance:.getHandle (), alias &deviceCount, alias devices.ptr);
            
            let mut maxScore = 0;
            for i in 0u32 .. deviceCount {
                let (name, score, fam, support) = self.ratePhysicalDevice (win:.getVulkanSurface (), devices[i]);
                if (maxScore < score) {
                    self._physicalDevice = alias devices[i];
                    self._physicalDeviceName = name;
                    self._physicalDeviceFamilyIndices = fam;
                    self._physicalDeviceSwapChainDetail = support;
                    maxScore = score;
                }
            }

            if (self._physicalDevice is null) throw BalderError::new ("No suitable device found"s8);        
        }

        /**
         * @returns: a score for the physical device, -1 if the device is not suitable
         */
        def ratePhysicalDevice (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> ([c8], i32, [u32], SwapChainDetail) {
            let dmut properties = VkPhysicalDeviceProperties ();
            let dmut features = VkPhysicalDeviceFeatures ();

            vkGetPhysicalDeviceProperties (device, alias &properties);
            vkGetPhysicalDeviceFeatures (device, alias &features);
            
            if (features.geometryShader == 0u32) return (""s8, -1, [], SwapChainDetail ());

            let family = self.findQueueFamily (surface, device);            
            if (!family._0) return (""s8, -1, [], SwapChainDetail ());
            if (!self.checkDeviceExtensionSupport (device)) return (""s8, -1, [], SwapChainDetail ());

            let support = self.querySwapChainSupport (surface, device);
            if (support.formats.len == 0us || support.presents.len == 0us) return (""s8, -1, [], SwapChainDetail ());

            let mut score = cast!i32 (properties.limits.maxImageDimension2D);
            let name = dcopy fromStringZ (properties.deviceName []);

            return if (properties.deviceType == VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
                (name, score + 1000, [family._1, family._2], support)
            } else {
                (name, score, [family._1, family._2], support) 
            };       
        }

        /**
         * Find the indices of the queue family (graphics and present)
         */
        def findQueueFamily (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> (bool, u32, u32) {
            let mut gr = 0u32, mut pr = 0u32;
            let mut foundGr = false, mut foundPr = false;

            let mut queueFamilyCount = 0u32;
            vkGetPhysicalDeviceQueueFamilyProperties (device, alias &queueFamilyCount, null);

            if (queueFamilyCount != 0u32) {
                let dmut queueFamilies = [VkQueueFamilyProperties () ; new queueFamilyCount];
                vkGetPhysicalDeviceQueueFamilyProperties (device, alias &queueFamilyCount, alias queueFamilies.ptr);
                
                for i, q in queueFamilies {
                    if (q.queueFlags & cast!u32 (VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT) != 0u32) {
                        gr = cast!u32 (i);
                        foundGr = true;
                    }

                    let mut presentSupport = VK_FALSE;
                    vkGetPhysicalDeviceSurfaceSupportKHR (device, cast!u32 (i), surface, alias &presentSupport);
                    if (presentSupport != VK_FALSE) {
                        pr = cast!u32 (i);
                        foundPr = true;
                    }

                    if (foundPr && foundGr) break {}
                }                
            }

            return (foundGr && foundPr, gr, pr);            
        }

        /**
         * @returns: true if the physical device has the correct extension for the balder engine to work, false otherwise
         */
        def checkDeviceExtensionSupport (self, device : VkPhysicalDevice)-> bool {
            let mut extensionCount = 0u32;
            vkEnumerateDeviceExtensionProperties (device, null, alias &extensionCount, null);
            
            if (extensionCount != 0u32) {
                let dmut availableExtensions = [VkExtensionProperties () ; new extensionCount];
                vkEnumerateDeviceExtensionProperties (device, null, alias &extensionCount, alias availableExtensions.ptr);

                let dmut required = dcopy self._requiredExtensions;
                for a in availableExtensions {
                    required:.remove (fromStringZ (a.extensionName[]));
                }

                return required.len () == 0us;
            }

            false
        }

        /**
         * Get information about the support for swapchain for the device
         */
        def querySwapChainSupport (self, surface : VkSurfaceKHR, device : VkPhysicalDevice)-> SwapChainDetail {
            let mut capabilities = VkSurfaceCapabilitiesKHR ();
            vkGetPhysicalDeviceSurfaceCapabilitiesKHR (device, surface, alias &capabilities);

            let mut formatCount = 0u32;
            vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, null);

            let dmut formats : [VkSurfaceFormatKHR] = [];
            if (formatCount != 0u32) {
                formats = [VkSurfaceFormatKHR () ; new formatCount];
                vkGetPhysicalDeviceSurfaceFormatsKHR (device, surface, alias &formatCount, alias formats.ptr);
            }

            let mut presentCount = 0u32;
            vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, null);

            
            let dmut presents : [VkPresentModeKHR] = [];
            if (presentCount != 0u32) {
                presents = [VkPresentModeKHR::VK_PRESENT_MODE_MAX_ENUM_KHR ; new presentCount];
                vkGetPhysicalDeviceSurfacePresentModesKHR (device, surface, alias &presentCount, alias presents.ptr);
            }
            
            SwapChainDetail (capabilities-> capabilities, formats-> formats, presents-> presents)
        }

    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ======================================================================================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {

        pub over dispose (mut self) {            
            self._requiredExtensions:.clear ();
            self._win = null;

            self:.disposeSwapchain ();

            if (self._vmaAllocator !is null) {
                vmaDestroyAllocator (alias self._vmaAllocator);
                self._vmaAllocator = null;
            }
            
            if (self._imageAvailableSem.len != 0us) {
                // We dispose the three elements at the same time, they are always constructed and used together
                for i in 0us .. self._imageAvailableSem.len {                    
                    vkDestroySemaphore (self._device, self._imageAvailableSem[i], null);
                    vkDestroySemaphore (self._device, self._renderFinishedSem[i], null);
                    vkDestroyFence (self._device, self._inFlightFences[i], null);
                }

                self._imageAvailableSem = [];
                self._renderFinishedSem = [];
                self._inFlightFences = [];
            }

            // No need to destroy the command buffers, they are managed by the pool
            if (self._commandPool !is null) {
                vkDestroyCommandPool (self._device, self._commandPool, null);
                self._commandPool = null;

                // So they are destroyed here
                self._commandBuffers = [];
            }            

            if (self._renderPass !is null) {
                vkDestroyRenderPass (self._device, self._renderPass, null);
                self._renderPass = null;
                self._clearColor = VkClearValue (color-> VkClearColorValue (int32-> [0 ; 4]));
                self._renderPassBeginInfo = VkRenderPassBeginInfo ();
            }
            
            if (self._device !is null) {
                vkDestroyDevice (self._device, null);
                self._device = null;
                self._graphicsQueue = null;
                self._presentQueue = null;
            }            
            
            self._physicalDevice = null;
            self._physicalDeviceName = ""s8;
            self._physicalDeviceSwapChainDetail = SwapChainDetail ();
            self._physicalDeviceFamilyIndices = [];
        }
        
    }

    __dtor (mut self) {
        self:.dispose ();
    }
         

}
