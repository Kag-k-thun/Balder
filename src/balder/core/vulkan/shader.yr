mod balder::core::vulkan::shader;

import balder::core::vulkan::device;
import balder::core::vulkan::layout;
import balder::core::vulkan::utils;
import balder::core::vulkan::desc_alloc;

import balder::core::error;
import balder::math::vector;

import vulkan::_;
import std::fs::_;
import std::conv;

/**
 * Ancestor of all kind of shaders
 */
pub class @abstract Shader {

    // The layout of the shader
    let dmut _pipelineLayout : &PipelineLayout;
    
    // The vulkan device holding the shader
    let dmut _device : &VulkanDevice;

    // The descriptor allocator used to create descriptor sets
    let dmut _allocator : (&DescriptorAllocator)? = (dmut (&DescriptorAllocator)?)::__err__;;
    
    // The vulkan handle
    let mut _program : VkPipeline = null;
    
    prot self (dmut device : &VulkanDevice, dmut pipelineLayout : &PipelineLayout)
        with _device = alias device, _pipelineLayout = alias pipelineLayout
    {}

    /**
     * @returns: the device used by the shader
     */
    pub def getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the pipeline layout of the shader
     */
    pub def getLayout (mut self)-> dmut &PipelineLayout {
        alias self._pipelineLayout
    }

    /**
     * @returns: the allocator of the shader to allocate a descriptor set
     */
    pub def getAllocator (mut self)-> dmut &DescriptorAllocator {
        match ref self._allocator {
            Ok (dmut x : _) => return alias x;
            _ => __pragma!panic ();
        }
    }

    /**
     * Use the shader for the next drawings
     */
    pub def use (mut self) {
        vkCmdBindPipeline (self._device:.getCommandBuffer (), VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS, self._program);

        let extent = self._device:.getSwapchainExtent ();
        let viewport = VkViewport (
            x-> 0.0f,
            y-> 0.0f,
            width-> to!f32 (extent.width), 
            height-> to!f32 (extent.height),
            minDepth-> 0.0f,
            maxDepth-> 1.0f
        );

        vkCmdSetViewport (self._device:.getCommandBuffer (), 0u32, 1u32, &viewport);

        let scissor = VkRect2D (extent-> extent);
        vkCmdSetScissor (self._device:.getCommandBuffer (), 0u32, 1u32, &scissor);        
    }
    
    impl Disposable {
        pub over dispose (mut self) {}
    }
    
}
   
/**
 * A shader
 * @template: 
 *    - IN: the input type of the shader 
 *    - UN: the uniform type of the shader
 */
pub class Shader {struct IN, struct UN} over Shader {

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    /**
     * @params: 
     *    - device: the device used to allocate the shader
     *    - pipelineLayout: the layout describing the shader uniform content
     *    - vertSrc: the path of the vertex shader
     *    - fragSrc: the path of the fragment shader
     */
    pub self simplePass (dmut device : &VulkanDevice, vertSrc : &Path, fragSrc : &Path)
        with super (alias device, PipelineLayout!{UN}::new (alias device))
        throws &BalderError
    {
        match ref self._pipelineLayout {
            dmut l : &PipelineLayout!{UN} => {
                self._allocator = (DescriptorAllocator!{UN}::new (alias l))?;        
            }
        }
        
        let vertContent = self.readFile (vertSrc);
        let fragContent = self.readFile (fragSrc);

        let vertShader = self:.createShaderModule (vertContent);
        let fragShader = self:.createShaderModule (fragContent);

        let vertShaderStageInfo = VkPipelineShaderStageCreateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            stage-> VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT,
            module-> vertShader,
            pName-> toStringZ ("main"s8)
        );

        let fragShaderStageInfo = VkPipelineShaderStageCreateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            stage-> VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT,
            module-> fragShader,
            pName-> toStringZ ("main"s8)
            );

        let dmut shaderStages = [VkPipelineShaderStageCreateInfo () ; 2];
        shaderStages[0] = vertShaderStageInfo;
        shaderStages[1] = fragShaderStageInfo;

        self._program = self:.createPipeline (shaderStages);
        
        vkDestroyShaderModule (self._device:.getDeviceHandle (), vertShader, null);
        vkDestroyShaderModule (self._device:.getDeviceHandle (), fragShader, null);                
    }
    
    prv {

        /**
         * @returns: the content of a shader file
         */
        def readFile (self, src : &Path)-> [u8]
            throws &BalderError
        {
            with dmut f = File::open (src) {
                f:.readBytesAll ()
            } catch {
                _ => throw BalderError::new ("Shader file not found : "s8 ~ src.toStr ());
            }
        }

        /**
         * Create a shader module from bytecode of the shader
         * @returns: the shader module
         */
        def createShaderModule (mut self, bytecode : [u8])-> VkShaderModule
            throws &BalderError
        {
            let createInfo = VkShaderModuleCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                codeSize-> bytecode.len,
                pCode-> cast!{&u32} (cast!{&void} (bytecode.ptr))
                );

            let dmut module : VkShaderModule = null;
            if (vkCreateShaderModule (self._device:.getDeviceHandle (), &createInfo, null, alias &module) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create shader module"s8);
            }

            module
        }

        /**
         * Create the pipeline of the shader
         */
        def createPipeline (mut self, stages : [VkPipelineShaderStageCreateInfo])-> dmut VkPipeline
            throws &BalderError
        {
            let (attrDescr, bindDescr) = self.createAttributeDescription ();

            let vertexInputInfo = VkPipelineVertexInputStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
                vertexBindingDescriptionCount-> 1u32,
                pVertexBindingDescriptions-> &bindDescr,
                vertexAttributeDescriptionCount-> cast!u32 (attrDescr.len),
                pVertexAttributeDescriptions-> attrDescr.ptr
                );


            let inputAssembly = VkPipelineInputAssemblyStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
                topology-> VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
                primitiveRestartEnable-> VK_FALSE
                );

            let viewport = VkViewport (
                x-> 0.0f,
                y-> 0.0f,
                width-> to!f32 (self._device.getSwapchainExtent ().width),
                height-> to!f32 (self._device.getSwapchainExtent ().height),
                minDepth-> 0.0f,
                maxDepth-> 1.0f
                );

            let scissors = VkRect2D (
                extent-> self._device.getSwapchainExtent ()
                );

            let dynStateList = [VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT,
                             VkDynamicState::VK_DYNAMIC_STATE_SCISSOR];

            let dynState = VkPipelineDynamicStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
                dynamicStateCount-> cast!u32 (dynStateList.len),
                pDynamicStates-> dynStateList.ptr
                );

            let viewportState = VkPipelineViewportStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
                viewportCount-> 1u32,
                pViewports-> &viewport,
                scissorCount-> 1u32,
                pScissors-> &scissors
                );

            let rasterizer = VkPipelineRasterizationStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
                depthClampEnable-> VK_FALSE,
                rasterizerDiscardEnable-> VK_FALSE,
                polygonMode-> VkPolygonMode::VK_POLYGON_MODE_FILL,
                cullMode-> cast!u32 (VkCullModeFlagBits::VK_CULL_MODE_BACK_BIT),
                frontFace-> VkFrontFace::VK_FRONT_FACE_CLOCKWISE,
                depthBiasEnable-> VK_FALSE,
                lineWidth-> 1.0f
                );

            let multisampling = VkPipelineMultisampleStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
                sampleShadingEnable-> VK_FALSE,
                rasterizationSamples-> VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT,
                minSampleShading-> 1.0f,
                alphaToCoverageEnable-> VK_FALSE,
                alphaToOneEnable-> VK_FALSE
                );

            let colorBlendAttachement = VkPipelineColorBlendAttachmentState (
                colorWriteMask-> cast!u32 (VkColorComponentFlagBits::VK_COLOR_COMPONENT_R_BIT |
                                           VkColorComponentFlagBits::VK_COLOR_COMPONENT_G_BIT |
                                           VkColorComponentFlagBits::VK_COLOR_COMPONENT_B_BIT |
                                           VkColorComponentFlagBits::VK_COLOR_COMPONENT_A_BIT),
                blendEnable-> VK_TRUE,
                srcColorBlendFactor-> VkBlendFactor::VK_BLEND_FACTOR_SRC_ALPHA,
                dstColorBlendFactor-> VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
                colorBlendOp-> VkBlendOp::VK_BLEND_OP_ADD,
                srcAlphaBlendFactor-> VkBlendFactor::VK_BLEND_FACTOR_ONE,
                dstAlphaBlendFactor-> VkBlendFactor::VK_BLEND_FACTOR_ZERO,
                alphaBlendOp-> VkBlendOp::VK_BLEND_OP_ADD
                );
            
            let colorBlending = VkPipelineColorBlendStateCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
                logicOpEnable-> VK_FALSE,
                logicOp-> VkLogicOp::VK_LOGIC_OP_COPY,
                attachmentCount-> 1u32,
                pAttachments-> &colorBlendAttachement
                );

            let renderPass = self._device:.getRenderPass ();
            let pipelineInfo = VkGraphicsPipelineCreateInfo (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
                stageCount-> cast!u32 (stages.len),
                pStages-> stages.ptr,
                pVertexInputState-> &vertexInputInfo,
                pInputAssemblyState-> &inputAssembly,
                pViewportState-> &viewportState,
                pRasterizationState-> &rasterizer,
                pMultisampleState-> &multisampling,
                pDepthStencilState-> null,
                pColorBlendState-> &colorBlending,
                pDynamicState-> &dynState,
                renderPass-> renderPass,
                layout-> self._pipelineLayout:.getVulkanHandle (),
                subpass-> 0u32,
                basePipelineHandle-> null,
                basePipelineIndex-> -1
                );


            let dmut pipeline : VkPipeline = null;
            if (vkCreateGraphicsPipelines (self._device:.getDeviceHandle (), null, 1u32, &pipelineInfo, null, alias &pipeline) != VkResult::VK_SUCCESS) {
                throw BalderError::new ("Failed to create graphic pipeline"s8);
            }
            
            alias pipeline
        }


        /**
         * Create the vertex description of the input vertex type of the shader
         */
        def createAttributeDescription (self)-> ([VkVertexInputAttributeDescription], VkVertexInputBindingDescription) {
            let dmut res = [VkVertexInputAttributeDescription () ; new (__pragma!field_offsets (IN)).len];
            
            cte for i in 0us .. (__pragma!field_offsets (IN)).len {
                let offset = (__pragma!field_offsets (IN))[i];

                res[i] = VkVertexInputAttributeDescription (
                    binding-> 0u32,
                    location-> cast!u32 (i),
                    format-> getFormat!{IN, (__pragma!field_type (IN, (__pragma!field_names (IN))[i]))} (),
                    offset-> cast!u32 (offset)
                    );                
            }

            let bind = VkVertexInputBindingDescription (
                binding-> 0u32,
                stride-> cast!u32 (sizeof (IN)),
                inputRate-> VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX
                );
            
            (res, bind)
        }
        
    }


    impl Disposable {
        pub over dispose (mut self) {
            match ref self._allocator {
                Ok (dmut m : _) => m:.dispose ();
            }
            
            self._pipelineLayout:.dispose ();

            
            if (self._program !is null) {
                vkDestroyPipeline (self._device:.getDeviceHandle (), self._program, null);
                self._program = null;
            }
            
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
}


