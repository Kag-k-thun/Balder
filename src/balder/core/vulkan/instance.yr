mod balder::core::vulkan::instance;

import vulkan::_;
import balder::core::_;

import std::io;
import std::config::_;
import std::conv;

pub class VulkanInstance {

    // The handle of the vulkan instance
    let dmut _instance : VkInstance = null;

    // The configuration of the instance
    let mut _config : &Config = Dict::new ();

    // The handle for the debug messenger
    let dmut _debugMessenger : VkDebugUtilsMessengerEXT = null;
    
    /**
     * Create an empty vulkan instance
     */
    pub self () {}

    /**
     * Configure the vulkan instance
     * @params: 
     *    - config: the configuration to use
     */
    pub def configure (mut self, dmut win : &Window, config : &Config)
        throws &BalderError
    {
        self:.dispose ();

        self._config = config;        
        self:.createInstance (alias win);
        
        __version DEBUG {
            self:.configureDebug ();
        }
    }
    
    /**
     * @returns: the handle of the vulkan instance
     */
    pub def getHandle (mut self)-> VkInstance {
        self._instance
    }

    /**
     * Create the vulkan instance using the configuration `self._config`
     */
    prv def createInstance (mut self, dmut win : &Window)
        throws &BalderError        
    {
        let mut validationLayers : [&c8] = []; 
        __version DEBUG {
            if (self.checkValidationLayerSupport ()) {
                validationLayers = [ "VK_LAYER_KHRONOS_validation"s8.ptr ];
            }
        }

        let appInfo = VkApplicationInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO,
            pApplicationName -> win.getName ().toStringZ (),
            applicationVersion->  cast!u32 (VK_API_VERSION_1_0),
            pEngineName-> "No egine"s8.ptr,
            engineVersion->  cast!u32 (VK_API_VERSION_1_0),
            apiVersion-> cast!u32 (VK_API_VERSION_1_0),
            pNext->  null
            );

        let mut extensionCount = 0u32;
        SDL_Vulkan_GetInstanceExtensions (win:.getSdlHandle (), alias &extensionCount, null);
        let mut extensionNames : [mut &c8]  = [cast!{&c8} (null) ; new extensionCount];
        SDL_Vulkan_GetInstanceExtensions (win:.getSdlHandle (), alias &extensionCount, alias extensionNames.ptr);        

        __version DEBUG {
            extensionNames = alias (extensionNames ~ [(VK_EXT_DEBUG_UTILS_EXTENSION_NAME).ptr]);
        }
        
        let createInfo = VkInstanceCreateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            pNext-> null,
            flags-> 0u32,
            pApplicationInfo-> &appInfo,
            enabledLayerCount-> cast!u32 (validationLayers.len),
            ppEnabledLayerNames-> validationLayers.ptr,
            enabledExtensionCount-> cast!u32 (extensionNames.len),
            ppEnabledExtensionNames-> extensionNames.ptr
            );

        if (vkCreateInstance (&createInfo, null, alias &self._instance) != VkResult::VK_SUCCESS) {
            throw BalderError::new ("Failed to create vulkan instance"s8);
        }

    }
    
    __version DEBUG {

        /**
         * Debug function that configures the vulkan sdk to print error messages
         */
        prv def configureDebug (mut self)
            throws &BalderError
        {            
            let debugCreateInfo = VkDebugUtilsMessengerCreateInfoEXT (
                sType-> VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
                messageSeverity->
                    cast!u32 (VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
                              VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
                              VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT),
                
                messageType->
                    cast!u32 (VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
                              VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
                              VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT),
                
                pfnUserCallback-> &debugCallback,
                pUserData-> null,
                pNext-> null,
                flags-> 0u32
                );
            
            let f = Runtime!{PFN_vkVoidFunction, PFN_vkCreateDebugUtilsMessengerEXT}::_yrt_unsafe_cast (
                vkGetInstanceProcAddr (self._instance, "vkCreateDebugUtilsMessengerEXT"s8.ptr)
                );
                
            let p = Runtime!{typeof (f), &void}::_yrt_unsafe_cast (f);
            if (p !is null) {
                if (f (self._instance, &debugCreateInfo, null, alias &self._debugMessenger) != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to create vulkan debugger"s8);
                }
            } else {
                throw BalderError::new ("Failed to find vulkan debugger function"s8);
            }
        }
            
        /**
         * Debug function, that verifies that the installed vulkan SDK support debug messaging
         * @returns: true if the sdk support the validation layer `VK_LAYER_KHRONOS_validation`
         */
        prv def checkValidationLayerSupport (self)-> bool {
            let mut layerCount = 0u32;
            vkEnumerateInstanceLayerProperties (alias &layerCount, null);
            
            let dmut avalaibleLayers = allocArray!{VkLayerProperties} (cast!usize (layerCount));
            vkEnumerateInstanceLayerProperties (alias &layerCount, alias avalaibleLayers.ptr);

            for p in avalaibleLayers {                
                let name = fromStringZ (p.layerName[]);
                if (name == "VK_LAYER_KHRONOS_validation"s8) return true;
            }

            return false;
        }
    }
    
    
    impl Disposable {

        pub over dispose (mut self) {
            __version DEBUG {
                if (self._debugMessenger !is null) {
                    let f = Runtime!{PFN_vkVoidFunction, PFN_vkDestroyDebugUtilsMessengerEXT}::_yrt_unsafe_cast (
                        vkGetInstanceProcAddr (self._instance, "vkDestroyDebugUtilsMessengerEXT"s8.ptr));
                    
                    let p = Runtime!{typeof (f), &void}::_yrt_unsafe_cast (f);
                    if (p !is null) {
                        f (self._instance, alias self._debugMessenger, null);
                    }
                    
                    self._debugMessenger = null;
                }

                if (self._instance !is null) {
                    vkDestroyInstance (alias self._instance, null);
                    self._instance = null;
                }
            }            
        }        
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    
}



__version DEBUG {
    def debugCallback (messageSeverity : VkDebugUtilsMessageSeverityFlagBitsEXT,
                       _ : VkDebugUtilsMessageTypeFlagsEXT,
                       pCallBackData : &VkDebugUtilsMessengerCallbackDataEXT,
                       dmut _ : &void)-> VkBool32 {    
        if (messageSeverity >= VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
            match fromStringZ ((*pCallBackData).pMessage)? {
                Ok (msg : _) => 
                    eprintln ("Validation layer =>\n ", msg);
                Err () => __pragma!panic ();
            } 
        }

        return VK_FALSE;
    }

    mod Runtime {F, T} {   
        pub extern (C) def _yrt_unsafe_cast (x : F)-> dmut T;
    }
}
