mod balder::core::vulkan::utils;

import vulkan::_;
import balder::math::_;

/**
 * Image 2D are passed using image buffers to shader
 */
pub def getDescriptorType {T of Texture2D} ()-> VkDescriptorType {
    VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
}

/**
 * All other kind of data (vec, mat, etc.) are passed using uniform buffers
 */
pub def getDescriptorType {T} ()-> VkDescriptorType {
    VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
}

/**
 * @returns: the flag bits for the shader stage
 * @info: this is a convention in the name of the uniform, maybe there is a better way for doing that but for the moment it seems ok
 * @example: 
 * ====
 * let v_projection = ; // vertex shader
 * let vf_view = ; // vertex and frag shader
 * let f_color = ; // frag shader
 * let g_color = ; // geometry
 * let c_color = ; // compute
 * let a_color = ; // all graphics
 * let A_color = ; // all 
 * ====
 */
pub def getDescriptorStage (name : [c32])-> u32 {
    let mut stage : u32 = 0u32;
    for i in name {
        match i {
            'f' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT); }
            'v' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT); }
            'g' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT); }
            'c' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT); }
            'a' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS); }
            'A' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL); }
            '_' => { break {} }
        }
    };
        
    stage    
}


/**
 * @returns: the format that can be used for the type V
 * @static_assert: if type V is not supported
 */
pub def getFormat {T, struct V} ()-> VkFormat {
    cte if (is!{V}{U of vec4}) {
        VkFormat::VK_FORMAT_R32G32B32A32_SFLOAT
    } else cte if (is!{V}{U of vec3}) {
        VkFormat::VK_FORMAT_R32G32B32_SFLOAT
    } else cte if (is!{V}{U of vec2}) {
        VkFormat::VK_FORMAT_R32G32_SFLOAT
    } else cte if (is!{V}{U of f32}) {
        VkFormat::VK_FORMAT_R32_SFLOAT
    } else cte if (is!{V}{U of ivec4}) {
        VkFormat::VK_FORMAT_R32G32B32A32_SINT
    } else cte if (is!{V}{U of ivec3}) {
        VkFormat::VK_FORMAT_R32G32B32_SINT
    } else cte if (is!{V}{U of ivec2}) {
        VkFormat::VK_FORMAT_R32G32_SINT
    } else cte if (is!{V}{U of i32}) {
        VkFormat::VK_FORMAT_R32_SINT
    } else {
        cte assert (false, "Field of type : " ~ (V)::typeid ~ " in type " ~ T::typeid ~ " is unsable as a shader input");
    }
}

