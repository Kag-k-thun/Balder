mod balder::core::vulkan::cmd_alloc;

import balder::core::vulkan::_;
import balder::core::vulkan::utils;
import balder::core::error;


import std::collection::vec;
import vulkan::_;
import std::io;


pub enum
| LOADING = 0u32
| DRAWING = 1u32
 -> CommandAllocatorPhase;

/**
 * The indirecto command allocator is used to allocate indirect command, and generate the indirect command buffer used to draw indirect
 */
pub class @final IndirectCommandAllocator {

    // The device used to allocate and draw
    let dmut _device : &VulkanDevice;

    // The phase of the command allocator
    let mut _phase : CommandAllocatorPhase = CommandAllocatorPhase::LOADING;
    
    // The list of indexed indirect commands
    let dmut _indexedCmds = Vec!{VkDrawIndexedIndirectCommand}::new ();

    // The id of the current index being drawn
    let mut _currentIndexed = 0u64;

    // The buffer storing information about the indirect drawing
    let dmut _indexedCmdBuffer : (&Buffer)? = (dmut (&Buffer)?)::__err__;
    
    /**
     * Crete an empty indirect command allocator
     * @params:
     *    - device: the device used to allocate and draw
     */
    pub self (dmut device : &VulkanDevice)
        with _device = alias device
    {}


    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   GETTERS   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */


    pub {

        /**
         * @returns: the current phase of the allocator
         */
        def getPhase (self)-> CommandAllocatorPhase {
            self._phase
        }
        
    }
    
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==========================================   LOADING PHASE   =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {
        
        /**    
         * Register an indexed mesh that will be drawn during the draw phase
         * @params:
         *    - nbPoints: the number of points to draw
         *    - nbInstance: the number of instance to draw
         *    - firstIndex: the offset of the first index in the ibo buffer
         *    - vertexOffset: the offset of the first vertex in the vbo buffer
         *    - firstInstance: the offset of the first instance in the instance buffer
         */
        def registerIndexedObject (mut self, nbPoints : u32, nbInstance : u32 = 1u32, firstIndex : u32 = 0u32, vertexOffset : i32 = 0, firstInstance : u32 = 0u32) {
            self._indexedCmds:.push (
                VkDrawIndexedIndirectCommand (
                    indexCount-> nbPoints,
                    instanceCount-> nbInstance,
                    firstIndex-> firstIndex,
                    vertexOffset-> vertexOffset,
                    firstInstance-> firstInstance
            ));
        }

        /**
         * Finalize the loading phase of the command buffer allocator. So it enter the drawing phase.
         */
        def finalizeLoading (mut self)
            throws &BalderError
        {
            self._phase = CommandAllocatorPhase::DRAWING;
            if (self._indexedCmds.len () != 0us) {
                let dmut buf = self._device:.getMemoryAllocator ():.allocBuffer (
                    cast!u64 (self._indexedCmds.len () * sizeof (VkDrawIndexedIndirectCommand)),
                    cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT |
                              VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT),
                    cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

                buf:.update (self._indexedCmds[]);                
                self._indexedCmdBuffer = alias (alias buf)?;
            }
        }
        
    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==========================================   DRAWING PHASE   =========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {

        /**
         * Start the recording of drawings
         */
        def startRecording (mut self) {
            if (self._phase != CommandAllocatorPhase::DRAWING) {
                eprintln ("Recording in loading phase, Panic !");
                __pragma!panic ();
            }
                            
            self._currentIndexed = 0u64;
        }
        
        /**
         * Draw the next indexed buffer 
         * @assume: associated buffers, shaders and descriptor set are correctly bound
         */
        def drawNextIndexed (mut self) {
            match ref self._indexedCmdBuffer {
                Ok (dmut buf : &Buffer) => {
                    vkCmdDrawIndexedIndirect (self._device:.getCommandBuffer (), buf:.getVulkanBuffer (), self._currentIndexed * cast!u64 (sizeof (VkDrawIndexedIndirectCommand)), 1u32, cast!u32 (sizeof (VkDrawIndexedIndirectCommand)));
                    self._currentIndexed += 1u64;
                }
                Err () => {
                    // No command to draw
                }
            }
        }
        
    }


    /**
     * ======================================================================================================
     * ======================================================================================================
     * ============================================   DISPOSING   ===========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            match ref self._indexedCmdBuffer {
                Ok (dmut buf : &Buffer) => {
                    buf:.dispose ();
                }
                _ => {}
            }
            
            self._indexedCmds:.clear ();
            self._currentIndexed = 0u64;
            self._phase = CommandAllocatorPhase::LOADING;
        }
        
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
}
