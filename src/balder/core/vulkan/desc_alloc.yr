mod balder::core::vulkan::desc_alloc;

import balder::core::vulkan::_;
import balder::core::vulkan::utils;
import balder::core::error;

import std::collection::vec;
import vulkan::_;

pub class @abstract DescriptorAllocator {
    
    // The vulkan device used for allocation
    let dmut _device : &VulkanDevice;

    // The pipeline layout used by the shader to describe descriptor sets
    let dmut _layout : &PipelineLayout;
    
    // The pool being used
    let dmut _currentPool : VkDescriptorPool = null;

    // The set of used pools
    let dmut _usedPools : [dmut VkDescriptorPool] = [];

    // The set of free pools
    let dmut _freePools : [dmut VkDescriptorPool] = [];

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE   =======================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    pub self (dmut layout : &PipelineLayout)
        with _device = alias layout:.getDevice (), _layout = alias layout
    {}

    /**
     * @returns: the device used to allocate descriptor sets
     */
    pub def getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the pipeline layout used by the allocator
     */
    pub def getPipelineLayout (mut self)-> dmut &PipelineLayout {
        alias self._layout
    }
    
    /**
     * Reset all pools
     */
    pub def resetPools (mut self) {
    }
    
    /**
     * Allocate a descriptor set
     */
    pub def allocate (mut self)-> dmut &DescriptorSet
        throws &BalderError
        ;
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   PRIVATE   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    /**
     * @returns: a usable pool for set allocation
     */
    prot def getPool (mut self, forceFree : bool = false)-> dmut VkDescriptorPool
        throws &BalderError
    {
        let dmut pool = if (forceFree || self._currentPool is null) {
            let dmut p = alias self:.getFreePool ();
            self._usedPools = alias (self._usedPools ~ [alias p]);
            alias p
        } else {
            alias self._currentPool
        };        

        alias pool
    }
    
    /**
     * @returns: a usable descriptor pool for allocation
     */
    prv def getFreePool (mut self)-> dmut VkDescriptorPool
        throws &BalderError
    {
        if (self._freePools.len != 0us) {
            let dmut fr = alias self._freePools[$ - 1us];
            self._freePools = self._freePools [0us .. $ - 1us];

            return alias fr;
        }

        // we want to have a multiple of max frame in flight otherwise we will have so unusable descriptor sets
        return self:.createDescriptorPool (512u32 * self._device.getSwapchainNbFrames ());
    }

    /**
     * Create a new descriptor pool
     */
    prot def createDescriptorPool (mut self, count : u32)-> dmut VkDescriptorPool
        throws &BalderError
        ;
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================  CLEANING   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */
    
    impl Disposable {

        pub over dispose (mut self) {
            for i in 0us .. self._freePools.len {
                vkDestroyDescriptorPool (self._device:.getDeviceHandle (), self._freePools [i], null);
            }

            for i in 0us .. self._usedPools.len {
                vkDestroyDescriptorPool (self._device:.getDeviceHandle (), self._usedPools [i], null);
            }

            self._freePools = [];
            self._usedPools = [];
        }
        
    }

    __dtor (mut self) {
        self:.dispose ();
    }
    
}


/**
 * @template:
 *    - UN: the struct defining the content of a descriptor set
 */
pub class DescriptorAllocator {struct T} over DescriptorAllocator {

    /**
     * @params:
     *     - device: the device used to allocate descriptor sets
     */
    pub self (dmut layout : &PipelineLayout!{T})
        with super (alias layout) 
    {}    
    
    /**
     * Allocate a descriptor set for a given shader
     * @params: 
     *    - shader: the shader in which the descriptor set will be usable
     */
    pub over allocate (mut self)-> dmut &DescriptorSet
        throws &BalderError
    {
        let dmut pool = self:.getPool ();        
        let dmut set : VkDescriptorSet = null;
        let dmut layouts = self._layout:.getDescriptorSetLayout ();

        let allocInfo = VkDescriptorSetAllocateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            descriptorPool->  pool,
            descriptorSetCount-> 1u32,
            pSetLayouts-> &layouts
            );
        
        let mut res = vkAllocateDescriptorSets (self._device:.getDeviceHandle (), &allocInfo, alias &set);
        match res {
            VkResult::VK_SUCCESS => {}
            VkResult::VK_ERROR_FRAGMENTED_POOL | 
	    VkResult::VK_ERROR_OUT_OF_POOL_MEMORY => {
                pool = self:.getPool (forceFree-> true);
                res = vkAllocateDescriptorSets (self._device:.getDeviceHandle (), &allocInfo, alias &set);
                if (res != VkResult::VK_SUCCESS) {
                    throw BalderError::new ("Failed to allocate a descriptor set."s8);
                }
            }
            _ => {
                throw BalderError::new ("Failed to allocate a descriptor set."s8);
            }
        }                
        
        return DescriptorSet!{T}::new (alias self, alias set);
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   PRIVATE   ============================================
     * ======================================================================================================
     * ======================================================================================================
     */
   
    /**
     * Create a descriptor pool that can be used to create a descriptor set
     * @params: 
     *     - count: the number of descriptor set that can be allocated by the pool
     * @returns: the allocated descriptor pool
     */
    prot over createDescriptorPool (mut self, count : u32)-> dmut VkDescriptorPool
        throws &BalderError
    {
        let dmut res = [VkDescriptorPoolSize () ; new (__pragma!field_offsets (T)).len];
        cte for i in 0us .. (__pragma!field_offsets (T)).len {
            res [i] = VkDescriptorPoolSize (
                type-> getDescriptorType!{__pragma!field_type (T, (__pragma!field_names (T))[i])} (),
                descriptorCount-> self._device.getSwapchainNbFrames ()
                );
        }

        let poolInfo = VkDescriptorPoolCreateInfo (
            sType-> VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
            poolSizeCount-> cast!u32 (res.len),
            pPoolSizes-> res.ptr,
            maxSets-> count
            );

        let dmut descPool : VkDescriptorPool = null;
        if (vkCreateDescriptorPool (self._device:.getDeviceHandle (), &poolInfo, null, alias &descPool) != VkResult::VK_SUCCESS) {
            throw BalderError::new ("failed to create descriptor pool."s8);
        }

        return alias descPool;
    }
    
}
