mod balder::core::vulkan::desc_set;

import balder::core::vulkan::_;
import balder::core::vulkan::utils;
import balder::core::error;

import vulkan::_;
import std::io;

/**
 * Ancestor of all descriptor sets
 */
pub class @abstract DescriptorSet {

    // The allocator that allocated the descriptor set    
    let dmut _allocator : &DescriptorAllocator;

    // The allocated descriptor sets (one by in flight frame)
    let dmut _set : VkDescriptorSet;

    // The buffer and image binding 
    let dmut _writes : [VkWriteDescriptorSet] = [];
    
    /**
     * @params:
     *    - allocator: the allocator used to allocate the descriptor set
     *    - sets: the descriptor set (assumed to have one by frame in flight of the drawing device)
     */
    prot self (dmut allocator : &DescriptorAllocator, dmut set : VkDescriptorSet)
        with _allocator = alias allocator, _set = alias set
    {}

    /**
     * Bind a buffer to a uniform value in the descriptor description
     * @params: 
     *    - name: the name of the uniform value to bind
     *    - buf: the buffer to bind to the uniform value
     */
    pub def bind (mut self, name : [c32], dmut buf : &Buffer)-> dmut &DescriptorSet
        throws &BalderError
        ;

    /**
     * Finalize the binding of the descriptor set
     * @assume: all uniform values are bound to a buffer
     */
    pub def finalize (mut self) {        
        vkUpdateDescriptorSets (self._allocator:.getDevice ():.getDeviceHandle (), cast!u32 (self._writes.len), self._writes.ptr, 0u32, null);        
    }

    /**
     * Use the descriptor set for the drawing of the next frame
     */
    pub def use (mut self) {
        let dmut device = self._allocator:.getDevice ();
        let dmut pipeline = self._allocator:.getPipelineLayout ();
        vkCmdBindDescriptorSets (device:.getCommandBuffer (), VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline:.getVulkanHandle (), 0u32, 1u32, &self._set, 0u32, null);
    }
    
}

/**
 * @template: 
 *    - T: the struct defining the content of the descriptor set
 */
pub class DescriptorSet {struct T} over DescriptorSet {

    /**
     * @params:
     *    - allocator: the allocator used to allocate the descriptor set
     *    - sets: the descriptor set (assumed to have one by frame in flight of the drawing device)
     */
    pub self (dmut allocator : &DescriptorAllocator, dmut set : VkDescriptorSet)
        with super (alias allocator, alias set)
    {
        self._writes = [VkWriteDescriptorSet () ; new (__pragma!field_offsets(T)).len];
    }     

    /**
     * Bind a buffer to a uniform value in the descriptor description
     * @params: 
     *    - name: the name of the uniform value to bind
     *    - buf: the buffer to bind to the uniform value

     */
    pub over bind (mut self, name : [c32], dmut buf : &Buffer)-> dmut typeof (self)::super
        throws &BalderError
    {
        cte for i in 0us .. (__pragma!field_offsets(T)).len {
            if ((__pragma!field_names(T))[i] == name) {
                cte assert (getDescriptorType!{__pragma!field_type (T, (__pragma!field_names (T))[i])} () == VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, "cannot bind a buffer to a texture");

                self._writes [i] = VkWriteDescriptorSet (
                    sType-> VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                    dstSet-> self._set,
                    dstBinding-> cast!u32 (i),
                    dstArrayElement-> 0u32,
                    descriptorType-> VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                    descriptorCount-> 1u32,
                    pBufferInfo-> buf:.getDescriptorInfo ()
                    );
                
                return alias self;
            }
        }

        import std::conv;
        throw BalderError::new ("descriptor set has no field named '"s8 ~ to![c8] (name) ~ "'"s8);
    }

    
}
