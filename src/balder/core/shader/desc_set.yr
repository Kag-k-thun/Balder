in desc_set;

use balder::core::{_,
                   memory::_,
                   config::_,
                   driver::_,
                   shader::{_, buffers::_}};

use balder::utils::log;

use ::vulkan::core;
use std::io;

use ::etc::c::memory;

/**
 * Ancestor of all descriptor sets
 */
@final
pub class DescriptorSet {

    // The allocator that allocated the descriptor set    
    let dmut _shader : &Shader;

    // The id of the pool that performed the allocation
    let dmut _poolId : usize;

    // The allocated descriptor sets (one by in flight frame)
    let dmut _set : [VkDescriptorSet] = [];

    // The samplers for textures
    let dmut _samplers : [[c8] => VkSampler] = copy [];

    // the push constant size
    let dmut _pc : [[u8]] = [];

    let stages : u32 = 0;
    
    /**
     * @params:
     *    - allocator: the allocator used to allocate the descriptor set
     *    - sets: the descriptor set (assumed to have one by frame in flight of the drawing device)
     *    - pcSize: the size of the push constant
     *    - uniformSize: the size of the uniform content
     */
    pub self (dmut shader : &Shader, poolId : usize, dmut sets : [VkDescriptorSet])
        with _shader = alias shader
        , _set = alias sets
        , _poolId = poolId
        , _pc = copy [copy [0 ; shader.getPushConstantSize ()] ; sets.len]        
    {}    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the shader to which the descriptor set is attached
     * */
    pub fn getShader (mut self)-> dmut &Shader {
        alias self._shader
    }

    /**
     * @returns: the handles of the vulkan descriptor sets
     * */
    pub fn getSetHandles (mut self)-> dmut [VkDescriptorSet] {
        alias self._set
    }

    /**
     * @returns: the id of the descriptor pool that performed the allocation
     * */
    @field
    pub fn poolId (self)-> usize {
        self._poolId
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Bind an uniform value to a buffer
     * */
    pub fn setUniform (mut self, name : [c8], ubo : &UniformBufferObject, frame : i32 = -1) {        
        let un = if let Ok (un) = self._shader.getUniformInfo (name) {
            un
        } else {
            log::error #("DescriptorSet", "Set uniform impossible :", name);
            return;            
        }

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                        
            let mut bufferInfo = VkDescriptorBufferInfo ();
            bufferInfo.buffer = ubo.getBuffer ().getVulkanBuffer ();
            bufferInfo.offset = 0;
            bufferInfo.range = un.size;

            let mut descWrite = VkWriteDescriptorSet ();
            descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descWrite.dstSet = self._set [i];
            descWrite.dstBinding = un.binding;
            descWrite.dstArrayElement = 0;
            descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            descWrite.descriptorCount = 1;
            descWrite.pBufferInfo = &bufferInfo;

            vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CONSTANTS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Set the value of a push constant in the shader
     * */
    pub fn setConstant {T} (mut self, name : [c8], value : T, frame : i32 = -1) { 
        let pc = if let Ok (pc) = self._shader.getPushConstantInfo (name) {
            pc
        } else {
            log::error #("DescriptorSet", "Set push constant impossible :", name);
            return;   
        }        

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                        
            memcpy (cast!{*void} (self._pc [i].ptr + cast!usize (pc.offset)),
                    cast!{*void} (&value),
                    (T::size));                
        }                    
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          BUFFER          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Bind an uniform value to a buffer
     * */
    pub fn setBuffer (mut self, name : [c8], ubo : &StorageBufferObject, frame : i32 = -1) {        
        let un = if let Ok (un) = self._shader.getBufferInfo (name) {
            un
        } else {
            log::error #("DescriptorSet", "Set buffer impossible :", name);
            return;               
        }

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                            
            let mut bufferInfo = VkDescriptorBufferInfo ();
            bufferInfo.buffer = ubo.getBuffer ().getVulkanBuffer ();
            bufferInfo.offset = 0;
            bufferInfo.range = cast!u64 (ubo.getBuffer ().getSize ());

            let mut descWrite = VkWriteDescriptorSet ();
            descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descWrite.dstSet = self._set [i];
            descWrite.dstBinding = un.binding;
            descWrite.dstArrayElement = 0;
            descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
            descWrite.descriptorCount = 1;
            descWrite.pBufferInfo = &bufferInfo;

            vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          OUTPUT TEXTURE          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Bind a storage texture
     * @params:
     *    - name: the name of the uniform value to bind
     *    - texture: the texture to bind (assuming it's a write texture, e.g. ColorTexture)
     * */
    pub fn setStorageTexture (mut self, name : [c8], texture : &Texture, frame : i32 = -1) {        
        let un = if let Ok (un) = self._shader.getTextureStorageInfo (name) {
            un
        } else {
            log::error #("DescriptorSet", "Set storage texture impossible :", name);
            return;                       
        }

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {            
            let mut imageInfo = VkDescriptorImageInfo ();
            imageInfo.imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_GENERAL; 

            if let outTex : &OutputTexture = texture {
                imageInfo.imageView = outTex.getImageViews ()[i];
            } else {
                imageInfo.imageView = texture.getImageView ();
            }
            
            let mut descWrite = VkWriteDescriptorSet ();
            descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descWrite.dstSet = self._set [i];
            descWrite.dstBinding = un.binding;

            descWrite.dstArrayElement = 0;
            descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
            descWrite.descriptorCount = 1;
            descWrite.pImageInfo = &imageInfo;

            vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);                
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          SAMPLE TEXTURE          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Bind a texture     
     * */
    pub fn setTexture (mut self, name : [c8], texture : &Texture, frame : i32 = -1) {
        let un = if let Ok (un) = self._shader.getTextureInfo (name) {
            un
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                   
        }
        
        let sampler = if let Ok (sampler) = self._samplers [name] {
            sampler 
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                                   
        }
        
        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                                                                            
            { // write image view                

                let mut imageInfo = VkDescriptorImageInfo ();                
                if un.kind == TextureKind::DEPTH {
                    imageInfo.imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
                } else {
                    imageInfo.imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
                } 

                if let outTex : &OutputTexture = texture {
                    imageInfo.imageView = outTex.getImageViews ()[i];
                } else {
                    imageInfo.imageView = texture.getImageView ();
                }

                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.binding;                
                
                // image and sample are bound in two different layout bindings
                if un.binding == un.sampler {
                    imageInfo.sampler = sampler;
                    descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
                } else {
                    descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
                } 
                
                descWrite.dstArrayElement = 0;                
                descWrite.descriptorCount = 1;
                descWrite.pImageInfo = &imageInfo;

                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
            }

            if un.binding != un.sampler { // Write sampler only
                let mut imageInfo = VkDescriptorImageInfo (); 
                imageInfo.sampler = sampler;

                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.sampler;                

                descWrite.dstArrayElement = 0;
                descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
                descWrite.descriptorCount = 1;
                descWrite.pImageInfo = &imageInfo;

                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);                
            }
        }
    }
    
    /**
     * Bind a texture array
     * */
    pub fn setTextureArray (mut self, name : [c8], textures : [&Texture], frame : i32 = -1) {
        let un = if let Ok (un) = self._shader.getTextureInfo (name) {
            un
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                   
        }
        
        let sampler = if let Ok (sampler) = self._samplers [name] {
            sampler 
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                                   
        }        
        
        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {
            {  // write image view
                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.binding;

                let dmut imageInfo = copy [VkDescriptorImageInfo () ; textures.len];                
                for t in 0 .. textures.len {
                    if un.kind == TextureKind::DEPTH {
                        imageInfo [t].imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
                    } else {
                        imageInfo [t].imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
                    } 

                    if let outTex : &OutputTexture = textures [t] {
                        imageInfo [t].imageView = outTex.getImageViews ()[i];
                    } else {
                        imageInfo [t].imageView = textures [t].getImageView ();
                    }                                                    

                    if un.binding == un.sampler {
                        imageInfo [t].sampler = sampler;
                        descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
                    } else {
                        descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
                    }
                }
                
                descWrite.dstArrayElement = 0;                
                descWrite.descriptorCount = cast!u32 (imageInfo.len);
                descWrite.pImageInfo = imageInfo.ptr;
                
                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
            }

            if un.binding != un.sampler { // Write sampler only
                let mut imageInfo = VkDescriptorImageInfo (); 
                imageInfo.sampler = sampler;

                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.sampler;                

                descWrite.dstArrayElement = 0;
                descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
                descWrite.descriptorCount = 1;
                descWrite.pImageInfo = &imageInfo;

                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);                
            }            
        }    
    }
                                                                                                
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the samplers for the textures of the shader
     * */
    pub fn createSamplers (mut self)
        throws BalderError
    {
        let lst = if let Ok (lst) = self._shader.getTextureInfos () && lst.len != 0 {
            lst
        } else {
            return;
        }
        
        let dmut device = self._shader:.getDevice ();
        let dmut properties = VkPhysicalDeviceProperties ();
        vkGetPhysicalDeviceProperties (device.getPhysicalDeviceHandle (), alias &properties);

        for name, info in lst {
            let mut samplerInfo = VkSamplerCreateInfo ();
            samplerInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;

            if info.kind == TextureKind::DEPTH {
                samplerInfo.magFilter = VkFilter::VK_FILTER_NEAREST;
		        samplerInfo.minFilter = VkFilter::VK_FILTER_NEAREST;
                
		        samplerInfo.mipmapMode = info.mipmapMode;                
		        samplerInfo.addressModeU = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
		        samplerInfo.addressModeV = samplerInfo.addressModeU;
		        samplerInfo.addressModeW = samplerInfo.addressModeU;
                
		        samplerInfo.mipLodBias = 0.0f;
		        samplerInfo.maxAnisotropy = 1.0f;
		        samplerInfo.minLod = 0.0f;
		        samplerInfo.maxLod = 1.0f;
		        samplerInfo.borderColor = VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;
                
            } else {
                if info.anisotropyEnable { samplerInfo.anisotropyEnable = VK_TRUE; }                
                if info.unnormalizedCoordinates { samplerInfo.unnormalizedCoordinates = VK_TRUE; }                
                if info.compareEnable { samplerInfo.compareEnable = VK_TRUE; }                

                samplerInfo.maxAnisotropy = std::algorithm::comparison::min (info.maxAnisotropy, properties.limits.maxSamplerAnisotropy);
                samplerInfo.borderColor = info.borderColor;

                samplerInfo.compareOp = info.compareOp;
                samplerInfo.mipmapMode = info.mipmapMode;

                samplerInfo.magFilter = info.magFilter;
                samplerInfo.minFilter = info.minFilter;
                samplerInfo.addressModeU = info.addressModeU;
                samplerInfo.addressModeV = info.addressModeV;
                samplerInfo.addressModeW = info.addressModeW;
            }
            
            let dmut sampler : VkSampler = null;
            if (vkCreateSampler (device.getDeviceHandle (), &samplerInfo, null, &sampler) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create texture sampler for texture " ~ name);
            }

            self._samplers [name] = alias sampler;
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Use the descriptor set for the drawing of the next frame
     */
    pub fn select (self, frame : u32, cmd : VkCommandBuffer) {        
        let pipeline = self._shader.getPipelineLayout ();        
        let current = self._set [frame];

        if self._pc [frame].len != 0 {
            vkCmdPushConstants (cmd,
                                pipeline.getVulkanHandle (),
                                self._shader.getActivatedStages (),
                                0,
                                cast!u32 (self._pc [frame].len),
                                cast!{*void} (self._pc [frame].ptr));
        }
        
        vkCmdBindDescriptorSets (cmd,
                                 self._shader.getBindPoint (),                                 
                                 pipeline.getVulkanHandle (),
                                 0u32,
                                 1u32,
                                 &current,
                                 0u32,
                                 null);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if self._samplers.len != 0 {
                for _, dmut sampler in alias self._samplers {
                    vkDestroySampler (self._shader:.getDevice ().getDeviceHandle (), sampler, null);
                }

                self._samplers = copy [];
            }            

            if self._poolId != 0us {
                self._shader:.getDevice ():.getDescriptorAllocator ():.deallocate (self._poolId, alias self._set);
                self._set = [];
                self._poolId = 0;
            }
        }
    }

}
