in desc_set;

use balder::core::{_,
                   memory::_,
                   config::{_, shader::_},
                   driver::_,
                   shader::{_, buffers::_}};

use balder::utils::log;

use ::vulkan::core;
use std::io;

use ::etc::c::memory;

/**
 * Ancestor of all descriptor sets
 */
@final
pub class DescriptorSet {

    // The configuration of the desc set
    let _cfg : DescriptorSetConfig;
        
    // The shader to which is attached the set
    let dmut _shader : &Shader;


    prot { // Alloc
        
        // The id of the pool that performed the allocation
        let dmut _poolId : usize;
        
        // The allocated descriptor sets (one by in flight frame)
        let dmut _set : [VkDescriptorSet] = [];

        // The samplers for textures
        let dmut _samplers : [[c8] => VkSampler] = copy [];
    }    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @params:
     *    - shader: the shader needing the desc set
     *    - info: the descriptor set content
     *    - setId: the index of the descriptor set
     *    - poolId: the id of the pool that allocated the set
     *    - sets: the allocated sets (one per frame)
     */
    pub self (dmut shader : &Shader,
              poolId : usize,
              info : DescriptorSetConfig,                            
              dmut sets : [VkDescriptorSet])
        
        with _shader = alias shader
        , _cfg = info        
        , _set = alias sets
        , _poolId = poolId                
    {}    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the shader to which the descriptor set is attached
     * */
    pub fn getShader (mut self)-> dmut &Shader {
        alias self._shader
    }

    /**
     * @returns: the handles of the vulkan descriptor sets
     * */
    pub fn getSetHandles (mut self)-> dmut [VkDescriptorSet] {
        alias self._set
    }

    /**
     * @returns: the id of the descriptor pool that performed the allocation
     * */
    @field
    pub fn poolId (self)-> usize {
        self._poolId
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Bind an uniform value to a buffer
     * */
    pub fn setUniform (mut self, name : [c8], ubo : &UniformBufferObject, frame : i32 = -1) {        
        let un = if let Ok (un) = self._cfg.uniforms [name] {
            un
        } else {
            log::error #("DescriptorSet", "Set uniform impossible :", name);
            return;            
        }

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                        
            let mut bufferInfo = VkDescriptorBufferInfo ();
            bufferInfo.buffer = ubo.getBuffer ().getVulkanBuffer ();
            bufferInfo.offset = 0;
            bufferInfo.range = un.size;

            let mut descWrite = VkWriteDescriptorSet ();
            descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descWrite.dstSet = self._set [i];
            descWrite.dstBinding = un.binding;
            descWrite.dstArrayElement = 0;
            descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            descWrite.descriptorCount = 1;
            descWrite.pBufferInfo = &bufferInfo;

            vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          BUFFER          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Bind an uniform value to a buffer
     * */
    pub fn setBuffer (mut self, name : [c8], ubo : &StorageBufferObject, frame : i32 = -1) {        
        let un = if let Ok (un) = self._cfg.buffers [name] {
            un
        } else {
            log::error #("DescriptorSet", "Set buffer impossible :", name);
            return;               
        }

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                            
            let mut bufferInfo = VkDescriptorBufferInfo ();
            bufferInfo.buffer = ubo.getBuffer ().getVulkanBuffer ();
            bufferInfo.offset = 0;
            bufferInfo.range = cast!u64 (ubo.getBuffer ().getSize ());

            let mut descWrite = VkWriteDescriptorSet ();
            descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descWrite.dstSet = self._set [i];
            descWrite.dstBinding = un.binding;
            descWrite.dstArrayElement = 0;
            descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
            descWrite.descriptorCount = 1;
            descWrite.pBufferInfo = &bufferInfo;

            vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          OUTPUT TEXTURE          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Bind a storage texture
     * @params:
     *    - name: the name of the uniform value to bind
     *    - texture: the texture to bind (assuming it's a write texture, e.g. ColorTexture)
     * */
    pub fn setStorageTexture (mut self, name : [c8], texture : &Texture, frame : i32 = -1) {        
        let un = if let Ok (un) = self._cfg.storageTextures [name] {
            un
        } else {
            log::error #("DescriptorSet", "Set storage texture impossible :", name);
            return;                       
        }

        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {            
            let mut imageInfo = VkDescriptorImageInfo ();
            imageInfo.imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_GENERAL; 

            if let outTex : &OutputTexture = texture {
                imageInfo.imageView = outTex.getImageViews ()[i];
            } else {
                imageInfo.imageView = texture.getImageView ();
            }
            
            let mut descWrite = VkWriteDescriptorSet ();
            descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descWrite.dstSet = self._set [i];
            descWrite.dstBinding = un.binding;

            descWrite.dstArrayElement = 0;
            descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
            descWrite.descriptorCount = 1;
            descWrite.pImageInfo = &imageInfo;

            vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);                
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          SAMPLE TEXTURE          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Bind a texture     
     * */
    pub fn setTexture (mut self, name : [c8], texture : &Texture, frame : i32 = -1) {
        let un = if let Ok (un) = self._cfg.textures [name] {
            un
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                   
        }
        
        let sampler = if let Ok (sampler) = self._samplers [name] {
            sampler 
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                                   
        }
        
        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {                                                                            
            { // write image view                

                let mut imageInfo = VkDescriptorImageInfo ();                
                if un.kind == TextureKind::DEPTH {
                    imageInfo.imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
                } else {
                    imageInfo.imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
                } 

                if let outTex : &OutputTexture = texture {
                    imageInfo.imageView = outTex.getImageViews ()[i];
                } else {
                    imageInfo.imageView = texture.getImageView ();
                }

                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.binding;                
                
                // image and sample are bound in two different layout bindings
                if un.binding == un.sampler {
                    imageInfo.sampler = sampler;
                    descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
                } else {
                    descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
                } 
                
                descWrite.dstArrayElement = 0;                
                descWrite.descriptorCount = 1;
                descWrite.pImageInfo = &imageInfo;

                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
            }

            if un.binding != un.sampler { // Write sampler only
                let mut imageInfo = VkDescriptorImageInfo (); 
                imageInfo.sampler = sampler;

                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.sampler;                

                descWrite.dstArrayElement = 0;
                descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
                descWrite.descriptorCount = 1;
                descWrite.pImageInfo = &imageInfo;

                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);                
            }
        }
    }
    
    /**
     * Bind a texture array
     * */
    pub fn setTextureArray (mut self, name : [c8], textures : [&Texture], frame : i32 = -1) {
        let un = if let Ok (un) = self._cfg.textures [name] {
            un
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                   
        }
        
        let sampler = if let Ok (sampler) = self._samplers [name] {
            sampler 
        } else {
            log::error #("DescriptorSet", "Set sampler texture impossible :", name);
            return;                                                   
        }        
        
        let dmut device = self._shader:.getDevice ();
        let mut start = 0u32, mut end = device:.getSwapchain ().nbFrames;
        if frame != -1 {
            start = cast!u32 (frame);
            end = cast!u32 (frame + 1);
        }
        
        for i in start .. end {
            {  // write image view
                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.binding;

                let dmut imageInfo = copy [VkDescriptorImageInfo () ; textures.len];                
                for t in 0 .. textures.len {
                    if un.kind == TextureKind::DEPTH {
                        imageInfo [t].imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
                    } else {
                        imageInfo [t].imageLayout = VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
                    } 

                    if let outTex : &OutputTexture = textures [t] {
                        imageInfo [t].imageView = outTex.getImageViews ()[i];
                    } else {
                        imageInfo [t].imageView = textures [t].getImageView ();
                    }                                                    

                    if un.binding == un.sampler {
                        imageInfo [t].sampler = sampler;
                        descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
                    } else {
                        descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
                    }
                }
                
                descWrite.dstArrayElement = 0;                
                descWrite.descriptorCount = cast!u32 (imageInfo.len);
                descWrite.pImageInfo = imageInfo.ptr;
                
                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);
            }

            if un.binding != un.sampler { // Write sampler only
                let mut imageInfo = VkDescriptorImageInfo (); 
                imageInfo.sampler = sampler;

                let mut descWrite = VkWriteDescriptorSet ();
                descWrite.sType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descWrite.dstSet = self._set [i];
                descWrite.dstBinding = un.sampler;                

                descWrite.dstArrayElement = 0;
                descWrite.descriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
                descWrite.descriptorCount = 1;
                descWrite.pImageInfo = &imageInfo;

                vkUpdateDescriptorSets (device.getDeviceHandle (), 1, &descWrite, 0, null);                
            }            
        }    
    }
                                                                                                
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the samplers for the textures of the shader
     * */
    pub fn createSamplers (mut self)
        throws BalderError
    {
        if self._cfg.textures.len == 0 {
            return;
        }
        
        let dmut device = self._shader:.getDevice ();
        let dmut properties = VkPhysicalDeviceProperties ();
        vkGetPhysicalDeviceProperties (device.getPhysicalDeviceHandle (), alias &properties);

        for name, info in self._cfg.textures {
            let mut samplerInfo = VkSamplerCreateInfo ();
            samplerInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;

            if info.kind == TextureKind::DEPTH {
                samplerInfo.magFilter = VkFilter::VK_FILTER_NEAREST;
		        samplerInfo.minFilter = VkFilter::VK_FILTER_NEAREST;
                
		        samplerInfo.mipmapMode = info.mipmapMode;                
		        samplerInfo.addressModeU = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
		        samplerInfo.addressModeV = samplerInfo.addressModeU;
		        samplerInfo.addressModeW = samplerInfo.addressModeU;
                
		        samplerInfo.mipLodBias = 0.0f;
		        samplerInfo.maxAnisotropy = 1.0f;
		        samplerInfo.minLod = 0.0f;
		        samplerInfo.maxLod = 1.0f;
		        samplerInfo.borderColor = VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;
                
            } else {
                if info.anisotropyEnable { samplerInfo.anisotropyEnable = VK_TRUE; }                
                if info.unnormalizedCoordinates { samplerInfo.unnormalizedCoordinates = VK_TRUE; }                
                if info.compareEnable { samplerInfo.compareEnable = VK_TRUE; }                

                samplerInfo.maxAnisotropy = std::algorithm::comparison::min (info.maxAnisotropy, properties.limits.maxSamplerAnisotropy);
                samplerInfo.borderColor = info.borderColor;

                samplerInfo.compareOp = info.compareOp;
                samplerInfo.mipmapMode = info.mipmapMode;

                samplerInfo.magFilter = info.magFilter;
                samplerInfo.minFilter = info.minFilter;
                samplerInfo.addressModeU = info.addressModeU;
                samplerInfo.addressModeV = info.addressModeV;
                samplerInfo.addressModeW = info.addressModeW;
            }
            
            let dmut sampler : VkSampler = null;
            if (vkCreateSampler (device.getDeviceHandle (), &samplerInfo, null, &sampler) != VkResult::VK_SUCCESS) {
                throw copy BalderError ("Failed to create texture sampler for texture " ~ name);
            }

            self._samplers [name] = alias sampler;
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Use the descriptor set for the drawing of the next frame
     */
    pub fn select (self, frame : u32, cmd : VkCommandBuffer) {        
        let pipeline = self._shader.getPipelineLayout ();        
        let current = self._set [frame];

        vkCmdBindDescriptorSets (cmd,
                                 self._shader.getBindPoint (),                                 
                                 pipeline.getVulkanHandle (),
                                 self._cfg.id,
                                 1u32,
                                 &current,
                                 0u32,
                                 null);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if self._samplers.len != 0 {
                for _, dmut sampler in alias self._samplers {
                    vkDestroySampler (self._shader:.getDevice ().getDeviceHandle (), sampler, null);
                }

                self._samplers = copy [];
            }            

            if self._poolId != 0us {
                self._shader:.getDevice ():.getDescriptorAllocator ():.deallocate (self._poolId, alias self._set);
                self._set = [];
                self._poolId = 0;
            }
        }
    }

}
