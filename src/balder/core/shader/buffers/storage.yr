in storage;

use balder::core::{error, dispose, memory::_, driver::_};
use ::vulkan::_;
use std::{io, stream};


/**
 * Ancestor of all storage buffers
 */
@final
pub class StorageBufferObject {

    // The buffers containing the storage values, one per frame in flight
    let dmut _storageBuffers : (&DynamicBuffer)? = none;

    /**
     * Create an empty ubo
     */
    pub self (dmut device : &VulkanDevice, size : usize)
        throws BalderError
    {
        let dmut buffer = device:.getMemoryAllocator ():.allocDynamicBuffer (
            size,
            cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_BUFFER_BIT),
            cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                      VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

        self._storageBuffers = (alias buffer)?;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn getBuffer (mut self)-> dmut &DynamicBuffer {
        if let Ok (dmut d) = alias self._storageBuffers {
            return alias d;
        }

        panic;
    }

    pub fn getBuffer (self)-> &DynamicBuffer {
        if let Ok (d) = self._storageBuffers {
            return d;
        }

        panic;
    }

    pub fn getSize (self)-> usize {
        if let Ok (d) = self._storageBuffers {
            return d.getSize ();
        }

        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          UPDATING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the data of the storage buffer
     * */
    pub fn setData {U} (mut self, offset : usize, data : U, commit : bool = true) {
        // for dmut buf in alias self._storageBuffers {
        if let Ok (dmut d) = alias self._storageBuffers {            
            d:.setData!{U} (offset, data, commit-> commit);
        }
    }

    /**
     * Update the data of the storage buffer
     * */
    pub fn setData {T of [U], U} (mut self, offset : usize, data : T, commit : bool = true) {
        // for dmut buf in alias self._storageBuffers {
        if let Ok (dmut d) = alias self._storageBuffers {
            d:.setData!{T} (offset, data, commit-> commit);
        }
    }

    pub fn copyData (mut self, srcOffset : usize, dstOffset : usize, size : usize, other : &storage::StorageBufferObject, commit : bool = true) {
        if let Ok (dmut d) = alias self._storageBuffers {
            if let Ok (o) = other._storageBuffers {
                d:.copyData (srcOffset, dstOffset, size, o, commit-> commit);
            }
        }
    }

    pub fn forceCommit (mut self) {
        if let Ok (dmut d) = alias self._storageBuffers {
            d:.forceCommit ();
        }
    }

    /**
     * @returns: data from the storage buffer
     * */
    pub fn getData {U} (self, offset : usize)-> U {
        if let Ok (d) = self._storageBuffers {
            return d.getData!{U} (offset);
        }

        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write ("STORAGE (");
            if let Ok (o) = self._storageBuffers {
                stream:.write (o);
            }
            stream:.write (")");
        }
    }

    impl Disposable {
        pub over dispose (mut self) {
            //for dmut uni in alias self._storageBuffers {
            if let Ok (dmut uni) = alias self._storageBuffers {
                uni:.dispose ();
                self._storageBuffers = none;
            }
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}
