in ubo;

use balder::core::{error, dispose, memory::_, driver::_};
use vulkan::_;

/**
 * Ancestor of all uniform buffers
 */
@abstract
pub class UniformBufferObject {

    // The buffers containing the uniform values, one per frame in flight
    let mut _uniformBuffers : [dmut &Buffer] = [];

    /**
     * Create an empty ubo
     */
    prot self () {}

    pub fn getBuffers (mut self)-> dmut [&Buffer] {
        alias self._uniformBuffers
    }

    pub fn update {record UN} (mut self, data : UN) {
        if let dmut u : &UniformBufferObject!{UN} = alias self {
            u:.update (data);
        }
    }

    impl Disposable {
        pub over dispose (mut self) {
            for dmut uni in alias self._uniformBuffers {
                uni:.dispose ();
            }

            self._uniformBuffers = [];
        }
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}

/**
 * @template:
 *      - T: the structure describing the material
 */
pub class UniformBufferObject {record T} over UniformBufferObject {

    /**
     * Create a material and all its buffers
     */
    pub self (dmut device : &VulkanDevice)
        throws BalderError
    {
        for _ in 0 .. device.getSwapchainNbFrames () {
            let dmut buffer = device:.getMemoryAllocator ():.allocBuffer (
                T::size,
                cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT),
                cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                          VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

            self._uniformBuffers ~= [alias buffer];
        }
    }

    pub fn update (mut self, data : T) {
        for dmut buf in alias self._uniformBuffers {
            buf:.copyMappedData (&data);
        }
    }


}
