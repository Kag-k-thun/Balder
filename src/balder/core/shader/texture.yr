in texture;

use balder::core::{_, driver::_, memory::_};
use balder::utils::log;

use vulkan::_;
use std::config::_;

use sdl2::{image, surface, pixels};

extern (C) fn memcpy (src : *void, dst : *void, size : usize);

@abstract
pub class Texture {

    let dmut _device : &VulkanDevice;

    // The image view used to bind the texture in shaders
    let dmut _imageView : VkImageView = null;

    prot self (dmut device : &VulkanDevice)
        with _device = alias device
    {}

    /**
     * @returns: the image view of the texture used to bind to descriptor sets
     * */
    pub fn getImageView (mut self)-> dmut VkImageView {
        alias self._imageView
    }

    impl Disposable;
    __dtor (mut self) {
        self:.dispose ();
    }
}

@final
pub class Texture2D over Texture {

    // The width of the texture image
    let mut _width : u32 = 0;

    // The height of the texture image
    let mut _height : u32 = 0;

    // The vulkan image of the texture
    let dmut _image : (&Image2D)? = none;

    pub self (dmut device : &VulkanDevice, filename : [c8])
        with super (alias device)
        throws BalderError
    {
        self:.configure (filename);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the texture from a
     * */
    fn configure (mut self, filename : [c8])
        throws BalderError
    {
        self:.loadFile (filename);
        self:.createImageView ();
    }

    /**
     * Create the image view used to attach the texture to a descriptor set
     * */
    fn createImageView (mut self)
        throws BalderError
    {
        if let Ok (dmut img) = alias self._image {
            let mut info = VkImageViewCreateInfo ();
            info.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            info.image = img:.getVulkanImage ();
            info.viewType = VkImageViewType::VK_IMAGE_VIEW_TYPE_2D;
            info.format = img.getFormat ();

            info.subresourceRange.aspectMask = VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT;
            info.subresourceRange.levelCount = 1;
            info.subresourceRange.layerCount = 1;
            info.components.r = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_R;
            info.components.g = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_G;
            info.components.b = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_B;
            info.components.a = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A;

            if vkCreateImageView (self._device:.getDeviceHandle (), &info, null, &self._imageView) != VkResult::VK_SUCCESS {
                throw copy BalderError ("Failed to create image view");
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          FILE LOADING          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a file image from a filename
     * @params:
     *    - filename: the project path to the file to load
     * */
    fn loadFile(mut self, filename : [c8])
        throws BalderError
    {
        let path = balder::utils::path::projectPath (filename);
        let dmut surf = IMG_Load (std::conv::toStringZ (path.toStr ()));
        if surf == null {
            throw copy BalderError ("Failed to load texture image : " ~ path.toStr ());
        }

        {
            self:.loadStagingBuffer (alias surf);
        } exit {
            SDL_FreeSurface (alias surf);
        }

    } catch {
        err => {
            throw copy BalderError (std::format::format ("Malformed image configuration =>\n\t{}", err));
        }
    }

    /**
     * Allocate the texture image
     * Load the pixel datas to a staging buffer and copy it to the image of the texture
     * */
    fn loadStagingBuffer (mut self, dmut surf : *SDL_Surface)
        throws BalderError
    {
        self._width = cast!u32 (unsafe { (*surf).w });
        self._height = cast!u32 (unsafe { (*surf).h });
        let datas = unsafe { (*surf).pixels };
        let sdlFormat = unsafe { (*(*surf).format).format };

        let (pixelSize, vulkanFormat) = match sdlFormat {
            pixels::SDL_PIXELFORMAT_RGBA32   => { (4u32, VkFormat::VK_FORMAT_R8G8B8A8_SRGB) }
            pixels::SDL_PIXELFORMAT_ARGB8888 => { (4u32, VkFormat::VK_FORMAT_R8G8B8A8_SRGB)  }
            pixels::SDL_PIXELFORMAT_RGB24   => { (4u32, VkFormat::VK_FORMAT_R8G8B8A8_SRGB) }
            pixels::SDL_PIXELFORMAT_BGR24    => { (4u32, VkFormat::VK_FORMAT_R8G8B8A8_SRGB) }
            _ => {
                throw copy BalderError (std::format::format ("Unknwon pixel format {} ", sdlFormat));
            }
        };

        let dmut image = self._device:.getMemoryAllocator ():.allocImage2D (self._width, self._height,
                                                                            vulkanFormat,
                                                                            VkImageTiling::VK_IMAGE_TILING_LINEAR,
                                                                            cast!u32 (VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_DST_BIT | VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLED_BIT),
                                                                            cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

        let dmut stagingBuf = self._device:.getMemoryAllocator ():.allocBuffer (
            cast!u64 ((self._width * self._height) * pixelSize),
            cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT),
            cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
                      VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT));

        {
            stagingBuf:.map ();
            match sdlFormat {
                pixels::SDL_PIXELFORMAT_RGBA32 => {
                    memcpy (stagingBuf:.getMapAddress (), datas, cast!usize ((self._width * self._height) * 4u32));
                }
                pixels::SDL_PIXELFORMAT_RGB24 => {
                    self.copy_RGB_to_RGBA (cast!{dmut *u8} (stagingBuf:.getMapAddress ()), cast!{*u8} (datas), self._width, self._height);
                }
                pixels::SDL_PIXELFORMAT_ARGB8888 => {
                    self.copy_ARGB_to_RGBA (cast!{dmut *u8} (stagingBuf:.getMapAddress ()), cast!{*u8} (datas), self._width, self._height);
                }
                pixels::SDL_PIXELFORMAT_BGR24 => {
                    self.copy_BGR_to_RGBA (cast!{dmut *u8} (stagingBuf:.getMapAddress ()), cast!{*u8} (datas), self._width, self._height);
                }
            }
            stagingBuf:.unmap ();

            image:.copyFrom (alias stagingBuf, VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT);
            self._image = (alias image)?;
            log::debug ("Image uploaded to device");
        } exit {
            stagingBuf:.dispose ();
        }
    }

    /**
     * Convert an image of bgr format to rgb format
     */
    fn copy_RGB_to_RGBA (self, dmut out : *u8, data : *u8, w : u32, h : u32) {
        let mut src = data;
        let dmut res = alias out;
        for _ in 0u32 .. (w * h) {
            unsafe {
                res [0] = src [2];
                res [1] = src [1];
                res [2] = src [0];
                res [3] = 255;
            }
            src += 3us;
            res = alias (res + 4us);
        }
    }

    /**
     * Convert an image of bgr format to rgb format
     */
    fn copy_BGR_to_RGBA (self, dmut out : *u8, data : *u8, w : u32, h : u32) {
        let mut src = data;
        let dmut res = alias out;
        for _ in 0u32 .. (w * h) {
            unsafe {
                res [0] = src [2];
                res [1] = src [1];
                res [2] = src [0];
                res [3] = 255;
            }
            src += 3us;
            res = alias (res + 4us);
        }
    }

    /**
     * Convert an image of argb format to rgba format
     */
    fn copy_ARGB_to_RGBA (self, dmut out : *u8, data : *u8, w : u32, h : u32) {
        let mut src = data;
        let dmut res = alias out;
        for _ in 0u32 .. (w * h) {
            unsafe {
                res [0] = src [1];
                res [1] = src [2];
                res [2] = src [3];
                res [3] = src [0];
            }
            src += 4us;
            res = alias (res + 4us);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if self._imageView != null {
                vkDestroyImageView (self._device:.getDeviceHandle (), self._imageView, null);
                self._imageView = null;
            }

            if let Ok (dmut img) = alias self._image {
                log::debug ("Disposing texture image");
                img:.dispose ();
                self._image = none;
            }
        }
    }

}
