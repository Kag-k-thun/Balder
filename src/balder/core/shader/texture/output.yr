in output;

use balder::core::{_, driver::_, memory::_};
use balder::utils::log;

use std::config::_;

use ::vulkan::core;
use ::sdl2::{image, surface, pixels};

@final
pub class IOutputTexture over Texture {

    // The format of the color buffer
    let mut _format : VkFormat;

    // The vulkan image of the texture
    let dmut _images : [&Image2D] = [];

    // The image views to bind the output textures
    let dmut _imageViews : [VkImageView] = [];

    let _depth : bool; 
    
    /**
     * Create a color texture of a given dimension
     * */
    pub self (dmut device : &VulkanDevice,
              format : VkFormat,
              width : u32,
              height : u32,
              forSubpass : bool = true,
              forStorage : bool = false,
              depth : bool = false,
              nbImages : u32? = none,
              numSamples : VkSampleCountFlagBits = VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT)

        with super (alias device, width, height)
        , _format = format
        , _depth = depth

        throws BalderError
    {
        self:.configure (numSamples, depth, forSubpass, forStorage, nbImages);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the color image
     * */
    fn configure (mut self, numSamples : VkSampleCountFlagBits, depth : bool, forSubpass : bool, forStorage : bool, nbImages : u32?)
        throws BalderError
    {
        self:.createImage (numSamples, depth, forSubpass, forStorage, nbImages);
        self:.createImageViews (depth);
    }

    /**
     * Allocate the texture image memory space
     * */
    fn createImage (mut self, numSamples : VkSampleCountFlagBits, depth : bool, forSubpass : bool, forStorage : bool, nbImages : u32?)
        throws BalderError
    {
        let mut usage : u32 = if depth {
            VkImageUsageFlagBits::VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 
        } else  {
            VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT 
        } ;

        if forSubpass {
            usage = usage | VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLED_BIT;
        }

        if forStorage {
             usage = usage | VkImageUsageFlagBits::VK_IMAGE_USAGE_STORAGE_BIT;
        }

        let nbImage = if let Ok (i) = nbImages { i } else { cast!u32 (self._device:.getSwapchain ().nbFrames) };
        
        self._images = copy [
            self._device:.getMemoryAllocator ():.allocImage2D (
                self._width, self._height,
                self._format,
                VkImageTiling::VK_IMAGE_TILING_OPTIMAL,
                usage,
                numSamples-> numSamples,
                VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
            for _ in 0 .. nbImage];        
    }

    /**
     * Create the image view to attach the texture to a rendering pass
     * */
    fn createImageViews (mut self, depth : bool)
        throws BalderError
    {
        self._imageViews = copy [null ; self._images.len];
        for i, img in self._images {            
            let mut info = VkImageViewCreateInfo ();
            info.sType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            info.image = img.getVulkanImage ();
            info.viewType = VkImageViewType::VK_IMAGE_VIEW_TYPE_2D;
            info.format = img.getFormat ();

            info.subresourceRange.aspectMask = if depth { VkImageAspectFlagBits::VK_IMAGE_ASPECT_DEPTH_BIT } else { VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT }; 
            info.subresourceRange.levelCount = 1;
            info.subresourceRange.layerCount = 1;

            info.components.r = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_R;
            info.components.g = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_G;
            info.components.b = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_B;
            info.components.a = VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A;
        
            if vkCreateImageView (self._device.getDeviceHandle (), &info, null, &self._imageViews [i]) != VkResult::VK_SUCCESS {
                throw copy BalderError ("Failed to create image view");
            }            
        }    
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    @field
    pub over format (self)-> VkFormat {
        self._format
    }

    /**
     * @returns: the list of image views of the ouput texture
     * */
    pub fn getImageViews (self)-> [VkImageView] {
        self._imageViews
    }

    /**
     * @returns: the images of the texture
     * */
    pub fn getImages (self)-> [&Image2D] {
        self._images
    }

    /**
     * @returns: the images of the texture
     * */
    pub fn getImages (mut self)-> dmut [&Image2D] {
        alias self._images
    }
    
    /**
     * @returns: true iif the output texture is a depth texture
     * */
    pub fn isDepth (self)-> bool {
        self._depth
    }
    
    /**
     * @panic
     * */
    pub over getImageView (self)-> VkImageView {
        log::error#("OutputTexture", "Output textures have multiple image views");
        
        panic;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    impl Disposable {
        pub over dispose (mut self) {
            for i in 0 .. self._images.len {
                if self._imageViews [i] != null {
                    vkDestroyImageView (self._device.getDeviceHandle (), self._imageViews [i], null);                    
                }
                
                log::debug #("OutputTexture", "Disposing texture");
                self._images [i]:.dispose ();                                                    
            }

            self._images = [];
            self._imageViews = [];
            self._width = 0;
            self._height = 0;
        }
    }

}
