in layout;

use balder::core::driver::device;
use balder::core::{error, dispose};
use balder::core::config::{_, shader::_};

use balder::core::shader::_;
use balder::math::vector;

use balder::utils::_;

use ::vulkan::core;

/**
 * Ancestor of all pipeline layout classes
 */
@final
pub class PipelineLayout {

    // The pipeline layout for vulkan shader
    let dmut _layout : VkPipelineLayout = null;

    // The descriptor set layout describing the uniform values that can be bound to the shader
    let dmut _descriptorSetLayout : [DescriptorContext => (u32, VkDescriptorSetLayout)] = copy [];
    
    // The device containing the pipeline layout
    let dmut _device : &VulkanDevice ;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self  (dmut device : &VulkanDevice)
        with _device = alias device
    {}

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn configure (mut self, config : &ShaderConfig)
        throws BalderError
    {
        self:.createDescriptorSetLayouts (config);
        self._layout = self:.createPipelineLayout (config);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the vulkan handle of the pipeline layout
     */
    pub fn getVulkanHandle (self)-> VkPipelineLayout {
        self._layout
    }

    /**
     * @returns: the descriptor set layout usable for descriptor set allocation
     */
    pub fn getDescriptorSetLayout (self, context : DescriptorContext)-> VkDescriptorSetLayout {
        if let Ok (d) = self._descriptorSetLayout [context] {
            return d._1;
        }

        log::error #("PipelineLayout", "Layout doesn't have the right context");
        panic;
    }
    
    /**
     * @returns: the device used by the pipeline layout
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Create the descriptor set layout for the given T template struct
     * @returns: the descriptor set layout
     */
    fn createDescriptorSetLayouts (mut self, config : &ShaderConfig)
        throws BalderError
    {
        for ctx, s in config.descSet {
            self._descriptorSetLayout [ctx] = (s.id, self.createDescriptorLayout (s));
        }
    }

    /**
     * Create a descriptor set for a sub desc set
     * */
    fn createDescriptorLayout (self, config : DescriptorSetConfig)-> dmut VkDescriptorSetLayout
        throws BalderError
    {
        let dmut descs = copy [VkDescriptorSetLayoutBinding () ; config.size.len];
                                   
        let mut i = 0us;
        for _, u in config.uniforms {
            let mut desc = VkDescriptorSetLayoutBinding ();
            desc.descriptorCount    = 1;
            desc.descriptorType     = VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            desc.stageFlags         = u.stage;
            desc.binding            = u.binding;
            descs [i] = desc;
            i += 1;
        }
        
        for _, u in config.buffers {
            let mut desc = VkDescriptorSetLayoutBinding ();
            desc.descriptorCount    = 1;
            desc.descriptorType     = VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
            desc.stageFlags         = u.stage;
            desc.binding            = u.binding;
            descs [i] = desc;
            i += 1;
        }

        for _, u in config.textures {
            let mut desc = VkDescriptorSetLayoutBinding ();
            desc.descriptorCount    = 1;
            desc.descriptorType     = VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
            desc.stageFlags         = u.stage;
            desc.binding            = u.binding;
            descs [i] = desc;
            i += 1;
        }

        for _, u in config.storageTextures {
            let mut desc         = VkDescriptorSetLayoutBinding ();
            desc.descriptorCount = 1;
            desc.descriptorType  = VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;            
            desc.stageFlags      = u.stage;
            desc.binding         = u.binding;
            descs [i]             = desc;
            i += 1;
        }
        
        let mut layoutInfo = VkDescriptorSetLayoutCreateInfo ();
        layoutInfo.sType        = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
        layoutInfo.bindingCount = cast!u32 (descs.len);
        layoutInfo.pBindings    = descs.ptr;        

        let dmut descSet : VkDescriptorSetLayout = null;
        if (vkCreateDescriptorSetLayout (self._device.getDeviceHandle (), &layoutInfo, null, alias &descSet) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create descriptor set layout");
        }

        return alias descSet;
    }

    /**
     * Create the pipeline layout from self._descriptorSetLayout
     */
    prv fn createPipelineLayout (mut self, cfg : &ShaderConfig)-> dmut VkPipelineLayout
        throws BalderError
    {
        let mut activateStages = 0u32;
        match cfg {
            raster : &RasterShaderConfig => {            
                for _, p in raster.passes {
                    activateStages = activateStages | p.stage;
                }
            }
            _ : &ComputeShaderConfig => {
                activateStages = VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT;                
            }
            _ => {
                log::error #("PipelineLayout", "??");
                panic;
            }
        }  
        
        let mut range = VkPushConstantRange ();
        range.offset = 0;
        range.size = cfg.pushConstant.size;
        range.stageFlags = activateStages; 

        let mut sets : [mut VkDescriptorSetLayout] = copy [null ; self._descriptorSetLayout.len];
        for _, s in self._descriptorSetLayout {
            sets [s._0] = s._1;
        }        
        
        let dmut layout : VkPipelineLayout = null;
        let mut pipelineLayoutInfo = VkPipelineLayoutCreateInfo ();
        pipelineLayoutInfo.sType                  = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
        pipelineLayoutInfo.setLayoutCount         = cast!u32 (sets.len);
        pipelineLayoutInfo.pSetLayouts            = sets.ptr;

        if cfg.pushConstant.size != 0 {
            pipelineLayoutInfo.pushConstantRangeCount = 1u32;
            pipelineLayoutInfo.pPushConstantRanges = &range; 
        }
                
        if (vkCreatePipelineLayout (self._device.getDeviceHandle (), &pipelineLayoutInfo, null, alias &layout) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create pipeline layout.");
        }
        
        return alias layout;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            for _, set in self._descriptorSetLayout {                
                vkDestroyDescriptorSetLayout (self._device.getDeviceHandle (), set._1, null);                
            }
            self._descriptorSetLayout = copy [];
        
            if (self._layout != null) {
                vkDestroyPipelineLayout (self._device.getDeviceHandle (), self._layout, null);
                self._layout = null;
            }
        }        
    }

}
