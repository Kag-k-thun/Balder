in compute;

use balder::core::{_,
                   application::_,
                   config::_,
                   shader::_,
                   driver::_};

use balder::utils::_;
use balder::math::vector;

use ::vulkan::core;
use std::{conv, fs::_};


/**
 * A shader used to include only one compute pass
 * */
pub class ComputeShader over Shader {

    let mut _groupSize : [u32 ; 3] = [1 ; 3];
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice)
        with super (alias device, VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_COMPUTE)
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the size of the local groups in the shader
     * */
    pub fn getGroupSizes (self)-> [u32 ; 3] {
        if let Ok (cfg) = self._cfg {
            return cfg.getGroupSizes ();
        }

        [0 ; 3]
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CONFIGURE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure a shader from a toml file
     * */
    pub fn configure (mut self, file : [c8])
        throws BalderError
    {
        let cfg = copy ShaderConfig (file);
        self:.configure (file, cfg)
    }

    /**
     * Configure a shader from a shader configuration
     * @params:
     *    - name: the name of the shader to configure
     *    - cfg: the configuration of the shader
     * */
    pub fn configure (mut self, name : [c8], cfg : &ShaderConfig)
        throws BalderError
    {
        name;
        log::debug #("ComputeShader", "Configure shader from", name);
        self:.dispose ();
                
        if cfg.getPasses ().len != 1 {
            throw copy BalderError ("Compute shader requires exactly one compute stage");
        }

        self._super_:.configure (cfg);        
        self._pipelineLayout:.configure (cfg);                
        let mut module : mut VkShaderModule = null;
        {
            let p = cfg.getPasses ()[0];            
            let stageContent = self.readFile (balder::utils::path::projectPath (p.shaderFile));
            module = self:.createShaderModule (stageContent);
            
            let mut info = VkPipelineShaderStageCreateInfo ();
            info.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
            info.stage = VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT;
            info.module = module;
            info.pName = std::conv::toStringZ (p.mainFunc);            
            
            self._program = self:.createPipeline (cfg, info);
        } exit {
            if module != null {
                vkDestroyShaderModule (self._device.getDeviceHandle (), module, null);            
            }
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          MODULE CREATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */


    fn createPipeline (mut self, cfg : &ShaderConfig, stage : VkPipelineShaderStageCreateInfo)-> dmut VkPipeline
        throws BalderError
    {
        cfg;
        let mut pipelineInfo = VkComputePipelineCreateInfo ();
        pipelineInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
        pipelineInfo.layout = self._pipelineLayout.getVulkanHandle ();
        pipelineInfo.stage = stage;

        let dmut pipeline : VkPipeline = null;
        if (vkCreateComputePipelines (self._device.getDeviceHandle (), null, 1u32, &pipelineInfo, null, alias &pipeline) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create compute pipeline");
        }

        alias pipeline
    }
        
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._pipelineLayout:.dispose ();
            if (self._program != null) {
                vkDestroyPipeline (self._device.getDeviceHandle (), self._program, null);
                self._program = null;
            }

            self._cfg = none;
        }
    }
    
}
