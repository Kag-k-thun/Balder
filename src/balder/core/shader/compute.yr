in compute;


/**
 * A shader used to include only one compute pass
 * */
pub class ComputeShader over Shader {

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice)
        with super (alias device)
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CONFIGURE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure a shader from a toml file
     * */
    pub fn configure (mut self, file : [c8])
        throws BalderError
    {
        let cfg = copy ShaderConfig (file);
        self:.configure (file, cfg)
    }

    /**
     * Configure a shader from a shader configuration
     * @params:
     *    - name: the name of the shader to configure
     *    - cfg: the configuration of the shader
     * */
    pub fn configure (mut self, name : [c8], cfg : &ShaderConfig)
        throws BalderError
    {
        name;
        log::debug #("ComputeShader", "Configure shader from", name);
        self:.dispose ();

        self._uniformInfos = (cfg.getUniforms ())?;
        self._textureInfos = (cfg.getTextures ())?;
        self._textureStorageInfos = (cfg.getStorageTextures ())?;

        if cfg.getPasses ().len != 1 {
            throw copy BalderError ("Compute shader requires exactly one compute stage");
        }
        
        self._pipelineLayout:.configure (cfg);        
        let dmut stage = VkPipelineShaderStageCreateInfo ();
        let mut module ; mut VkShaderModule = null;
        {
            let p = cfg.getPasses ()[0];            
            let stageContent = self.readFile (balder::utils::path::projectPath (p.shaderFile));
            module = self:.createShaderModule (stageContent);

            let mut info = VkPipelineShaderStageCreateInfo ();
            info.sType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
            info.stage = p.stage;
            info.module = modules [i];
            info.pName = std::conv::toStringZ (p.mainFunc);            
            
            self._program = self:.createPipeline (cfg, stage);
        } exit {
            if module != null {
                vkDestroyShaderModule (self._device.getDeviceHandle (), module, null);            
            }
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          MODULE CREATION          =================================
     * ====================================================================================================
     * ====================================================================================================
     */


    fn createPipeline (mut self, cfg : &ShaderConfig, stage : VkPipelineShaderStageCreateInfo, renderPass : VkRenderPass, extent : VkExtent2D, forSubPass : bool, outTextures : [&Texture])-> dmut &VkPipeline
        throws BalderError
    {
        let mut pipelineInfo = VkComputePipelineCreateInfo ();
        pipelineInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
        pipelineInfo.layout = self._pipelineLayout.getVulkanHandle ();
        pipelineInfo.stage = stage;

        let dmut pipeline : VkPipeline = null;
        if (vkCreateComputePipelines (self._device.getDeviceHandle (), null, 1u32, &pipelineInfo, null, alias &pipeline) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create compute pipeline");
        }

        alias pipeline
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._pipelineLayout:.dispose ();
            if (self._program != null) {
                vkDestroyPipeline (self._device.getDeviceHandle (), self._program, null);
                self._program = null;
            }

            self._uniformInfos = none;
            self._textureInfos = none;
        }
    }
    
}
