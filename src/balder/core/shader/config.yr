in config;

use balder::core::error;
use vulkan::_;
use std::{config::_, fs::_};

use balder::math::_;

pub record UniformInfo {
    pub let mut binding : u32 = 0;
    pub let mut size : u64 = 0;
    pub let mut stage : VkShaderStageFlags = VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS;
    pub self () {}
}

pub record TextureInfo {
    pub let mut binding : u32 = 0;
    pub let mut stage : VkShaderStageFlags = VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS;
    pub self () {}
}

pub record ShaderPass {
    pub let mut stage : VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
    pub let mut mainFunc : [c8] = "main";
    pub let mut shaderFile : [c8] = "";

    pub self () {}
}

@final
pub class ShaderConfig {
    let dmut _passes : [ShaderPass] = [];
    let dmut _uniforms : [[c8] => UniformInfo] = copy [];
    let dmut _textures : [[c8] => TextureInfo] = copy [];

    pub self (config : [c8])
        throws BalderError
    {
        let dmut file = File::open (balder::utils::path::projectPath (config));
        let cfg = std::config::toml::parse (file:.readAll ());

        if let Ok (d : &Dict) = cfg ["pass"]? {
            self._passes = copy [ShaderPass () ; d[].len];
            for p, c in d[] {
                let mut sh = ShaderPass ();
                sh.stage = self.selectStage (p);
                sh.mainFunc = if let Ok (Str (value-> v)) = c ["function"]? { v } else { "main" };
                sh.shaderFile = c ["shader"].to![c8] ();
                let index = c ["index"].to!{u32} ();

                self._passes [index] = sh;
            }
        }

        if let Ok (d : &Dict) = cfg ["uniform"]? {
            for p, c in d[] {
                let mut un = UniformInfo ();
                un.binding = c ["binding"].to!{u32} ();
                un.size = c ["size"].to!{u64} ();
                un.stage = self.selectUniformStage (if let Ok (Str (value-> v)) = c ["stage"]? { v } else { "A" });

                self._uniforms [p] = un;
            }
        }

        if let Ok (d : &Dict) = cfg ["texture"]? {
            for p, c in d[] {
                let mut un = TextureInfo ();
                un.binding = c ["binding"].to!{u32} ();
                un.stage = self.selectUniformStage (if let Ok (Str (value-> v)) = c ["stage"]? { v } else { "A" });

                self._textures [p] = un;
            }
        }
    } catch {
        err => {
            throw copy BalderError (std::format::format ("Failed to read shader configuration file => \n\t{}", err));
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn getUniforms (self)-> [[c8] => UniformInfo] {
        self._uniforms
    }

    pub fn getTextures (self)-> [[c8] => TextureInfo] {
        self._textures
    }

    pub fn getPasses (self)-> [ShaderPass] {
        self._passes
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn selectStage (self, stage : [c8])-> VkShaderStageFlagBits
        throws BalderError
    {
        match stage {
            "vertex" => { VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT }
            "fragment" => { VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT }
            "geometry" => { VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT }
            "compute" => { VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT }
            "tessel_ctrl" => { VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT }
            "tessel_eval" => { VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT }
            _ => {
                throw copy BalderError ("Unknwon shader stage " ~ stage);
            }
        }
    }

    fn selectUniformStage (self, name : [c8])-> VkShaderStageFlags
        throws BalderError
    {
        let mut stage : u32 = 0u32;
        for i in 0 .. name.len {
            match name [i] {
                'f' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT); }
                'v' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT); }
                'g' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT); }
                'c' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT); }
                'a' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS); }
                'A' => { stage = stage | cast!u32 (VkShaderStageFlagBits::VK_SHADER_STAGE_ALL); }
                _ => { throw copy BalderError ("Unknwon uniform shader stage " ~ name [i .. i + 1]); }
            }
        }

        stage
    }

}


/**
 * @returns: the format that can be used for the type V
 * @static_assert: if type V is not supported
 */
pub fn getFormat {T, V} ()-> VkFormat {
    cte if (is!{V}{U of vec4}) {
        VkFormat::VK_FORMAT_R32G32B32A32_SFLOAT
    } else cte if (is!{V}{U of vec3}) {
        VkFormat::VK_FORMAT_R32G32B32_SFLOAT
    } else cte if (is!{V}{U of vec2}) {
        VkFormat::VK_FORMAT_R32G32_SFLOAT
    } else cte if (is!{V}{U of f32}) {
        VkFormat::VK_FORMAT_R32_SFLOAT
    } else cte if (is!{V}{U of ivec4}) {
        VkFormat::VK_FORMAT_R32G32B32A32_SINT
    } else cte if (is!{V}{U of ivec3}) {
        VkFormat::VK_FORMAT_R32G32B32_SINT
    } else cte if (is!{V}{U of ivec2}) {
        VkFormat::VK_FORMAT_R32G32_SINT
    } else cte if (is!{V}{U of i32}) {
        VkFormat::VK_FORMAT_R32_SINT
    } else {
        cte assert (false, "Field of type : " ~ (V)::typeid ~ " in type " ~ T::typeid ~ " is unsable as a shader input");
    }
}
