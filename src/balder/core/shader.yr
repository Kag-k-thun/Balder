in shader;


pub mod ::buffers;
pub mod ::layout;
pub mod ::desc_set;

pub mod ::texture;

mod ::raster;
mod::compute;

use balder::core::{_,
                   application::_,
                   config::_,
                   shader::_,
                   driver::_};

use balder::math::vector;

use ::vulkan::core;
use std::{conv, fs::_};

/**
 * Ancestor of all kind of shaders
 */
@abstract
pub class Shader {

    // The vulkan device holding the shader
    let dmut _device : &VulkanDevice;

    // The layout of the shader
    let dmut _pipelineLayout : &PipelineLayout;

    // The configuration of the shader
    let mut _cfg : (&ShaderConfig)? = none;

    // The activated stages of the shader
    let mut _activateStages : u32 = 0;
    
    // The vulkan handle
    let mut _program : VkPipeline = null;

    let _bindPoint : VkPipelineBindPoint;

    // The descriptor set size
    let mut _descSetSize : [VkDescriptorType] = [];
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut device : &VulkanDevice, bindPoint : VkPipelineBindPoint)
        with _device = alias device
        , _pipelineLayout = copy PipelineLayout (alias device)
        , _bindPoint = bindPoint
    {}

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the device used by the shader
     */
    pub fn getDevice (mut self)-> dmut &VulkanDevice {
        alias self._device
    }

    /**
     * @returns: the pipeline layout of the shader
     */
    pub fn getPipelineLayout (mut self)-> dmut &PipelineLayout {
        alias self._pipelineLayout
    }

    /**
     * @returns: the device used by the shader
     */
    pub fn getDevice (self)-> &VulkanDevice {
        self._device
    }

    /**
     * @returns: the pipeline layout of the shader
     */
    pub fn getPipelineLayout (self)-> &PipelineLayout {
        self._pipelineLayout
    }

    /**
     * @returns: the bind point of the shader
     * */
    pub fn getBindPoint (self)-> VkPipelineBindPoint {
        self._bindPoint
    }

    pub fn getActivatedStages (self)-> u32 {
        self._activateStages
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          UNIFORM/TEXTURES          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the information about an uniform field
     * */
    pub fn getUniformInfo (self, name : [c8])-> (UniformInfo)? {
        if let Ok (cfg) = self._cfg {
            return cfg.getUniforms () [name];
        }

        none
    }

    /**
     * @returns: the information about an buffer field
     * */
    pub fn getBufferInfo (self, name : [c8])-> (BufferInfo)? {
        if let Ok (cfg) = self._cfg {
            return cfg.getBuffers () [name];
        }

        none
    }

    /**
     * @returns: the information about an texture sampler field
     * */
    pub fn getTextureInfo (self, name : [c8])-> (TextureInfo)? {
        if let Ok (cfg) = self._cfg {
            return cfg.getTextures () [name];
        }

        none
    }

    /**
     * @returns: the information about an texture sampler field
     * */
    pub fn getTextureInfos (self)-> [[c8] => TextureInfo]? {
        if let Ok (cfg) = self._cfg {
            return (cfg.getTextures ())?;
        }

        none
    }

    
    /**
     * @Â¶eturns: the size of the push constant range
     * */
    pub fn getPushConstantSize (self)-> u32 {
        if let Ok (cfg) = self._cfg {
            return cfg.getPushConstantSize ();
        }
        
        0u32
    }

    /**
     * @returns: the information about a push constant in the shader
     * */
    pub fn getPushConstantInfo (self, name : [c8])-> (PushConstantInfo)? {
        if let Ok (cfg) = self._cfg {
            return cfg.getPushConstants () [name];
        }

        none
    }
    
    /**
     * @returns: the information about an texture storage field
     * */
    pub fn getTextureStorageInfo (self, name : [c8])-> (TextureInfo)? {
        if let Ok (cfg) = self._cfg {
            return cfg.getStorageTextures () [name];
        }

        none
    }

    /**
     * @returns: the number of image sampler in the shader
     * */
    pub fn getNbTextures (self)-> usize {
        if let Ok (cfg) = self._cfg {
            return cfg.getTextures ().len;
        }

        0
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          UNIFORM          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Allocate a descriptor set to bind uniform values to the shader
     * */
    pub fn allocateDescriptorSet (mut self)-> dmut &DescriptorSet
        throws BalderError
    {
        let (poolId, dmut sets) = alias self._device:.getDescriptorAllocator ():.allocate (self._pipelineLayout.getDescriptorSetLayout (),
                                                                                           self._descSetSize);

        
        let dmut s = copy DescriptorSet (alias self,                                                                                   
                                         poolId,                                         
                                         alias sets);
        s:.createSamplers ();

        alias s
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          SELECTION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Use the shader for the next drawings
     */
    pub fn select (self, cmd : VkCommandBuffer) {
        vkCmdBindPipeline (cmd, self._bindPoint, self._program);    
    }   

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn configure (mut self, cfg : &ShaderConfig) {
        self._cfg = (cfg)?;

        let mut res : [VkDescriptorType] = [];                    
        res ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER ; cfg.getUniforms ().len];                        
        res ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER ; cfg.getBuffers ().len];                                    
        res ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER ; cfg.getTextures ().len];                                    
        res ~= copy [VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_IMAGE ; cfg.getStorageTextures ().len];                    

        self._descSetSize = res;
        self._activateStages = 0;
        
        for _, p in cfg.getPasses () {
            self._activateStages = self._activateStages | p.stage;
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          MISCELLANEAOUS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @returns: the content of a shader file
     */
    prot fn readFile (self, src : Path)-> [u8]
        throws BalderError
    {
        {
            let dmut f = File::open (src);
            f:.readBytesAll ()
        } catch {
            _ => throw copy BalderError ("Shader file not found : " ~ src.toStr ());
        }
    }

    /**
     * Create a shader module from bytecode of the shader
     * @returns: the shader module
     */
    prot fn createShaderModule (mut self, bytecode : [u8])-> VkShaderModule
        throws BalderError
    {
        let mut createInfo = VkShaderModuleCreateInfo ();
        createInfo.sType = VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
        createInfo.codeSize = bytecode.len;
        createInfo.pCode = cast!{*u32} (cast!{*void} (bytecode.ptr));

        let dmut module : VkShaderModule = null;
        if (vkCreateShaderModule (self._device.getDeviceHandle (), &createInfo, null, alias &module) != VkResult::VK_SUCCESS) {
            throw copy BalderError ("Failed to create shader module");
        }

        module
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable;

}
   

pub def RasterShader : raster::RasterShader;
pub def ComputeShader : compute::ComputeShader;

