/**
 * @authors: Emile Cadorel
 */
mod balder::core::window;

import balder::core::_;

import vulkan::_;
import std::config::_;
import std::time::_;
import std::concurrency::thread;

import balder::concurrency::timer;
import sdl2::_;
import std::io;


/**
 * Class managing a window and vulkan devices to enable 3D rendering
 * @example:
 * ===
 * // Create an empty window
 * with dmut win = Window::new () {
 * 
 *    // Configure the window
 *    win:.configure (conf);
 * 
 *    // show the window to the screen
 *    win:.show ();
 *
 * } // window are disposable
 * ===
 */
pub class Window {

    // the width of the window
    let mut _w : u32 = 0u32;

    // The height of the window
    let mut _h : u32 = 0u32;

    // The name (displayed on the window bar) of the window
    let mut _name : [c8] = ""s8;

    prot {

        // The sdl handler of the window
        let dmut _sdlWindow : &SDL_Window = null;
        
        // The surface for vulkan presenting
        let dmut _vkSurface : VkSurfaceKHR = null;
        
        // Vulkan instance
        let dmut _vkInstance : &VulkanInstance = VulkanInstance::new ();

        // The device used for rendering
        let dmut _vkDevice : &VulkanDevice = VulkanDevice::new ();
        
    }

    prot {

        // The thread running the rendering loop        
        let dmut _renderingTh : Thread = Thread (0us, ThreadPipe::new (create-> false));

        // The command allocator used to allocate the indirect command buffer, and draw with it
        let dmut _cmdAlloc : (&IndirectCommandAllocator)? = (dmut (&IndirectCommandAllocator)?)::__err__;
        
        // True if the window is rendering
        let mut _isRunning : bool = false;

        // The timer of frame duration
        let dmut _frameTimer = Timer::new ();

        // The timer of a second, for nb frame per second computation
        let dmut _secondTimer = Timer::new ();
        
        // The duration of a frame in ms, by default 60 frame per seconds
        let mut _frameDuration : Duration = dur::millis (16u64) + dur::micros (666u64);

        /// The number of frame in the current second
        let mut _nbFrame : u32 = 0u32;
        
        /// The number of frame rendered during the last second
        let mut _lastNbFrame : u32 = 0u32;
        
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =======================================   CTOR AND CONFIGURE  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

        
    /**
     * Create an empty window
     */
    pub self () {}

    
    /**
     * Configure the window to use vulkan for 3D rendering
     * @params: 
     *    - config: the configuration of the window
     *    - resizable: true iif the window should be resizable 
     * @throws:
     *    - &BalderError: if the configuration failed
     */
    pub def configureVulkan (mut self, config : &Config, fps : u32, resizable : bool = false)
        throws &BalderError
    {
        import std::conv; // toStringZ
        
        if (SDL_Init (SDL_INIT_EVERYTHING) < 0) {
            throw BalderError::new ("Failed to init SDL2"s8);
        }

        if (TTF_Init () < 0) {
            throw BalderError::new ("Failed to init ttf"s8);
        }
	
	self._sdlWindow = SDL_CreateWindow(
	    self._name.toStringZ (), 
	    cast!i32 (SDL_WINDOWPOS_UNDEFINED), 
	    cast!i32 (SDL_WINDOWPOS_UNDEFINED), 
	    cast!i32 (self._w), 
	    cast!i32 (self._h), 
	    if (resizable) { SDL_WindowFlags::SDL_WINDOW_VULKAN |
                             SDL_WindowFlags::SDL_WINDOW_RESIZABLE }
            else {
                SDL_WindowFlags::SDL_WINDOW_VULKAN 
            }
	);

        if (self._sdlWindow is null) {
            throw BalderError::new ("Failed to create window"s8);
        }
        
        self._vkInstance:.configure (alias self, config);
        
        SDL_Vulkan_CreateSurface (self._sdlWindow, self._vkInstance:.getHandle (), alias &self._vkSurface);
        if (self._vkSurface is null) {
            throw BalderError::new ("Failed to create vulkan surface"s8);
        }
        
        self._vkDevice:.configure (alias self, config);
        SDL_HideWindow (alias self._sdlWindow);

        self._frameDuration = dur::seconds (1) / fps;

        self._cmdAlloc = alias (IndirectCommandAllocator::new (alias self._vkDevice))?;

        // Draw empty screen, to configure default command buffers 
        self:.resetDrawing ();
    }

    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  SETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {
        
        /**
         * Change the dimension of the window
         * @params: 
         *    - w: the width of the window
         *    - h: the height of the window
         */
        def setDimension (mut self, w : u32, h : u32) {
            self._w = w;
            self._h = h;
            if (self._sdlWindow !is null) {
                SDL_SetWindowSize (alias self._sdlWindow, cast!i32 (self._w), cast!i32 (self._h));
            }
        }

        
        /**
         * Change the name of the window
         * @params: 
         *    - name: the name to put on the window title bar
         */
        def setName (mut self, name : [c8]) {        
            self._name = name;
            if (self._sdlWindow !is null) {
                import std::conv; // toStringZ
                SDL_SetWindowTitle (alias self._sdlWindow, self._name.toStringZ ());
            }
        }

    }
    
    /**
     * ======================================================================================================
     * ======================================================================================================
     * ===============================================  GETTERS  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {
    
        /**
         * @returns:
         *   - .0: the width of the window
         *   - .1: the height of the window
         */
        def getDimension (self)-> (u32, u32) {
            (self._w, self._h)
        }
        

        /**
         * @returns: the name of the window
         */
        def getName (self)-> [c8] {
            self._name
        }

        /**
         * @returns: the handle of the sdl window
         */
        def getSdlHandle (mut self)-> dmut &SDL_Window {
            alias self._sdlWindow
        }

        /**
         * @returns: the surface on which vulkan can render, to render on the window
         */
        def getVulkanSurface (mut self)-> dmut VkSurfaceKHR {
            alias self._vkSurface
        }
        
        /**
         * @returns: The instance of vulkan used by the window
         */
        def getVulkanInstance (mut self)-> dmut &VulkanInstance {
            alias self._vkInstance
        }

        /**
         * @returns: The device used by the window to render
         */
        def getVulkanDevice (mut self)-> dmut &VulkanDevice {
            alias self._vkDevice
        }    

    }


    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================   USAGE  ===============================================
     * ======================================================================================================
     * ======================================================================================================
     */

    pub {
        
        /**
         * Show the window on the screen
         */
        def show (mut self) {
            if (self._sdlWindow !is null) {
                SDL_ShowWindow (alias self._sdlWindow);
            }
        }

        /**
         * Hide the window on the screen
         */
        def hide (mut self) {
            if (self._sdlWindow !is null) {
                SDL_ShowWindow (alias self._sdlWindow);
            }
        }

        /**
         * Launch the thread that draws on the window at a given framerate
         */
        def startRendering (mut self) {
            if (!self._isRunning && self._renderingTh.id == 0us) {                
                self._isRunning = true;
                self._renderingTh = spawn (&self:.renderingThread);
            }
        }

        /**
         * Stop the thread that draws on the window
         */
        def stopRendering (mut self) {
            self._isRunning = false;
            if (self._renderingTh.id != 0us) {
                self._renderingTh.join ();
                self._renderingTh.id = 0us;
            }
            
            self:.waitIdle ();
        }

        /**
         * Clear all screen drawings
         */
        def resetDrawing (mut self)
            throws &BalderError
        {
            self:.updateDrawing (
                &self.emptyLoad,
                &self.emptyDraw
            );
        }
        
        /**
         * Update the elements that are drawn to the window screen
         * @params:
         *     - loadPhase: a callback closure for the loading phase 
         *     - drawPhase: a callback closure for the drawing phase 
         * @info: the command allocator is correctly set for both phases. This function can be called before the window start its rendering threads, and is thread safe.
         * @warning: 
         * 1. This function interrupts the screen drawing for the duration of the redrawing
         *     The loading phase should be used to inform the command allocator of the meshes that are already loaded to buffers, but not for the real loading of the scene
         * 2. loading and drawing should be made in the same order (load mesh 1 then 2, draw mesh 1 then 2, but not load mesh 1 and 2, draw mesh 2 and 1)
         */
        def updateDrawing (mut self, loadPhase : dg (dmut &IndirectCommandAllocator)-> void, drawPhase : dg (dmut &IndirectCommandAllocator)-> void)
            throws &BalderError
        {            
            let wasDrawing = self._isRunning;
            self:.stopRendering ();
            
            atomic self {
                match ref self._cmdAlloc {
                    Ok (dmut alloc : _) => {                   
                        // Clearing the current scene
                        alloc:.dispose ();                        
                        loadPhase (alias alloc);

                        alloc:.finalizeLoading ();

                        self._vkDevice:.clearCommandBuffers ();
                        for i in 0u32 .. self._vkDevice:.getSwapchainNbFrames () {
                            alloc:.startRecording ();
                            self._vkDevice:.setCurrentFrameIndex (i);
                            self._vkDevice:.startRecording ();
                            self._vkDevice:.startRenderPass (i);
                            
                            drawPhase (alias alloc);

                            self._vkDevice:.stopRenderPass ();
                            self._vkDevice:.stopRecording ();
                        }
                        
                        self._vkDevice:.setCurrentFrameIndex (0u32);
                    }
                    Err () => {
                        eprintln ("Window has no indirect command allocator, Panic !");
                        __pragma!panic ();
                    }
                }
            }
            if (wasDrawing) {
                self:.startRendering ();
            }
        }
        
    }


    prv {

        /**
         * Empty indirect command buffer loading
         */
        def emptyLoad (self, dmut _ : &IndirectCommandAllocator) {}
        
        /**
         * Empty indirect command buffer drawing
         */
        def emptyDraw (self, dmut _ : &IndirectCommandAllocator) {}
        
    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * ==========================================   RENDERING UTILS  ========================================
     * ======================================================================================================
     * ======================================================================================================
     */

    
    prv {

        /**
         * Content of the rendering thread, updating the window at a given framerate
         */
        def renderingThread (mut self, _ : Thread) {
            while self._isRunning {
                atomic self {
                    self:.presentPass (self:.startPass ());
                }
                
                self:.waitFrame ();
            }
        }
    
        /**
         * Wait until the next frame should be drawn.
         * @info: update the frame count.
         */
        def waitFrame (mut self) {
            self._nbFrame += 1u32;

            if (self._secondTimer.timeSinceStart () >= dur::seconds (1u64)) {
                self._secondTimer:.reset ();
                self._lastNbFrame = self._nbFrame;
                self._nbFrame = 0u32;
                
                import std::conv;
                let oldName = self._name;
                self:.setName (self._name ~ " FPS : "s8  ~ std::conv::to!{[c8]} (self._lastNbFrame));
                self._name = oldName;
            }
            
            let tick = self._frameTimer.timeSinceStart ();
            let x = instant::now ();
            let r = self._frameDuration - tick - dur::micros (1u64);
            sleep (r);
            self._frameTimer:.reset ((instant::now () - x) - r);
        }
        
        /**
         * Start a new vulkan rendering pass
         */
        def startPass (mut self)-> i32 {
            self._vkDevice:.waitPreviousFrame ();
            let image = self._vkDevice:.acquireNextImage ();            
            if (image < 0) return image;

            image
        }

        /**
         * Present the pass that was rendered on the GPU
         */
        def presentPass (mut self, image : i32) {
            self._vkDevice:.presentScreen (cast!u32 (image));        
        }

        /**
         * Wait for all window subcommand to be idle
         */
        def waitIdle (mut self) {
            self._vkDevice:.waitIdle ();
        }


    }

    /**
     * ======================================================================================================
     * ======================================================================================================
     * =============================================  DISPOSING  ============================================
     * ======================================================================================================
     * ======================================================================================================
     */
        
    
    impl Disposable {
        pub over dispose (mut self) {
            self:.stopRendering ();
            self:.waitIdle ();

            match ref self._cmdAlloc {
                Ok (dmut cmd : _) => cmd:.dispose ();
            }
            
            self._vkDevice:.disposeSwapchain ();
            
            self:.disposeSurface ();            
            
            self._vkDevice:.dispose ();
            self._vkInstance:.dispose ();
            
            if (self._sdlWindow !is null) {
                SDL_DestroyWindow  (self._sdlWindow);
                self._sdlWindow = null;
            }
        }
    }

    /**
     * Dispose the surface of the window, so it can be recreated for example
     * @info: when window is resized, the surface must be recreated for example
     */
    prv def disposeSurface (mut self) {
        if (self._vkSurface !is null) {
            vkDestroySurfaceKHR (self._vkInstance:.getHandle (), self._vkSurface, null);
            self._vkSurface = null;
        }
    }
    
    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
       
}
