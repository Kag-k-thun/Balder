/**
 * @authors: Emile Cadorel
 */
mod balder::core::window;

import balder::core::error;

import std::config::_;
import sdl2::_;

/**
 * Class managing a window and vulkan devices to enable 3D rendering
 * @example:
 * ===
 * // Create an empty window
 * with dmut win = Window::new () {
 * 
 *    // Configure the window
 *    win:.configure (conf);
 * 
 *    // show the window to the screen
 *    win:.show ();
 *
 * } // window are disposable
 * ===
 */
pub class Window {

    // the width of the window
    let mut _w : u32 = 0u32;

    // The height of the window
    let mut _h : u32 = 0u32;

    // The name (displayed on the window bar) of the window
    let mut _name : [c8] = ""s8;

    // The sdl handler of the window
    let dmut _sdlWindow : &SDL_Window = null;
    
    /**
     * Create an empty window
     */
    pub self () {}

    /**
     * Change the dimension of the window
     * @params: 
     *    - w: the width of the window
     *    - h: the height of the window
     */
    pub def setDimension (mut self, w : u32, h : u32) {
        self._w = w;
        self._h = h;
        if (self._sdlWindow !is null) {
            SDL_SetWindowSize (alias self._sdlWindow, cast!i32 (self._w), cast!i32 (self._h));
        }
    }

    /**
     * Change the name of the window
     * @params: 
     *    - name: the name to put on the window title bar
     */
    pub def setName (mut self, name : [c8]) {        
        self._name = name;
        if (self._sdlWindow !is null) {
            import std::conv; // toStringZ
            SDL_SetWindowTitle (alias self._sdlWindow, self._name.toStringZ ());
        }
    }

    /**
     * Configure the window to use vulkan for 3D rendering
     * @params: 
     *    - config: the configuration of the window
     *    - resizable: true iif the window should be resizable 
     * @throws:
     *    - &BalderError: if the configuration failed
     */
    pub def configureVulkan (mut self, config : &Config, resizable : bool = false)
        throws &BalderError
    {
        import std::conv; // toStringZ
        
        if (SDL_Init (SDL_INIT_VIDEO) < 0) {
            throw BalderError::new ("Failed to init video"s8);
        }

        if (SDL_Init (SDL_INIT_EVENTS) < 0) {
            throw BalderError::new ("Failed to init events"s8);
        }

        if (TTF_Init () < 0) {
            throw BalderError::new ("Failed to init ttf"s8);
        }
	
	self._sdlWindow = SDL_CreateWindow(
	    self._name.toStringZ (), 
	    cast!i32 (SDL_WINDOWPOS_UNDEFINED), 
	    cast!i32 (SDL_WINDOWPOS_UNDEFINED), 
	    cast!i32 (self._w), 
	    cast!i32 (self._h), 
	    SDL_WindowFlags::SDL_WINDOW_VULKAN 
	);

        if (self._sdlWindow is null) {
            throw BalderError::new ("Failed to create window"s8);
        }

        SDL_HideWindow (alias self._sdlWindow);
        
        config;
        resizable;
    }

    /**
     * Show the window on the screen
     */
    pub def show (mut self) {
        if (self._sdlWindow !is null) {
            SDL_ShowWindow (alias self._sdlWindow);
        }
    }

    /**
     * Hide the window on the screen
     */
    pub def hide (mut self) {
        if (self._sdlWindow !is null) {
            SDL_ShowWindow (alias self._sdlWindow);
        }
    }
    
    /**
     * Start a new vulkan rendering pass
     */
    pub def startPass (mut self) {
    }

    /**
     * Submit the pass to render on the GPU
     */
    pub def submitPass (mut self) {
    }

    /**
     * Present the pass that was rendered on the GPU
     */
    pub def presentPass (mut self) {
    }
    
    impl Disposable {
        pub over dispose (mut self) {
            if (self._sdlWindow !is null) {
                SDL_DestroyWindow  (self._sdlWindow);
                self._sdlWindow = null;
            }
        }
    }

    /**
     * Call dispose
     */
    __dtor (mut self) {
        self:.dispose ();
    }
       
}
