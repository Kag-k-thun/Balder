in node;

pub mod ::node2D;
pub mod ::node3D;
pub mod ::root;

use std::fs::path;
use balder::core::driver::_;
use balder::scene::_;
use balder::core::dispose;

use ::std::time::_;

lazy dmut __NODE_UID__ = copy [0us];
fn getUID ()-> usize atomic {
    __NODE_UID__ [0] += 1us;
    __NODE_UID__ [0]
}

/**
 * Base
 * */
@abstract
pub class Node {

    // The uniq id of the visual instance in the scene
    let mut _uid : usize;

    // The name of the node
    let mut _name : Path;

    prot { // Tree
        // The scene in which the node can be found
        let dmut _parent : (&Node)? = none;

        // The list of childs in the node
        let dmut _childs : [[c8] => &Node] = copy [];
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Ctor for a root node
     * */
    prot self root (name : [c8])
        with _uid = getUID ()
        , _name = Path (name)
    {}

    /**
     * Create a node and put it in an existing tree
     * @params:
     *    - name: the name of the node
     *    - parents: the parent to which the node is attached
     * */
    pub self (name : [c8], dmut parent : &Node)
        with _uid = getUID ()
        , _name = Path (name)
        , _parent = (alias parent)?
    {
        parent:.addChild (name, alias self);
        self:.onTreeEnter (alias self);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          ATTACHING/DETACHING          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a child node in the trees of node
     * */
    fn addChild (mut self, name : [c8], dmut node : &Node) {
        if let Ok (dmut old) = alias self._childs [name] {
            old:.dispose ();
        }

        node._name = self._name.push (name);
        node._parent = (alias self)?;

        self._childs [name] = alias node;
    }

    /**
     * Remove a direct child in the node
     * */
    fn removeChild (mut self, name : [c8]) {
        self._childs:.remove (name);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          UPDATE SIGNALS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the node enters the scene
     * */
    pub fn onEnter (mut self, dmut scene : &Scene);

    /**
     * Method called when the node exits the scene
     * @info: the scene passed as argument is the same as the one passed in the previous onEnter
     * */
    pub fn onExit (mut self, dmut scene : &Scene);

    /**
     * Method called at each UI frame on nodes being in a scene
     * Propagate the signal to child nodes
     * */
    pub fn onTick (mut self, delta : Duration) {
        for _, dmut c in alias self._childs {
            c:.onTick (delta);
        }
    }

    /**
     * Propagate the entry of a node to scene
     * */
    fn onTreeEnter (mut self, dmut who : &Node) {
        if let Ok (dmut parent) = alias self._parent {
            parent:.onTreeEnter (alias who);
        }
    }

    /**
     * Propagate the exit of a node to scene
     * */
    fn onTreeExit (mut self, dmut who : &Node) {
        if let Ok (dmut parent) = alias self._parent {
            parent:.onTreeExit (alias who);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          FINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Find a child in the node tree
     * */
    pub fn find (mut self, name : Path)-> dmut (&Node)? {
        return self:.getChild (name.parts ());
    }

    /**
     * Find a child in the node tree
     * */
    fn getChild (mut self, name : [[c8]])-> dmut (&Node)? {
        if name.len == 0 { return (alias self)?; }
        if let Ok (dmut c) = alias self._childs [name [0]] {
            return c:.getChild (name [1 .. $]);
        }

        none
    }

    pub fn getChilds (mut self)-> dmut [[c8] => &Node] {
        alias self._childs
    }

    /**
     * Traverse the tree and return the list of nodes that can be found within it
     * */
    pub fn getAllNodes (mut self, ref dmut list : [&Node])-> dmut [&Node] {
        list ~= [alias self];
        for _, dmut c in alias self._childs {
            c:.getAllNodes (ref list);
        }

        alias list
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ITERATION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the parent of the node
     * */
    pub fn getParent (mut self)-> dmut (&Node)? {
        alias self._parent
    }

    /**
     * @returns: the name of the node
     * */
    pub fn getName (self)-> Path {
        self._name
    }

    /**
     * Set the uid of the visual instance
     * */
    pub fn setUID (mut self, uid : usize) {
        self._uid = uid;
    }

    @field
    pub fn uid (self)-> usize {
        self._uid
    }

    /**
     * @returns: the scene to which the node is attached
     * */
    pub fn getScene (mut self)-> dmut (&Scene)? {
        if let Ok (dmut p) = alias self._parent {
            return alias p:.getScene ();
        }

        none
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut p) = alias self._parent {
                p:.removeChild (self._name.file ());
                self:.onTreeExit (alias self);
            }
        }
    }


}
