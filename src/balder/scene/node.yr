in node;

pub mod ::node2D;
pub mod ::node3D;

use std::fs::path;
use balder::core::driver::_;
use balder::scene::_;
use balder::core::dispose;

use ::std::time::_;

/**
 * Base
 * */
pub class Node {

    // The uniq id of the visual instance in the scene
    let mut _uid : usize = 0us;

    // The scene in which the node can be found
    let dmut _scene : &Scene;

    // The name of the node
    let mut _name : Path;

    // The parent of the node (none if this is a root node)
    let dmut _parent : (&Node)? = none;

    // The list of childs in the node
    let dmut _childs : [[c8] => &Node] = copy [];

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (name : [c8], dmut scene : &Scene)
        with _name = Path (name)
        , _scene = alias scene
    {
        scene:.registerNode (alias self);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          ATTACHING/DETACHING          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a child node in the trees of node
     * */
    pub fn addChild (mut self, name : [c8], dmut node : &Node) {
        self:.removeChild (name);

        node._name = self._name.push (name);
        node._parent = (alias self)?;

        self._childs [name] = alias node;
    }

    /**
     * Remove a direct child in the node
     * */
    pub fn removeChild (mut self, name : [c8]) {
        if let Ok (dmut c) = alias self._childs [name] {
            c:.dispose ();

            c._name = Path (name);
            c._parent = none;
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          SET/GET SCENE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the scene tree is complete, and ready to update crossover information
     * */
    pub fn onReady (mut self) {}

    /**
     * Method called when a node was detached from the scene
     * @info: at this point self._scene is still set
     * */
    pub fn onExit (mut self) {}

    /**
     * Method called at each UI frame
     * */
    pub fn onTick (mut self, delta : Duration) { delta; }

    /**
     * @returns: the scene to which the node is attached
     * */
    pub fn getScene (mut self)-> dmut &Scene {
        alias self._scene
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          FINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Find a child in the node tree
     * */
    pub fn getChild (mut self, name : Path)-> dmut (&Node)? {
        return self:.getChild (name.parts ());
    }

    /**
     * @returns: the parent of the node
     * */
    pub fn getParent (mut self)-> dmut (&Node)? {
        alias self._parent
    }

    /**
     * Find a child in the node tree
     * */
    fn getChild (mut self, name : [[c8]])-> dmut (&Node)? {
        if name.len == 0 { return (alias self)?; }
        if let Ok (dmut c) = alias self._childs [name [0]] {
            return c:.getChild (name [1 .. $]);
        }

        none
    }

    pub fn getChilds (mut self)-> dmut [[c8] => &Node] {
        alias self._childs
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the name of the node
     * */
    pub fn getName (self)-> Path {
        self._name
    }

    /**
     * Set the uid of the visual instance
     * */
    pub fn setUID (mut self, uid : usize) {
        self._uid = uid;
    }

    @field
    pub fn uid (self)-> usize {
        self._uid
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._scene:.removeNode (alias self);
        }
    }


}
