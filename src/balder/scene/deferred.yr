in deferred;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::utils::_;

use ::vulkan::core;

/**
 * The record holding the data of the deferred textures and subpass
 * */
pub record DeferredRenderScene {
    
    let dmut _position : (&RefCount!{&Texture})? = none;    
    let dmut _normal : (&RefCount!{&Texture})? = none;
    let dmut _binormal : (&RefCount!{&Texture})? = none;    
    let dmut _albedo : (&RefCount!{&Texture})? = none;
    let dmut _materialID : (&RefCount!{&Texture})? = none;    
    let dmut _depth : (&RefCount!{&Texture})? = none;
        
    let dmut _pass : (&DrawSubpass)? = none;
    let mut _outputTextures : [&OutputTexture] = [];
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub fn configure (mut self, passName : [c8], dmut win : &Window, width : u32, height : u32)
        throws BalderError
    {                
        let dmut device = win:.getVulkanDevice ();
        
        let dmut position = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, width, height);        
        let dmut normal = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, width, height);
        let dmut binormal = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R16G16B16_SFLOAT, width, height);
        let dmut albedo = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R8G8B8A8_UNORM, width, height);
        let dmut materialID = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R32_UINT, width, height);
        let dmut depth = copy OutputTexture (alias device, device.getDepthFormat (), width, height, depth-> true);
        
        let subpassTextures = copy [position,                                     
                                    normal,
                                    binormal,
                                    albedo,
                                    materialID,
                                    depth];

        self._outputTextures = subpassTextures;
        self._position = (alias win:.insertResource (alias position))?;
        self._depth = (alias win:.insertResource (alias depth))?;
        self._normal = (alias win:.insertResource (alias normal))?;
        self._binormal = (alias win:.insertResource (alias binormal))?;
        self._albedo = (alias win:.insertResource (alias albedo))?;
        self._materialID = (alias win:.insertResource (alias materialID))?;

        let dmut pass = copy DrawSubpass::toTextures (alias device, width, height, subpassTextures);
        self._pass = (alias pass)?;

        {            
            let dmut pipeline = win:.getVulkanPipeline ();        
            pipeline:.registerSubPass (passName, alias pass);            
        } catch {
            err => {
                log::error #("Scene", "Failed to register deferred subpass", err);                
            }
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the positions texture of the deferred pass
     * */
    @field
    pub fn positions (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut tex) = alias self._position {
            return alias tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }

    /**
     * @returns: the positions texture of the deferred pass
     * */
    @field
    pub fn positions (self)-> &RefCount!{&Texture} {
        if let Ok (tex) = self._position {
            return tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }
    
    /**
     * @returns: the normals texture of the deferred pass
     * */
    @field
    pub fn normals (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut tex) = alias self._normal {
            return alias tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }
    
    /**
     * @returns: the normals texture of the deferred pass
     * */
    @field
    pub fn normals (self)-> &RefCount!{&Texture} {
        if let Ok (tex) = self._normal {
            return tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }

    /**
     * @returns: the binormals texture of the deferred pass
     * */
    @field
    pub fn binormals (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut tex) = alias self._binormal {
            return alias tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }

    /**
     * @returns: the binormals texture of the deferred pass
     * */
    @field
    pub fn binormals (self)-> &RefCount!{&Texture} {
        if let Ok (tex) = self._binormal {
            return tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }

    /**
     * @returns: the albedo texture of the deferred pass
     * */
    @field
    pub fn albedo (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut tex) = alias self._albedo {
            return alias tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }


    /**
     * @returns: the albedo texture of the deferred pass
     * */
    @field
    pub fn albedo (self)-> &RefCount!{&Texture} {
        if let Ok (tex) = self._albedo {
            return tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }
    
    /**
     * @returns: the depth texture of the deferred pass
     * */
    @field
    pub fn depth (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut tex) = alias self._depth {
            return alias tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }
        
    /**
     * @returns: the depth texture of the deferred pass
     * */
    @field
    pub fn depth (self)-> &RefCount!{&Texture} {
        if let Ok (tex) = self._depth {
            return tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }

    /**
     * @returns: the materialID texture of the deferred pass
     * */
    @field
    pub fn materialID (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut tex) = alias self._materialID {
            return alias tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }
    
    /**
     * @returns: the materialID texture of the deferred pass
     * */
    @field
    pub fn materialID (self)-> &RefCount!{&Texture} {
        if let Ok (tex) = self._materialID {
            return tex;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }

    /**
     * @returns: the list of textures in which the rendering of the pass is made
     * */
    @field
    pub fn outputTextures (self)-> [&OutputTexture] {
        self._outputTextures
    }

    /**
     * @returns: the subpass of the deferredering 
     * */
    @field
    pub fn subpass (mut self)-> dmut &DrawSubpass {
        if let Ok (dmut pass) = alias self._pass {
            return alias pass;
        }
        
        log::error #("DeferredRenderScene", "Problem of configuration");
        panic;        
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut pass) = alias self._pass {
                pass:.dispose ();
                self._pass = none;
            }
            
            if let Ok (dmut cl) = alias self._position {
                cl:.dispose ();
                self._position = none;
            }

            if let Ok (dmut cl) = alias self._normal {
                cl:.dispose ();
                self._normal = none;
            }
            
            if let Ok (dmut cl) = alias self._binormal {
                cl:.dispose ();
                self._binormal = none;
            }

            if let Ok (dmut cl) = alias self._albedo {
                cl:.dispose ();
                self._albedo = none;
            }

            if let Ok (dmut cl) = alias self._materialID {
                cl:.dispose ();
                self._materialID = none;
            }

            if let Ok (dmut dp) = alias self._depth {
                dp:.dispose ();
                self._depth = none;
            }                                
        }    
    }    
}
