in cascade;


/**
 * The record holding the data for a cascade shadow pass
 * */
pub record CascadeShadowScene {

    // The depth texture holding the cascaded atlas
    let dmut _altasTexture : (&RefCount!{&Texture})? = none;

    // The subpass of the shadow rendering
    let dmut _pass : (&DrawSubpass)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub fn configure (mut self, passName : [c8], dmut win : &Window, scale : u32)
        throws BalderError
    {        
        let dmut device = win:.getVulkanDevice ();
        let dmut shadowText = copy OutputTexture (alias device, device.getDepthFormat (), width, height, depth-> true);
        self._altasTexture = (alias shadowText)?;
        
        let dmut pass = copy DrawSubpass::toTextures (alias device, passName, width, height, copy [shadowText]);
        self._pass = (alias pass)?;

        {
            let dmut pipeline = win:.getVulkanPipeline ();
            pipeline:.registerSubPass (passName, alias pass);
        } catch {
            err => {
                log::error #("Scene", "Failed to register deferred subpass", err);
            }
        }
        
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut pass) = alias self._pass {
                pass:.dispose ();
                self._pass = none;
            }

            if let Ok (dmut at) = alias self._altasTexture {
                at:.dispose ();
                self._altasTexture = none;
            }
        }
    }
    
    
}
