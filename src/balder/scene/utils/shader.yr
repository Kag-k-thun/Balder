in shader;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::utils::_;

use balder::scene::node::node3D::{camera, visual, visual::material};
use balder::scene::utils::{deferred, compose, material, light};


use ::vulkan::core;

/**
 * The shader collection holding information about loaded shaders and materials
 * */
pub record ShaderNodeScene {

    // The window drawning the scene
    let dmut _window : (&Window)? = none;

    // The list of shaders used in the scene
    let dmut _shaders : [[c8] => &RefCount!{&Shader}] = copy [];

    // The shader used to render shadow in the scene
    let dmut _shadowShader : (&RefCount!{&Shader})? = none;
    
    // The list of drawable nodes and the name of the associated shader
    let dmut _nodeAssoc : [[c8] => [usize => &VisualInstance3D]] = copy [];

    // The list of drawable nodes that casts shadows
    let dmut _shadowMeshes : [usize => &VisualInstance3D] = copy [];    

    // The array containing the list of materials used by the drawable nodes
    let dmut _materials : &MaterialArray = copy MaterialArray ();

    prv { // lights
    
        // The array containing the list of lights in the scene
        let dmut _directionLights : &LightArray = copy LightArray ();

        // The array containing the list of lights in the scene
        let dmut _pointLights : &LightArray = copy LightArray ();

        // The array containing the list of lights in the scene
        let dmut _spotLights : &LightArray = copy LightArray ();
        
    }

    prv { // Deferred
        
        // The output texture of deferred (to created shaders)
        let mut _outputTextures : [&OutputTexture] = [];
        
        // The subpass of the deferred
        let dmut _subpass : (&DrawSubpass)? = none;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn configure (mut self, dmut win : &Window, outTex : [&OutputTexture], dmut subPass : &DrawSubpass)
        throws BalderError
    {
        self:.dispose ();

        self._materials:.configure (alias win);
        self._directionLights:.configure (alias win);
        self._spotLights:.configure (alias win);
        self._pointLights:.configure (alias win);
        
        self._window = (alias win)?;        
        self._outputTextures = outTex;
        self._subpass = (alias subPass)?;
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the material array of the shader associations
     * */
    @field
    pub fn materials (mut self)-> dmut &MaterialArray {
        alias self._materials
    }    

    /**
     * @returns: the array containing spot light information in the composition pass
     * */
    @field
    pub fn spotLights (mut self)-> dmut &LightArray {
        alias self._spotLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn pointLights (mut self)-> dmut &LightArray {
        alias self._pointLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn directionLights (mut self)-> dmut &LightArray {
        alias self._directionLights
    }

    /**
     * @returns: the material array of the shader associations
     * */
    @field
    pub fn materials (self)-> &MaterialArray {
        self._materials
    }    

    /**
     * @returns: the array containing spot light information in the composition pass
     * */
    @field
    pub fn spotLights (self)-> &LightArray {
        self._spotLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn pointLights (self)-> &LightArray {
        self._pointLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn directionLights (self)-> &LightArray {
        self._directionLights
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Register a shader reference that will be used to draw a mesh in the scene
     *
     * */
    pub fn register (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D)-> dmut (&RefCount!{&Shader})
        throws BalderError
    {        
        {
            let dmut sub = alias self._subpass.value;
            let dmut shader = if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                alias sh
            } else {
                let dmut shader = self._window.value:.loadResource!{&RasterShader} (shCfg.name,
                                                                                    shCfg,
                                                                                    sub.getRenderPass (),
                                                                                    sub.getDimension ()._0,
                                                                                    sub.getDimension ()._1,
                                                                                    self._outputTextures);

                self._shaders [shCfg.name] = alias shader;
                alias shader
            };

            if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                inner [node.uid] = alias node;
            } else {
                self._nodeAssoc [shCfg.name] = copy [node.uid => alias node];
            }

            return alias shader;
        } catch {
            err => {
                log::error#("Scene", "failed to attach visual instance ", err);
                if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                    inner:.remove (node.uid);
                }
            }
        }
        
        throw copy BalderError ("Failed to register shader reference");
    }

    /**
     * Release a shader reference and free resources if possible
     * */
    pub fn release (mut self, shCfg : &ShaderConfig, dmut node : &VisualInstance3D) { 
        if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
            inner:.remove (node.uid);

            if inner.len == 0us {
                if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                    sh:.dispose ();
                    self._shaders:.remove (shCfg.name);
                }

                self._nodeAssoc:.remove (shCfg.name);
            }
        }
    }            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Draw the nodes using the command allocator
     * */
    pub fn draw (mut self, frame : u32, dmut cmd : &IndexedDrawCommandAllocator) {        
        for _, dmut c in alias self._nodeAssoc {
            for _, dmut v in alias c { v:.register (alias cmd); }
        }

        {
            cmd:.finalizeRegister ();
        } catch {
            err => {
                log::error #("Scene", "Failed to register nodes to draw", err);
                return;
            }
        }

        {
            for shName, dmut c in alias self._nodeAssoc {
                if let Ok (dmut shO) = alias self._shaders [shName] {
                    let dmut sh = shO:.get ();
                    sh.select (cmd.getCommandBuffer ());
                    
                    for _, v in c { v.draw (frame, alias sh, alias cmd); }
                }
            }
        } catch {
            err => {
                log::error #("Scene", "Failed to get shaders", err);                        
            }
        }
    }
    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._nodeAssoc = copy [];
            for _, dmut sh in alias self._shaders {
                sh:.dispose ();
            }

            if let Ok (dmut sh) = alias self._shadowShader {
                sh:.dispose ();
                self._shadowShader = none;
            }
            
            self._shaders = copy [];
            self._materials:.dispose ();
            self._directionLights:.dispose ();
            self._spotLights:.dispose ();
            self._pointLights:.dispose ();
        }
    }
    
}
