in shader;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::{_, shader::_}};
use balder::core::shader::buffers::_;

use balder::utils::_;

use balder::scene::node::node3D::{camera, visual, visual::material};
use balder::scene::utils::{deferred, compose, material, light};


use ::vulkan::core;

/**
 * The shader collection holding information about loaded shaders and materials
 * */
pub record ShaderNodeScene {

    // The window drawning the scene
    let dmut _window : (&Window)? = none;

    // The list of shaders used in the scene
    let dmut _shaders : [[c8] => (&RefCount!{&Shader}, &DescriptorSet)] = copy [];

    // The list of drawable nodes and the name of the associated shader
    let dmut _nodeAssoc : [[c8] => [usize => &VisualInstance3D]] = copy [];

    // The list of drawable nodes that casts shadows
    let dmut _shadowMeshes : [usize => &VisualInstance3D] = copy [];    

    // The array containing the list of materials used by the drawable nodes
    let dmut _materials : &MaterialArray = copy MaterialArray ();

    prv { // Camera

        let mut _cam : (&UniformBufferObject)? = none;
        
    }
    
    prv { // lights
    
        // The array containing the list of lights in the scene
        let dmut _directionLights : &LightArray = copy LightArray ();

        // The array containing the list of lights in the scene
        let dmut _pointLights : &LightArray = copy LightArray ();

        // The array containing the list of lights in the scene
        let dmut _spotLights : &LightArray = copy LightArray ();
        
    }

    prv { // Deferred
        
        // The output texture of deferred (to created shaders)
        let mut _outputTextures : [&OutputTexture] = [];
                
        // The subpass of the deferred
        let dmut _subpass : (&DrawSubpass)? = none;
       
    }

    prv { // Shadow

        // The list of shadow maps
        let dmut _shadowMaps : [&OutputTexture] = [];

        // The list of shadow subpasses
        let dmut _shadowPass : [&DrawSubpass] = [];

        // The list of shadow shaders used to render shadow in the scene        
        // @warning >= self._shadowPass.len (indeed cascade shadow have multiple shaders)
        //   - ._1: the index of the shadowMap/shadowPass
        let dmut _shadowShader : [(&RefCount!{&Shader}, u32, &DescriptorSet)] = [];
    
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn configure (mut self, dmut win : &Window, outTex : [&OutputTexture], dmut subPass : &DrawSubpass)
        throws BalderError
    {
        self:.dispose ();

        self._materials:.configure (alias win);
        self._directionLights:.configure (alias win);
        self._spotLights:.configure (alias win);
        self._pointLights:.configure (alias win);
                
        self._window = (alias win)?;        
        self._outputTextures = outTex;
        self._subpass = (alias subPass)?;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the camera used in the shaders
     * */
    pub fn setCamera (mut self, dmut cam : &Camera) {
        if let Ok (dmut ubo) = alias cam:.getUBO () {
            for _, dmut sh in alias self._shaders {
                sh._1:.setUniform (UniformNames::CAMERA, ubo);                
            }

            self._cam = (ubo)?;
        }
    }    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the material array of the shader associations
     * */
    @field
    pub fn materials (mut self)-> dmut &MaterialArray {
        alias self._materials
    }    

    /**
     * @returns: the array containing spot light information in the composition pass
     * */
    @field
    pub fn spotLights (mut self)-> dmut &LightArray {
        alias self._spotLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn pointLights (mut self)-> dmut &LightArray {
        alias self._pointLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn directionLights (mut self)-> dmut &LightArray {
        alias self._directionLights
    }

    /**
     * @returns: the material array of the shader associations
     * */
    @field
    pub fn materials (self)-> &MaterialArray {
        self._materials
    }    

    /**
     * @returns: the array containing spot light information in the composition pass
     * */
    @field
    pub fn spotLights (self)-> &LightArray {
        self._spotLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn pointLights (self)-> &LightArray {
        self._pointLights
    }

    /**
     * @returns: the array containing point light information in the composition pass
     * */
    @field
    pub fn directionLights (self)-> &LightArray {
        self._directionLights
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Register a shader reference that will be used to draw a mesh in the scene
     *
     * */
    pub fn register (mut self, shCfg : &RasterShaderConfig, dmut node : &VisualInstance3D)-> dmut (&RefCount!{&Shader})
        throws BalderError
    {        
        {
            let dmut sub = alias self._subpass.value;
            let dmut shader = if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                alias sh._0
            } else {
                let dmut shader = self._window.value:.loadResource!{&RasterShader} (shCfg.name,
                                                                                    shCfg,
                                                                                    sub.getRenderPass (),
                                                                                    sub.getDimension ()._0,
                                                                                    sub.getDimension ()._1,
                                                                                    self._outputTextures);

                let dmut desc = shader:.get ():.allocateDescriptorSet (DescriptorContext::CAMERA);
                if let Ok (cam) = self._cam {                    
                    desc:.setUniform (UniformNames::CAMERA, cam);                    
                }
                        
                self._shaders [shCfg.name] = (alias shader, alias desc);
                alias shader
            };            

            if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                inner [node.uid] = alias node;
            } else {
                self._nodeAssoc [shCfg.name] = copy [node.uid => alias node];
            }
            
            return alias shader;
        } catch {
            err => {
                log::error#("Scene", "failed to attach visual instance ", err);
                if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
                    inner:.remove (node.uid);
                }
            }
        }
        
        throw copy BalderError ("Failed to register shader reference");
    }

    /**
     * Release a shader reference and free resources if possible
     * */
    pub fn release (mut self, shCfg : &RasterShaderConfig, dmut node : &VisualInstance3D) { 
        if let Ok (dmut inner) = alias self._nodeAssoc [shCfg.name] {
            inner:.remove (node.uid);

            if inner.len == 0us {
                if let Ok (dmut sh) = alias self._shaders [shCfg.name] {
                    sh._1:.dispose ();
                    sh._0:.dispose ();
                    self._shaders:.remove (shCfg.name);
                }
                
                self._nodeAssoc:.remove (shCfg.name);
            }
        }
    }            

    /**
     * @returns: the shader used to render to shadow maps
     * */
    pub fn getShadowShaderRef (mut self, index : u32)-> dmut &RefCount!{&Shader} {
        alias self._shadowShader [index]._0        
    }

    /**
     * @returns: the number of shadow shaders called in shadow subpasses
     * */
    pub fn getNbShadowShaders (self)-> u32 {
        cast!u32 (self._shadowShader.len)
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Draw the nodes using the command allocator
     * */
    pub fn draw (mut self, frame : u32, dmut cmd : &IndexedDrawCommandAllocator) {        
        for _, dmut c in alias self._nodeAssoc {
            for _, dmut v in alias c { v:.register (alias cmd); }
        }

        {
            cmd:.finalizeRegister ();
        } catch {
            err => {
                log::error #("Scene", "Failed to register nodes to draw", err);
                return;
            }
        }

        {
            for shName, dmut c in alias self._nodeAssoc {
                if let Ok ((dmut shO, camSet)) = alias self._shaders [shName] {                    
                    let dmut sh = shO:.get ();
                    sh.select (cmd.getCommandBuffer ());
                    camSet.select (frame, cmd.getCommandBuffer ());
                    
                    for _, v in c { v.draw (frame, alias sh, alias cmd); }                                                    
                }
            }
        } catch {
            err => {
                log::error #("Scene", "Failed to get shaders", err);                        
            }
        }
    }
    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._nodeAssoc = copy [];            
            
            for _, dmut sh in alias self._shaders {
                sh._1:.dispose ();
                sh._0:.dispose ();
            }

            for i in 0 .. self._shadowShader.len {
                self._shadowShader [i]._2:.dispose ();
                self._shadowShader [i]._0:.dispose ();
            }
            self._shadowShader = [];
                                    
            self._shaders = copy [];
            self._materials:.dispose ();
            self._directionLights:.dispose ();
            self._spotLights:.dispose ();
            self._pointLights:.dispose ();
        }
    }
    
}
