in material;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::core::shader::buffers::_;
use balder::utils::_;

use balder::scene::node::node3D::visual::material;
use balder::scene;

use ::vulkan::core;

def GLSL_MATERIAL_SIZE               = 112;
def GLSL_MATERIAL_DIFFUSE_OFFSET     = 0;
def GLSL_MATERIAL_AMBIENT_OFFSET     = 16;
def GLSL_MATERIAL_SPECULAR_OFFSET    = 32;
def GLSL_MATERIAL_EMISSIVE_OFFSET    = 48;
def GLSL_MATERIAL_TRANSPARENT_OFFSET = 64;

def GLSL_MATERIAL_SHADINGMOD_OFFSET  = 80;
def GLSL_MATERIAL_ANISOTROPY_OFFSET  = 84;

def GLSL_MATERIAL_ILLUM_OFFSET       = 88;
def GLSL_MATERIAL_SHININESS_OFFSET   = 92;
def GLSL_MATERIAL_OPACITY_OFFSET     = 96;
def GLSL_MATERIAL_REFRACTION_OFFSET  = 100;


pub class MaterialArray {

    let dmut _window : (&Window)? = none;
    
    // The list of materials in the buffer
    let dmut _materials : [MaterialConfig] = [];

    // The number of objects refering to the material in the scene
    let dmut _refs : [u32] = [];
    
    // The ubo used to store material definition in composition shader
    let dmut _buffer : (&StorageBufferObject)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn configure (mut self, dmut win : &Window)
        throws BalderError
    {
        self._window = (alias win)?;
        self:.resize (4);
    }
        

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a material in the buffer array
     * */
    pub fn register (mut self, mat : MaterialConfig)-> u32
        throws BalderError
    {
        let mut firstFree = 0us;
        let mut found = false;
        
        for i in 0 .. self._materials.len {
            if self._materials [i] == mat {
                self._refs [i] += 1;
                return cast!u32 (i);
            }

            if self._refs [i] == 0 {
                firstFree = i;
                found = true;
            }
        }


        if !found {
            firstFree = self._materials.len;
            self:.resize (cast!u32 (self._materials.len * 2));            
        }
        
        self._materials [firstFree] = mat;
        self._refs [firstFree] = 1;
        if let Ok (dmut buf) = alias self._buffer {
            let off = firstFree * GLSL_MATERIAL_SIZE;            
            
            buf:.setData (off + GLSL_MATERIAL_DIFFUSE_OFFSET, mat.diffuseColor);
            buf:.setData (off + GLSL_MATERIAL_AMBIENT_OFFSET, mat.ambientColor);
            buf:.setData (off + GLSL_MATERIAL_SPECULAR_OFFSET, mat.specularColor);
            buf:.setData (off + GLSL_MATERIAL_EMISSIVE_OFFSET, mat.emissiveColor);
            buf:.setData (off + GLSL_MATERIAL_TRANSPARENT_OFFSET, mat.transparentColor);

            buf:.setData (off + GLSL_MATERIAL_SHADINGMOD_OFFSET, mat.shadingModel);
            buf:.setData (off + GLSL_MATERIAL_ANISOTROPY_OFFSET, mat.anisotropy);

            buf:.setData (off + GLSL_MATERIAL_ILLUM_OFFSET, mat.illum);
            buf:.setData (off + GLSL_MATERIAL_SHININESS_OFFSET, mat.shininess);
            buf:.setData (off + GLSL_MATERIAL_OPACITY_OFFSET, mat.opacity);
            buf:.setData (off + GLSL_MATERIAL_REFRACTION_OFFSET, mat.refraction, commit-> true);            
        }

        return cast!u32 (firstFree);
    }    

    /**
     * Release a material in the array
     * */
    pub fn release (mut self, id : u32) {
        if self._refs [id] > 0 {
            self._refs [id] -= 1;
        }

        let mut lastUsed = self._refs.len;
        for i in self._refs.len - 1 ... 0 {
            if self._refs [i] != 0 {
                lastUsed = i;
                break;
            }
        }

        let dmut old = alias self._buffer;
        {            
            if lastUsed < self._refs.len / 2 {
                self:.resize (balder::math::utils::nextPow2 (cast!u32 (lastUsed)));
            }
        } catch {
            err => {
                log::error #("MaterialArray", "Failed to resize buffer", err);
                self._buffer = (alias old);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the uniform buffer object containing the material configurations
     * */
    pub fn getSBO (mut self)-> dmut (&StorageBufferObject)? {
        alias self._buffer
    }

    /**
     * @returns: the uniform buffer object containing the material configurations
     * */
    pub fn getSBO (self)-> (&StorageBufferObject)? {
        self._buffer
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ARRAY RESIZE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resize the buffer to the given size
     * */
    fn resize (mut self, len : u32)
        throws BalderError
    {
        if let Ok (dmut win) = alias self._window {
            let dmut device = win:.getVulkanDevice ();
            
            let cpSize = std::algorithm::comparison::min (len, cast!u32 (self._refs.len));
            
            let dmut newRefs = copy [0u32 ; len];
            let dmut newMats = copy [MaterialConfig () ; len];

            for i in 0 .. cpSize {
                newMats [i] = self._materials [i];
                newRefs [i] = self._refs [i];
            }

            
            if let Ok (dmut buf) = alias self._buffer {
                win:.insertBin (alias buf);
                self._buffer = none;
            }
            
            let dmut nBuf = copy StorageBufferObject (alias device, GLSL_MATERIAL_SIZE * newMats.len);
            for i, mat in self._materials {
                let off = i * GLSL_MATERIAL_SIZE;
                                
                nBuf:.setData (off + GLSL_MATERIAL_DIFFUSE_OFFSET, mat.diffuseColor);
                nBuf:.setData (off + GLSL_MATERIAL_AMBIENT_OFFSET, mat.ambientColor);
                nBuf:.setData (off + GLSL_MATERIAL_SPECULAR_OFFSET, mat.specularColor);
                nBuf:.setData (off + GLSL_MATERIAL_EMISSIVE_OFFSET, mat.emissiveColor);
                nBuf:.setData (off + GLSL_MATERIAL_TRANSPARENT_OFFSET, mat.transparentColor);

                nBuf:.setData (off + GLSL_MATERIAL_SHADINGMOD_OFFSET, mat.shadingModel);
                nBuf:.setData (off + GLSL_MATERIAL_ANISOTROPY_OFFSET, mat.anisotropy);

                nBuf:.setData (off + GLSL_MATERIAL_ILLUM_OFFSET, mat.illum);
                nBuf:.setData (off + GLSL_MATERIAL_SHININESS_OFFSET, mat.shininess);
                nBuf:.setData (off + GLSL_MATERIAL_OPACITY_OFFSET, mat.opacity);
                nBuf:.setData (off + GLSL_MATERIAL_REFRACTION_OFFSET, mat.refraction);
            }

            self._buffer = (alias nBuf)?;
            self._materials = alias newMats;
            self._refs = alias newRefs;

            win:.redrawPipeline ();
        } else {
            log::warn #("MaterialArray", "resizing array is impossible it's not attach to a window");
            throw copy BalderError ("Using an unconfigured material array");
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut win) = alias self._window {
                if let Ok (dmut buf) = alias self._buffer {
                    win:.insertBin (alias buf);
                    self._buffer = none;
                }
                
                self._window = none;
            }

            self._materials = [];
            self._refs = [];
        }
    }
    
}
