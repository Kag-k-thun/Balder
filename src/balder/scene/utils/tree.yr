in tree;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::utils::_;

use balder::scene::node;
use balder::scene::node::node3D::{camera, visual, visual::material};


use std::time::_;

/**
 * The node tree of the scene
 * */
pub record NodeTreeScene {

    // The window drawing the scene
    let dmut _win : (&Window)? = none;

    // The contect of the tree
    let dmut _scene : (&Scene)? = none;

    // THe root node of the tree
    let dmut _rootNode : (&Node)? = none;

    // The list of nodes contained in the tree
    let dmut _nodes : [usize => &Node] = copy [];

    // The camera node of the tree
    let dmut _camera : (&Camera)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the tree
     * */
    pub fn configure (mut self, dmut win : &Window, dmut scene : &Scene) {
        self:.dispose ();
        
        self._scene = (alias scene)?;
        self._win = (alias win)?;
        
        self._rootNode = (copy root::RootNode (alias self:.getScene ()))?;        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the root node of the scene
     * */
    @field
    pub fn rootNode (mut self)-> dmut &Node {
        if let Ok (dmut r) = alias self._rootNode { 
            return alias r;
        }

        let dmut res = copy root::RootNode (alias self:.getScene ());
        self._rootNode = (alias res)?;

        alias res
    }

    /**
     * @returns: the camera in the tree (if any)
     * */
    @field
    pub fn camera (mut self)-> dmut (&Camera)? {
        alias self._camera
    }

    /**
     * @returns: the camera in the tree (if any)
     * */
    @field
    pub fn camera (self)-> (&Camera)? {
        self._camera
    }

    
    /**
     * @returns: the scene to which the tree is attached
     * */
    pub fn getScene (mut self)-> dmut &Scene {
        if let Ok (dmut c) = alias self._scene {
            return alias c;
        }

        log::error #("NodeTreeScene", "Get scene in tree that is attached to nothing");
        panic;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSERT/REMOVE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Attach a node in the rendering scene
     * */
    pub fn register (mut self, dmut node : &Node) {
        if let Ok (dmut n) = alias self._nodes [node.uid] {
            n:.onExit (alias self:.getScene ());
        }

        self._nodes [node.uid] = alias node;
        node:.onEnter (alias self:.getScene ());
        
        if let dmut ca : &Camera = alias node {
            if let Ok (ica) = self._camera && ica !is ca {
                log::error #("Scene", "scene has multiple cameras");
            } else {
                self:.onSetCamera (alias ca);
            }
        } 

        if let Ok (dmut win) = alias self._win {
            win:.redrawPipeline ();
        }
    }

    /**
     * Detach a node from the rendering scene
     * */
    pub fn remove (mut self, dmut node : &Node) {
        if let Ok (dmut n) = alias self._nodes [node.uid] {
            self._nodes:.remove (node.uid);

            if let dmut ca : &Camera = alias node {
                if let Ok (ica) = self._camera && ica is ca {
                    self:.onRemoveCamera ();
                }
            } else {
                n:.onExit (alias self:.getScene ());
            }

            if let Ok (dmut win) = alias self._win {
                win:.redrawPipeline ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CAMERA          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the camera of the scene, and apply it to every drawable nodes in the scene
     * */
    fn onSetCamera (mut self, dmut cam : &Camera) {
        self._camera = (alias cam)?;
        
        if let Ok (dmut scene) = alias self._scene {
            scene:.onCameraUpdate (alias cam);
        }
    }

    /**
     * Remove the camera of the scene
     * */
    fn onRemoveCamera (mut self) {
        if let Ok (dmut scene) = alias self._scene {                    
        
            if let Ok (dmut cam) = alias self._camera {
                self._nodes:.remove (cam.uid);
                
                self._camera = none;            
                cam:.onExit (alias scene);            
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TICKS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Slot when update IPS signal is emitted
     * */
    pub fn onTick (mut self, delta : Duration) {
        for _, dmut t in alias self._nodes {
            t:.onTick (delta);
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self:.onRemoveCamera ();
            for _, dmut n in alias self._nodes {
                n:.onExit (alias self:.getScene ());
            }
            self._nodes = copy [];            
            
            if let Ok (dmut r) = alias self._rootNode {
                r:.dispose ();
                self._rootNode = none;
            }
            
        }
    }
    
}
