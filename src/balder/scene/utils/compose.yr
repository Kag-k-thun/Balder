in compose;

use balder::core::_;
use balder::core::config::{_, shader::_};

use balder::core::{application::_, shader::_, driver::_};
use balder::core::shader::buffers::_;
use balder::utils::_;

use balder::scene::utils::{deferred, material, light, shader};
use balder::scene::node::node3D::camera;

use ::vulkan::core;

/**
 * The record holding the data needed for the compose pass of the scene
 * */
pub record ComposeRenderScene {
    
    let dmut _output : (&RefCount!{&Texture})? = none;
    let dmut _shader : (&RefCount!{&Shader})? = none;    
    let dmut _set : (&DescriptorSet)? = none;

    let dmut _pass : (&ComputeSubpass)? = none;
    let dmut _computeShader : (&ComputeShader)? = none;
    let dmut _outputTex : (&OutputTexture)? = none;
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CONFIGURE          ====================================
     * ====================================================================================================
     * =================================i===================================================================
     */
    
    pub fn configure (mut self, passName : [c8], dmut win : &Window, width : u32, height : u32, defer : DeferredRenderScene)
        throws BalderError
    {
        let dmut device = alias win:.getVulkanDevice ();
                
        let dmut output = copy OutputTexture (alias device, VkFormat::VK_FORMAT_R8G8B8A8_UNORM, width, height, forStorage-> true);
        self._output = (alias win:.insertResource (alias output))?;
        self._outputTex = (alias output)?;

        let dmut pass = copy ComputeSubpass (alias device, passName, width, height, 1);
        self._pass = (alias pass)?;
        
        let dmut shader = win:.loadResource!{&ComputeShader} (DefaultShaders::COMPOSE_3D);
        self._shader = (alias shader)?;
        
        if let Ok (dmut c : &ComputeShader) = (alias shader:.get ())? {
            self._computeShader = (alias c)?;
        }

        {
            let dmut set = shader:.get ():.allocateDescriptorSet (DescriptorContext::GLOBAL);
            self._set = (alias set)?;            
            set:.setTexture ("positions", defer.positions.get ());
            set:.setTexture ("normals", defer.normals.get ());
            set:.setTexture ("binormals", defer.binormals.get ());
            set:.setTexture ("albedo", defer.albedo.get ());
            set:.setTexture ("materialID", defer.materialID.get ());
            set:.setTexture ("depth", defer.depth.get ());  
            
            set:.setStorageTexture ("output", output);            
        } catch {
            err => {
                log::error #("Scene", "Malformed deferred textures", err);
                throw copy BalderError ("Failed to configure compose pass");
            }
        }
    
        {            
            let dmut pipeline = win:.getVulkanPipeline ();        
            pipeline:.registerSubPass (passName, alias pass);            
        } catch {
            err => {
                log::error #("Scene", "Failed to register deferred subpass", err);
                throw copy BalderError ("Failed to configure compose pass");
            }
        }        
    }

    pub fn setCamera (mut self, dmut cam : &Camera) {
        if let Ok (dmut set) = alias self._set {
            if let Ok (dmut ubo) = alias cam:.getUBO () {
                set:.setUniform (UniformNames::CAMERA, ubo);
            }
        } 
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the texture holding the result of the composition pass
     * */
    @field
    pub fn output (mut self)-> dmut &RefCount!{&Texture} {
        if let Ok (dmut out) = alias self._output {
            return alias out;
        }

        log::error #("ComposeRenderScene", "Problem of configuration");
        panic;
    }

    /**
     * @returns: the texture holding the result of the composition pass
     * */
    @field
    pub fn subpass (mut self)-> dmut &ComputeSubpass {
        if let Ok (dmut pass) = alias self._pass {
            return alias pass;
        }

        log::error #("ComposeRenderScene", "Problem of configuration");
        panic;
    }

    /**
     * @returns: the group size of the compute shader used for composition
     * */
    @field
    pub fn groupSizes (self)-> [u32 ; 3] {
        if let Ok (sh) = self._computeShader {
            return sh.getGroupSizes ();
        }

        log::error #("ComposeRenderScene", "Problem of configuration");
        panic;        
    }
                                        
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Prepare the output texture to be written from compute
     * */
    pub fn prepareTexture (mut self, cmd : VkCommandBuffer, frame : u32) {
        if let Ok (dmut out) = alias self._outputTex {
            out:.getImages ()[frame]:.transitionToWrite (cmd, VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT);
        }
        
        else {
            log::error #("ComposeRenderScene", "Problem of configuration");
            panic;
        }
    }
    
    /**
     * Finalize the output texture to be read from fragment
     * */
    pub fn finalizeTexture (mut self, cmd : VkCommandBuffer, frame : u32) {
        if let Ok (dmut out) = alias self._outputTex {
            out:.getImages ()[frame]:.transitionToRead (cmd, VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT);
        }
        
        else {
            log::error #("ComposeRenderScene", "Problem of configuration");
            panic;
        }        
    }

    /**
     * Select the compute shader, and descriptor set to be used for the next command dispatch
     * */
    pub fn select (mut self, frame : u32, ref shaderAssoc : ShaderNodeScene, cmd : VkCommandBuffer) {
        let dmut set = (if let Ok (dmut s) = alias self._set {
            alias s
        } else {
            log::error #("ComposeRenderScene", "Descriptor set malformed");
            return;
        });

        self.setStorage (frame, alias set, UniformNames::MATERIAL, shaderAssoc.materials.getSBO ());
        self.setStorage (frame, alias set, UniformNames::DIRECTION_LIGHT, shaderAssoc.directionLights.getSBO ());
        self.setStorage (frame, alias set, UniformNames::POINT_LIGHT, shaderAssoc.pointLights.getSBO ());
        self.setStorage (frame, alias set, UniformNames::SPOT_LIGHT, shaderAssoc.spotLights.getSBO ());
        
        set.select (frame, cmd);        
        if let Ok (dmut sh) = alias self._computeShader {
            sh.select (cmd);            
        } else {
            log::error #("ComposeRenderScene", "Problem of configuration");
            panic;
        }                
    }    

    /**
     * Set a storage buffer in the descriptor set
     * */
    fn setStorage (self, frame : u32, dmut set : &DescriptorSet, kind : [c8], sboO : (&StorageBufferObject)?) {                        
        if let Ok (sbo) = sboO {            
            set:.setBuffer (kind, sbo, frame-> cast!i32 (frame));                        
        } else { 
            log::error #("ComposeRenderScene", "Missing SBO in compose pass");            
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {            
            if let Ok (dmut pass) = alias self._pass {
                pass:.dispose ();
                self._pass = none;
            }
            
            if let Ok (dmut output) = alias self._output {
                output:.dispose ();
                self._output = none;
                self._outputTex = none;
            }

            if let Ok (dmut shader) = alias self._shader {
                shader:.dispose ();
                self._shader = none;
                self._computeShader = none;
            }

            if let Ok (dmut s) = alias self._set {
                s:.dispose ();
                self._set = none;
            }
        }
    }
}
