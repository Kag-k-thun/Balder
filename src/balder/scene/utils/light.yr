in light;

use balder::core::_;
use balder::core::{application::_, shader::_, driver::_, config::_};
use balder::core::shader::buffers::_;
use balder::{math::_, utils::_};

use balder::scene::node::node3D::light;
use balder::scene;

use ::vulkan::core;


record LightContent {
    pub let mut position : vec3 = vec3 ();
    pub let padd1 : f32 = 0.f;
    
    pub let mut color : vec3 = makeVec3 (1.f, 1.f, 1.f);
    pub let padd2 : f32 = 0.f;
    
    pub self () {}
}

pub class LightArray {

    // The window used to allocate the buffer
    let dmut _window : (&Window)? = none;
    
    // The list of lights in the buffer
    let dmut _lights : [LightContent] = [];

    // The association of lights in the shader
    let dmut _assocs : [&Light] = [];

    // The remove buffer used to store the light definitions
    let dmut _buffer : (&StorageBufferObject)? = none;

    // The current capacity of the light buffer
    let mut _capacity : u32 = 0;

    // The alignement of the buffer
    let _fstAlign : u32 = 16;
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn configure (mut self, dmut win : &Window)
        throws BalderError
    {
        self._window = (alias win)?;
        self:.resize ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the light in the array
     * */
    pub fn register (mut self, dmut light : &Light) {        
        let mut content = LightContent ();
        content.position = light.position;
        content.color = light.color;                
        
        self._assocs ~= [alias light];        
        self._lights ~= [content];
        
        let dmut old = alias self._buffer;
        {
            self:.resize ();

            let id = cast!u32 (self._lights.len - 1);
            light:.setIndex (id);
            if let Ok (dmut buf) = alias self._buffer {
                buf:.setData (cast!usize (self._fstAlign + (LightContent::size * id)), content, commit-> true);
            }
        } catch {
            err => {
                log::error #("LightArray", "Failed to resize", err);
                self._buffer = alias old;
            }
        }
    }

    /**
     * Update a ligth in the light buffer
     * */
    pub fn update (mut self, dmut light : &Light) {
        let mut content = LightContent ();
        content.position = light.position;
        content.color = light.color;        
    
        let id = light.getIndex ();
        self._lights [id] = content;
        if let Ok (dmut buf) = alias self._buffer {
            buf:.setData (cast!usize (self._fstAlign + (LightContent::size * id)), content, commit-> true);
        }
    }
    
    /**
     * Remove a light in the array
     * */
    pub fn release (mut self, dmut light : &Light) {        
        for i in light.getIndex () .. cast!u32 (self._lights.len - 1) {
            self._lights [i] = self._lights [i + 1];
            self._assocs [i] = alias self._assocs [i + 1];
            self._assocs [i]:.setIndex (cast!u32 (i));
        }

        self._lights = alias self._lights [0 .. $ - 1];
        self._assocs = alias self._assocs [0 .. $ - 1];

        let dmut old = alias self._buffer;
        {        
            self:.resize ();
        } catch {
            err => {
                log::error #("LightArray", "Failed to resize", err);
                self._buffer = alias old;
            }
        }
    }

        /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the storage buffer object containing the light configurations
     * */
    pub fn getSBO (mut self)-> dmut (&StorageBufferObject)? {
        alias self._buffer
    }

    /**
     * @returns: the storage buffer object containing the light configurations
     * */
    pub fn getSBO (self)-> (&StorageBufferObject)? {
        self._buffer
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ARRAY RESIZE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * */
    fn resize (mut self)
        throws BalderError
    {
        if let Ok (dmut win) = alias self._window {
            let dmut device = win:.getVulkanDevice ();
            
            let nSize = {
                if self._capacity < self._lights.len {
                    let nSize = if (self._capacity == 0) { 4u32 } else { self._capacity * 2 };                                                        
                    nSize
                } else if (self._capacity > (2 * self._lights.len)) {                                
                    balder::math::utils::nextPow2 (cast!u32 (self._lights.len))
                } else if let Ok (dmut buf) = alias self._buffer {
                    buf:.setData (0, cast!u32 (self._lights.len));
                    return;
                } else {
                    4u32
                }
            };

            log::debug #("LightArray", "Resize light buffer size", nSize);
            
            let dmut nBuf = copy StorageBufferObject (alias device, cast!usize ((nSize * LightContent::size) + self._fstAlign));
            nBuf:.setData (0, cast!u32 (self._lights.len));
            if self._lights.len != 0 {
                nBuf:.setData (cast!usize (self._fstAlign), self._lights);
            }
            
            if let Ok (dmut buf) = alias self._buffer {
                win:.insertBin (alias buf);
            }
            
            self._buffer = (alias nBuf)?;
            self._capacity = nSize;
            
            win:.redrawPipeline ();            
        }
    }

        /*!
         * ====================================================================================================
         * ====================================================================================================
         * ====================================          DISPOSE          =====================================
         * ====================================================================================================
         * ====================================================================================================
     */


    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut win) = alias self._window {
                if let Ok (dmut buf) = alias self._buffer {
                    win:.insertBin (alias buf);
                    self._buffer = none;
                }
                
                self._window = none;
            }

            self._lights = [];
            self._assocs = [];
        }
    }    
    
} 
