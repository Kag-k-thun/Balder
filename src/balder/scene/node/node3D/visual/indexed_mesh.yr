in indexed_mesh;

use balder::core::{_,
                   config::_,
                   shader::_,
                   shader::buffers::_,
                   driver::_,
                   application::_};

use balder::scene::node::_;
use balder::math::_;

use balder::scene::node::node3D::visual::_;
use balder::scene::node::node3D::camera;

use balder::utils::log;

/**
 * Mesh with two buffers, one for vertices, and one for indices
 */
pub class IndexedMesh3D over VisualInstance3D {

    // The material used to draw the node
    let dmut _material : &Material;

    prot { // Local data

        // The data of the mesh to upload on device
        let mut _array : (MeshArray)? = none;

        // The list of points defining the triangles of the mesh
        let mut _indices : [u32] = [];

        // Destroy the array after uploading (meaning it can be detached and reattached to the scene)
        let mut _destroyOnUpload : bool = false;

    }

    prot { // Remote data

        // The buffer containing the indices of the mesh
        let dmut _ibo : (&IndexBufferObject)? = none;

        // The buffer containing simpler version of the vertices of the mesh
        let dmut _shadowVBO : (&VertexBufferObject)? = none;

        // The buffer containing the vertices of the mesh
        let dmut _vbo : (&VertexBufferObject)? = none;

    }

    prot { // shader binding

        // The buffer containing the world transformation of the visual instance
        let dmut _world : (&UniformBufferObject)? = none;

        // The descriptor set used to attach buffers
        let dmut _descSet : (&DescriptorSet)? = none;

        // The descriptor set used to attach buffers
        let dmut _shadowDescSet : (&DescriptorSet)? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new indexed mesh
     * @params:
     *    - device: the device used to allocate and render the mesh
     *    - indices: the indices of the points forming the mesh
     */
    pub self  (name : [c8],
               dmut parent : &Node,
               indices : [u32],
               array : MeshArray,
               dmut material : &Material,
               shadow : bool = true,
               destroyOnUpload : bool = true)

        with super (name, alias parent, array.aabb (), shadow)
        , _material = alias material
        , _array = (array?)
        , _indices = indices
        , _destroyOnUpload = destroyOnUpload

    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onEnter (mut self, dmut scene : &Scene) {
        self:.destroyBuffers (alias scene);

        {
            if let Ok (array) = self._array && self._indices.len != 0 {
                let dmut win = scene:.getWindow ();
            
                let dmut ibo = copy IndexBufferObject!{u32} (win:.getVulkanDevice (), self._indices);
                self._ibo = (alias ibo)?;

                let dmut vbo = copy VertexBufferObject ();
                self._vbo = (alias vbo)?;

                let dmut world = copy UniformBufferObject (win:.getVulkanDevice (), mat4::size);
                world:.setData (0, self._transformation, commit-> true);                                
                self._world = (alias world)?;

                self:.configureVertices (win:.getVulkanDevice (), array, self._material, self._castShadow);
                self:.configureShader ();
            } else {
                log::warn #("IndexBufferObject", "Empty mesh");
            }
        } catch {
            err => {
                log::error #("IndexedMesh3D", "Failed to upload mesh data to device", err);
                self:.destroyBuffers (alias scene);
            }
        }

        if self._destroyOnUpload {
            self._array = none;
            self._indices = [];
        }
    }

    pub over onExit (mut self, dmut scene : &Scene) {
        log::info #("IndexedMesh3D", "onExit");            
        self:.destroyBuffers (alias scene);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CAMERA          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over setCamera (mut self, dmut cam : &Camera) {
        if let Ok (dmut set) = alias self._descSet {
            if let Ok (dmut ubo) = alias cam:.getUBO () {
                set:.setUniform (UniformNames::CAMERA, ubo);
            }
        } 
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =========================          UPLOAD DATA TO REMOTE BUFFERS          ==========================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the buffers containing the points of the mesh
     * */
    fn configureVertices (mut self, dmut device : &VulkanDevice, array : MeshArray, material : &Material, shadow : bool)
        throws BalderError
    {
        let data = array.compactVertices (material, forShadow-> false);
        if let Ok (dmut vbo) = alias self._vbo {
            vbo:.update (alias device, cast!{u32} (array.positions.len), data);

            if (shadow && data.len != array.positions.len * 3u32) {
                let dmut shadowVBO = copy VertexBufferObject ();
                let shadowData = array.compactVertices (material, forShadow-> true);
                shadowVBO:.update (alias device, cast!{u32} (array.positions.len), shadowData);

                self._shadowVBO = (alias shadowVBO)?;
            }
        }
    }

    /**
     * Configure the shader association to the node
     * @params:
     *    - scene: the scene containing the node
     * */
    fn configureShader (mut self)
        throws BalderError
    {
        if let Ok (dmut scene) = alias self:.getScene () {
            let dmut shader = scene:.registerShaderRef (self._material.shaderConfig,                                                         
                                                         alias self):.get ();

            let matID = scene:.registerMaterialRef (self._material.config);
                        
            log::info #("IndexedMesh3D", "Registered shader to draw ", matID);

            let dmut set = shader:.allocateDescriptorSet ();

            if let Ok (dmut w) = alias self._world {
                w:.setData (0, self._transformation, commit-> true);
                set:.setUniform (UniformNames::WORLD, w);
            }

            self._material:.attach (scene:.getWindow (), alias set, matID);
            self._descSet = (alias set)?;

            // if self._castShadow {
            //     let dmut shadowShader = scene:.registerShadowShaderRef (alias self);

            //     let dmut shadowSet = shadowShader:.allocateDescriptorSet ();
            //     shadowSet:.setUniform (UniformNames::WORLD, world);
            //     self._shadowDescSet = (alias shadowSet)?;
            // }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the mesh using the command allocator
     * @assume: the command allocator is in load mode
     * @params:
     *    - cmd: the command allocator in which the mesh has to be registered
     */
    pub over register (mut self, dmut cmd : &IndexedDrawCommandAllocator) {
        if let Ok (ibo) = self._ibo {
            cmd:.registerIndexedObject (ibo.getNbPoints ());
        }
    }

    /**
     * Draw the mesh using the command allocator
     * @assume:
     *    - the command allocator is in draw mode
     *    - the shader is already selected
     * @params:
     *    - shader: the shader used to draw
     *    - cmd: the command allocator in which the mesh has to be drawn
     */
    pub over draw (self,  frame : u32, dmut _ : &Shader, dmut cmd : &IndexedDrawCommandAllocator) {
        if let Ok (s) = self._descSet {
            s.select (frame, cmd.getCommandBuffer ());
        }

        if let Ok (v) = self._vbo {
            v.select (cmd.getCommandBuffer ());
        }

        if let Ok (i) = self._ibo {
            i.select (cmd.getCommandBuffer ());
        }

        cmd:.drawNextIndexed ();
    }

    /**
     * Draw the shadow of the mesh using the command allocator
     * @assume:
     *    - the command allocator is in draw mode
     *    - the shader is already selected
     * @params:
     *    - shader: the shader used to draw (basically only a vertex shader)
     *    - cmd: the command allocator in which the mesh has to be drawn
     * */
    pub over drawShadow (self, frame : u32, dmut _ : &Shader, dmut cmd : &IndexedDrawCommandAllocator) {
        if let Ok (s) = self._shadowDescSet {
            s.select (frame, cmd.getCommandBuffer ());
        }

        if let Ok (v) = self._shadowVBO {
            v.select (cmd.getCommandBuffer ());
        }

        if let Ok (i) = self._ibo {
            i.select (cmd.getCommandBuffer ());
        }

        cmd:.drawNextIndexed ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * The material used to draw the object
     * */
    @field
    pub fn material (self)-> &Material {
        self._material
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          TRIGGERS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over updateTransformation (mut self) {
        self._super_:.updateTransformation ();
        
        if let Ok (dmut world) = alias self._world {
            world:.setData (0, self._transformation, commit-> true);
        }        
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          BUFFERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Destroy all allocated buffers on device
     * */
    fn destroyBuffers (mut self, dmut scene : &Scene) {
        let dmut win = scene:.getWindow ();
        if let Ok (dmut ibo) = alias self._ibo {
            win:.insertBin (alias ibo);
            self._ibo = none;
        }

        if let Ok (dmut vbo) = alias self._vbo {
            win:.insertBin (alias vbo);
            self._vbo = none;
        }

        if let Ok (dmut vbo) = alias self._shadowVBO {
            win:.insertBin (alias vbo);
            self._shadowVBO = none;
        }

        if let Ok (dmut world) = alias self._world {
            win:.insertBin (alias world);
            self._world = none;
        }

        if let Ok (dmut s) = alias self._descSet {
            win:.insertBin (alias s);
            self._descSet = none;
            scene:.freeShaderRef (self._material.shaderConfig, alias self);
            scene:.freeMaterialRef (self._material.matID);
        }
                
        
        // if let Ok (dmut s) = alias self._shadowDescSet {
        //     win:.insertBin (alias s);
        //     self._shadowDescSet = none;
        //     scene:.freeSadowShaderRef (self._material.shaderConfig, alias self);
        // }

        self._material:.detach ();        
    }

}
