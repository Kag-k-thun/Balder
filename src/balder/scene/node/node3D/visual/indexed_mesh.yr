in indexed_mesh;

use balder::core::{_,
                   config::_,
                   shader::_,
                   shader::buffers::_,
                   driver::_,
                   application::_};

use balder::scene::node::_;
use balder::math::_;

use balder::scene::node::node3D::visual::_;

use balder::utils::log;

/**
 * Mesh with two buffers, one for vertices, and one for indices
 */
pub class IndexedMesh3D over VisualInstance3D {

    // The buffer containing the indices of the mesh
    let dmut _ibo : &IndexBufferObject;

    // The buffer containing the vertices of the mesh
    let dmut _vbo : &VertexBufferObject = copy VertexBufferObject ();

    // The buffer containing simpler version of the vertices of the mesh
    let dmut _shadowVBO : &VertexBufferObject;

    // The material used to draw the node
    let dmut _material : &Material;

    // The buffer containing the world transformation of the visual instance
    let dmut _world : &UniformBufferObject;

    // The descriptor set used to attach buffers
    let dmut _descSet : (&DescriptorSet)? = none;

    // The descriptor set used to attach buffers
    let dmut _shadowDescSet : (&DescriptorSet)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new indexed mesh
     * @params:
     *    - device: the device used to allocate and render the mesh
     *    - indices: the indices of the points forming the mesh
     */
    pub self  (name : [c8],
               dmut scene : &Scene,
               indices : [u32],
               array : MeshArray,
               dmut material : &Material,
               shadow : bool = true)
        with super (name, alias scene, array.aabb (), shadow)
        , _ibo = copy IndexBufferObject!{u32} (scene:.getWindow ():.getVulkanDevice (), indices)
        , _shadowVBO = alias self._vbo
        , _material = alias material
        , _world = copy UniformBufferObject (scene:.getWindow ():.getVulkanDevice (), mat4::size)
        throws BalderError
    {
        self:.configure (alias scene, array, material, shadow);
    }

    /**
     * Create a new indexed mesh
     * @params:
     *    - device: the device used to allocate and render the mesh
     *    - indices: the indices of the points forming the mesh
     */
    pub self (name : [c8],
              dmut scene : &Scene,
              indices : [u16],
              dmut material : &Material,
              array : MeshArray,
              shadow : bool = true)
        with super (name, alias scene, array.aabb (), shadow)
        , _ibo = copy IndexBufferObject!{u16} (scene:.getWindow ():.getVulkanDevice (), indices)
        , _shadowVBO = alias self._vbo
        , _material = alias material
        , _world = copy UniformBufferObject (scene:.getWindow ():.getVulkanDevice (), mat4::size)
        throws BalderError
    {
        self:.configure (alias scene, array, material, shadow);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the points of the mesh and shader association for material
     * */
    fn configure (mut self, dmut scene : &Scene, array : MeshArray, material : &Material, shadow : bool)
        throws BalderError
    {
        self:.configureVertices (scene:.getWindow ():.getVulkanDevice (), array, material, shadow);
        self:.configureShader (alias scene);
    }

    /**
     * Configure the buffers containing the points of the mesh
     * */
    fn configureVertices (mut self, dmut device : &VulkanDevice, array : MeshArray, material : &Material, shadow : bool)
        throws BalderError
    {
        let data = array.compactVertices (material, forShadow-> false);
        self._vbo:.update (alias device, cast!{u32} (array.positions.len), data);

        if (shadow && data.len != array.positions.len * 3u32) {
            self._shadowVBO = copy VertexBufferObject ();
            let shadowData = array.compactVertices (material, forShadow-> true);
            self._shadowVBO:.update (alias device, cast!{u32} (array.positions.len), shadowData);
        }
    }

    /**
     * Configure the shader association to the node
     * @params:
     *    - scene: the scene containing the node
     * */
    fn configureShader (mut self, dmut scene : &Scene)
        throws BalderError
    {
        let dmut shader = scene:.registerShaderRef (self._material.shaderConfig, alias self):.get ();
        log::info #("IndexedMesh3D", "Registered shader to draw");

        let dmut set = shader:.allocateDescriptorSet ();

        self._world:.setData (0, self._transformation, commit-> true);
        set:.setUniform (UniformNames::WORLD, self._world);

        if let Ok (cam) = scene:.getCamera () {
            cam.bind (alias set);
        }

        self._material:.attach (scene:.getWindow (), alias set);
        self._descSet = (alias set)?;

        // if self._castShadow {
        //     let dmut shadowShader = scene:.registerShadowShaderRef (alias self);

        //     let dmut shadowSet = shadowShader:.allocateDescriptorSet ();
        //     shadowSet:.setUniform (UniformNames::WORLD, world);
        //     self._shadowDescSet = (alias shadowSet)?;
        // }

        self:.transformationChanged ():.connect (scene:.getWindow ():.getSlotEmitter (), &self:.updateUBO);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register the mesh using the command allocator
     * @assume: the command allocator is in load mode
     * @params:
     *    - cmd: the command allocator in which the mesh has to be registered
     */
    pub over register (mut self, dmut cmd : &IndirectCommandAllocator) {
        cmd:.registerIndexedObject (self._ibo.getNbPoints ());
    }

    /**
     * Draw the mesh using the command allocator
     * @assume:
     *    - the command allocator is in draw mode
     *    - the shader is already selected
     * @params:
     *    - shader: the shader used to draw
     *    - cmd: the command allocator in which the mesh has to be drawn
     */
    pub over draw (self, dmut _ : &Shader, dmut cmd : &IndirectCommandAllocator) {
        if let Ok (s) = self._descSet {
            s.select ();
            self._vbo.select ();
            self._ibo.select ();

            cmd:.drawNextIndexed ();
        }
    }

    /**
     * Draw the shadow of the mesh using the command allocator
     * @assume:
     *    - the command allocator is in draw mode
     *    - the shader is already selected
     * @params:
     *    - shader: the shader used to draw (basically only a vertex shader)
     *    - cmd: the command allocator in which the mesh has to be drawn
     * */
    pub over drawShadow (self, dmut _ : &Shader, dmut cmd : &IndirectCommandAllocator) {
        if let Ok (s) = self._shadowDescSet {
            s.select ();
            self._shadowVBO.select ();
            self._ibo.select ();

            cmd:.drawNextIndexed ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * The material used to draw the object
     * */
    @field
    pub fn material (self)-> &Material {
        self._material
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          TRIGGERS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn updateUBO (mut self) {
        self._world:.setData (0, self._transformation, commit-> true);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self.__super__:.dispose ();
            let dmut win = self._scene:.getWindow ();

            win:.insertBin (alias self._vbo);
            win:.insertBin (alias self._shadowVBO);
            win:.insertBin (alias self._ibo);
            win:.insertBin (alias self._world);

            self._scene:.freeShaderRef (self._material.shaderConfig, alias self);
            if let Ok (dmut s) = alias self._descSet {
                win:.insertBin (alias s);
                self._descSet = none;
            }

            if let Ok (dmut s) = alias self._shadowDescSet {
                win:.insertBin (alias s);
                self._shadowDescSet = none;
            }

            self._material:.detach ();
            self:.transformationChanged ():.disconnect (&self:.updateUBO);
        }
    }

}
