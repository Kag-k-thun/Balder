in solid;

use balder::core::{_,
                   config::_,
                   shader::_,
                   shader::buffers::_,
                   driver::_,
                   application::_};

use balder::scene::node::_;
use balder::math::_;

use balder::scene::node::node3D::visual::{_, material::_};


use ::std::{conv, fs::_};
use ::assimp::_;

/**
 * A solid object model is a 3D model containing multiple meshes
 * */
pub class SolidObjectModel over Node3D {

    let mut _dimension : vec3 = vec3 ();
    let mut _centroid : vec3 = vec3 ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          LOADING FROM FILE          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a 3D index mesh from a file
     * @params:
     *   - path: the project path of the file to load
     *   - window: the window managing the resources
     * @returns: the mesh
     * */
    pub self fromFile (name : [c8], dmut scene : &Scene, path : [c8])-> dmut &IndexedMesh3D
        with super (name, alias scene)
        throws BalderError
    {
        let filePath = balder::utils::path::projectPath (path);

        unsafe {
            let sceneAI = aiImportFile (filePath.toStr ().toStringZ (),
                                      aiPostProcessSteps::TargetRealtime_Quality | aiPostProcessSteps::ConvertToLeftHanded);

            if sceneAI == null {
                throw copy BalderError ("Failed to load model from file " ~ filePath.toStr ());
            }

            {
                let dir = filePath.parent ();
                let (mins, maxs) = self.computeMinMax (sceneAI.rootNode (), sceneAI);

                self._dimension = maxs - mins;
                self._centroid = (maxs + mins) / 2.f;

                let root = sceneAI.rootNode ();
                self:.processSolidNode (root, sceneAI, dir);
            } exit {
                aiReleaseImport (sceneAI);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          BOUND COMPUTATIONS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the bounds of the scene
     * @returns:
     * - 0: the minimum bound
     * - 1: the maximum bound
     */
    @unsafe
    fn computeMinMax (self, node : *aiNode, scene : *aiScene)-> (vec3, vec3) {
        let mut min = vec3 (), mut max = vec3 ();
        for i in 0 .. node.numMeshes () {
            let mesh = scene.meshes () [i];
            let (aux_min, aux_max) = self.computeMinMax (mesh);
            min = self.updateMin (min, aux_min);
            max = self.updateMax (max, aux_max);
        }

        for i in 0 .. (*node).mNumChildren {
            let child = node.children () [i];
            let (aux_min, aux_max) = self.computeMinMax (child, scene);
            min = self.updateMin (min, aux_min);
            max = self.updateMax (max, aux_max);
        }

        (min, max)
    }

    /**
     * Compute the bound of a mesh
     */
    @unsafe
    fn computeMinMax (self, mesh : *aiMesh)-> (vec3, vec3) {
        let mut min = vec3 (), mut max = vec3 ();
        for i in 0u32 .. mesh.numVertices () {
            min = self.updateMin (min, mesh.vertices () [i]);
            max = self.updateMax (max, mesh.vertices () [i]);
        }

        (min, max)
    }

    /**
     * @returns: the minimum between the two vectors (field by field)
     */
    fn updateMin {T} (self, min : vec3, aux : T)-> vec3 {
        let min_x = if (min.x > aux.x) { aux.x } else { min.x }
        let min_y = if (min.y > aux.y) { aux.y } else { min.y }
        let min_z = if (min.z > aux.z) { aux.z } else { min.z }

        makeVec3 (min_x, min_y, min_z)
    }

    /**
     * @returns: the maximum between the two vectors (field by field)
     */
    fn updateMax {T} (self, max : vec3, aux : T)-> vec3 {
        let max_x = if (max.x < aux.x) { aux.x } else { max.x }
        let max_y = if (max.y < aux.y) { aux.y } else { max.y }
        let max_z = if (max.z < aux.z) { aux.z } else { max.z }

        makeVec3 (max_x, max_y, max_z)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          LOADING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read all the meshes and material inside a node and its childs, and register the meshes inside the solid object
     * @info: the window resource manager is used to load Managed resources (e.g. textures)
     * */
    @unsafe
    fn processSolidNode (mut self, node : *aiNode, scene : *aiScene, dir : Path)
        throws BalderError
    {
        for i in 0 .. node.numMeshes () {
            let mesh = scene.meshes ()[i];
            self:.processSolidMesh (mesh, scene, dir);
        }

        for i in 0 .. (*node).mNumChildren {
            let child = node.children ()[i];
            self:.processSolidNode (child, scene, dir);
        }
    }

    /**
     * Read a mesh and its associated material
     * */
    @unsafe
    fn processSolidMesh (mut self, mesh : *aiMesh, scene : *aiScene, dir : Path)
        throws BalderError
    {
        scene;
        dir;

        let dmut material = // if (mesh.materialIndex () > 0 && mesh.textureCoords (0) != null) {
        //     let innerMat = scene.materials () [mesh.materialIndex ()];
        //     self:.processMaterial (alias window, innerMat, dir)
        // } else
        {
            let dmut mt = copy ColorMaterial ();
            mt:.setColor (makeVec4 (1.f, 1.f, 1.f, 1.f));

            alias mt
        };


        let array = self:.loadSolidMeshVertices (mesh, material);
        let dmut indices = copy [0u32 ; 3 * mesh.numFaces ()];

        for i in 0u32 .. mesh.numFaces () {
            let face = mesh.faces () [i];
            if (face.mNumIndices != 3u32) throw copy BalderError ("Object is not triangulated");
            for j in 0u32 .. 3u32 {
                indices [i * 3u32 + j] = face.mIndices [j];
            }
        }

        let chName = "mesh_" ~ std::conv::to!{[c8]} (self._childs.len);

        let dmut indexMesh = copy IndexedMesh3D (chName,
                                                 alias self._scene,
                                                 indices,
                                                 array,
                                                 alias material);

        self:.addChild (chName, alias indexMesh);
    }

    /**
     * Process a solid mesh whose material is a simple color material
     * */
    @unsafe
    fn loadSolidMeshVertices (mut self, mesh : *aiMesh, material : &Material)-> MeshArray {
        let mut array = MeshArray ();
        array.positions = copy [vec3 () ; mesh.numVertices ()];
        if mesh.normals () != null && material.shaderConfig.hasEntry (VertexEntry::NORMALS) {
            array.normals = copy [vec3 () ; mesh.numVertices ()];
        }

        if mesh.tangents () != null && material.shaderConfig.hasEntry (VertexEntry::TANGENTS) {
            array.tangents = copy [vec3 () ; mesh.numVertices ()];
        }

        if mesh.textureCoords (0) != null && material.shaderConfig.hasEntry (VertexEntry::TEX_UV) {
            array.textureUVs = copy [vec2 () ; mesh.numVertices ()];
        }

        if mesh.textureCoords (1) != null && material.shaderConfig.hasEntry (VertexEntry::TEX_UV2) {
            array.textureUVs2 = copy [vec2 () ; mesh.numVertices ()];
        }

        if mesh.colors (0) != null && material.shaderConfig.hasEntry (VertexEntry::COLORS) {
            array.colors = copy [vec3 () ; mesh.numVertices ()];
        }

        for i in 0 .. mesh.numVertices () {
            let pos = mesh.vertices ()[i];
            array.positions [i] = makeVec3 (pos.x - self._centroid.x, pos.y - self._centroid.y, pos.z - self._centroid.z);

            if array.normals.len > i {
                let norm = mesh.normals () [i];
                array.normals [i] = makeVec3 (norm.x, norm.y, norm.z);
            }

            if array.tangents.len > i {
                let tan = mesh.tangents () [i];
                array.tangents [i] = makeVec3 (tan.x, tan.y, tan.z);
            }

            if array.textureUVs.len > i {
                let tan = mesh.textureCoords (0) [i];
                array.textureUVs [i] = makeVec2 (tan.x, tan.y);
            }

            if array.textureUVs2.len > i {
                let tan = mesh.textureCoords (1) [i];
                array.textureUVs2 [i] = makeVec2 (tan.x, tan.y);
            }

            if array.colors.len > i {
                let tan = mesh.colors (0) [i];
                array.colors [i] = makeVec3 (tan.r, tan.g, tan.b);
            }
        }

        array
    }



}
