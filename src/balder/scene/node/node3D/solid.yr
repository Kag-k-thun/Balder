in solid;

use balder::core::{_,
                   config::{_, shader::_},
                   shader::_,
                   shader::buffers::_,
                   driver::_,
                   application::_};

use balder::scene::node::_;
use balder::math::_;
use balder::utils::log;

use balder::scene::node::node3D::visual::{_, material::_};


use ::std::{conv, fs::_};
use ::assimp::_;

/**
 * A solid object model is a 3D model containing multiple meshes
 * */
pub class SolidObjectModel over Node3D {

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          LOADING FROM FILE          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a 3D index mesh from a file
     * @params:
     *   - path: the project path of the file to load
     *   - window: the window managing the resources
     * @returns: the mesh
     * */
    pub self fromFile (name : [c8], dmut parent : &Node, path : [c8])
        with super (name, alias parent)
        throws BalderError
    {
        let filePath = balder::utils::path::projectPath (path);

        unsafe {
            let sceneAI = aiImportFile (filePath.toStr ().toStringZ (),
                                      aiPostProcessSteps::TargetRealtime_Quality | aiPostProcessSteps::ConvertToLeftHanded);

            if sceneAI == null {
                throw copy BalderError ("Failed to load model from file " ~ filePath.toStr ());
            }

            {
                let dir = filePath.parent ();
                let (mins, maxs) = self.computeMinMax (sceneAI.rootNode (), sceneAI);
                let dimension = (maxs - mins);
                let centroid = (maxs + mins) / 2.f;
                
                let s = std::algorithm::comparison::max (std::algorithm::comparison::max (dimension.x, dimension.y), dimension.z);
                let scale = makeVec3 (1.0f / s, 1.0f / s, 1.0f / s);                
                let position = makeVec3 (-centroid.x, -mins.y, -centroid.z);
                
                let loadTransform = math::utils::scaling (scale) *  
                    math::utils::translation (position);
                
                let root = sceneAI.rootNode ();
                self:.processSolidNode (root, sceneAI, dir, loadTransform);
                                                                     
            } exit {
                aiReleaseImport (sceneAI);
            }
        }
    }
        
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          BINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onEnter (mut self, dmut _ : &Scene) {}
    pub over onExit (mut self, dmut _ : &Scene) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          BOUND COMPUTATIONS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the bounds of the scene
     * @returns:
     * - 0: the minimum bound
     * - 1: the maximum bound
     */
    @unsafe
    fn computeMinMax (self, node : *aiNode, scene : *aiScene)-> (vec3, vec3) {
        let mut min = vec3 (), mut max = vec3 ();
        for i in 0 .. node.numMeshes () {
            let mesh = scene.meshes () [i];
            let (aux_min, aux_max) = self.computeMinMax (mesh);
            min = self.updateMin (min, aux_min);
            max = self.updateMax (max, aux_max);
        }

        for i in 0 .. (*node).mNumChildren {
            let child = node.children () [i];
            let (aux_min, aux_max) = self.computeMinMax (child, scene);
            min = self.updateMin (min, aux_min);
            max = self.updateMax (max, aux_max);
        }

        (min, max)
    }

    /**
     * Compute the bound of a mesh
     */
    @unsafe
    fn computeMinMax (self, mesh : *aiMesh)-> (vec3, vec3) {
        let mut min = vec3 (), mut max = vec3 ();
        for i in 0u32 .. mesh.numVertices () {
            min = self.updateMin (min, mesh.vertices () [i]);
            max = self.updateMax (max, mesh.vertices () [i]);
        }

        (min, max)
    }

    /**
     * @returns: the minimum between the two vectors (field by field)
     */
    fn updateMin {T} (self, min : vec3, aux : T)-> vec3 {
        let min_x = if (min.x > aux.x) { aux.x } else { min.x }
        let min_y = if (min.y > aux.y) { aux.y } else { min.y }
        let min_z = if (min.z > aux.z) { aux.z } else { min.z }

        makeVec3 (min_x, min_y, min_z)
    }

    /**
     * @returns: the maximum between the two vectors (field by field)
     */
    fn updateMax {T} (self, max : vec3, aux : T)-> vec3 {
        let max_x = if (max.x < aux.x) { aux.x } else { max.x }
        let max_y = if (max.y < aux.y) { aux.y } else { max.y }
        let max_z = if (max.z < aux.z) { aux.z } else { max.z }

        makeVec3 (max_x, max_y, max_z)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          LOADING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read all the meshes and material inside a node and its childs, and register the meshes inside the solid object
     * @info: the window resource manager is used to load Managed resources (e.g. textures)
     * */
    @unsafe
    fn processSolidNode (mut self, node : *aiNode, scene : *aiScene, dir : Path, loadTransform : mat4)
        throws BalderError
    {
        for i in 0 .. node.numMeshes () {
            let mesh = scene.meshes ()[i];
            self:.processSolidMesh (mesh, scene, dir, loadTransform);
        }

        for i in 0 .. (*node).mNumChildren {
            let child = node.children ()[i];
            self:.processSolidNode (child, scene, dir, loadTransform);
        }
    }

    /**
     * Read a mesh and its associated material
     * */
    @unsafe
    fn processSolidMesh (mut self, mesh : *aiMesh, scene : *aiScene, dir : Path, loadTransform : mat4)
        throws BalderError
    {        
        let dmut material = if scene.numMaterials () > mesh.materialIndex () {
            let innerMat = scene.materials () [mesh.materialIndex ()];
            self:.processMaterial (mesh, innerMat, dir)
        } else {        
            let dmut mt = copy ConstantMaterial (MaterialConfig ());            
            alias mt
        };

        let array = self:.loadSolidMeshVertices (mesh, material, loadTransform);
        let dmut indices = copy [0u32 ; 3 * mesh.numFaces ()];
        
        for i in 0u32 .. mesh.numFaces () {
            let face = mesh.faces () [i];
            if (face.mNumIndices != 3u32) throw copy BalderError ("Object is not triangulated");
            for j in 0u32 .. 3u32 {
                indices [i * 3u32 + j] = face.mIndices [j];
            }
        }

        let chName = "mesh_" ~ std::conv::to!{[c8]} (self._childs.len);

        let dmut _ = copy IndexedMesh3D (chName,
                                         alias self,
                                         indices,
                                         array,
                                         alias material);            
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          MATERIAL          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a material from a material assump description
     * */
    @unsafe
    fn processMaterial (mut self, mesh : *aiMesh, mat : *aiMaterial, dir : Path)-> dmut &Material
        throws BalderError
    {        
        let mut config = MaterialConfig ();
        config.diffuseColor = self.readColor (mat.diffuseColor ());
        config.ambientColor = self.readColor (mat.ambientColor ());
        config.specularColor = self.readColor (mat.specularColor ());
        config.emissiveColor = self.readColor (mat.emissiveColor ());
        config.transparentColor = self.readColor (mat.transparentColor ());

        config.shadingModel = mat.shadingModel ();
        config.anisotropy = mat.anisotropy ();

        config.illum = mat.illum ();
        config.shininess = mat.shininess ();
        config.opacity = mat.opacity ();
        config.refraction = mat.refracti ();
                        
        if mat.textureCount (aiTextureType::DIFFUSE) > 0 && mesh.numUVComponents (0) > 0 {
            let ainame = mat.texture (aiTextureType::DIFFUSE, 0);

            let name = copy ainame.data [0 .. ainame.len + 1];
            let path = dir.push (name);

            // if mat.textureCount (aiTextureType::SPECULAR) > 0 {
            //     let name = mat.texture (aiTextureType::SPECULAR, 0);
            //     let path = dir.push (name.data [0 .. name.len + 1]);

            //     let mut shine = 1.f;
            //     if (mat.aiGetMaterialFloatArray ("$mat.shininess"s8.ptr, 0u32, 0u32, alias &shine, null) != aiReturn::SUCCESS) {
            //         shine = 1.0f;
            //     }
                
            //     return copy DiffuseSpecularTextureMaterial (path, spec_path, shine);                
            // }

            // if mat.textureCount (aiTextureType::DISPLACEMENT) > 0 {
            //     let name = mat.texture (aiTextureType::DISPLACEMENT, 0);
            //     let path = dir.push (name.data [0 .. name.len + 1]);
                            
            //     return copy DiffuseDisplacementTextureMaterial (path, spec_path, shine);                
            // }

            let fname = if std::fs::sys::isFile (path) {
                path.toStr ()
            } else { name };
                    
            return copy DiffuseTextureMaterial (fname, config);        
        }
        
        return copy ConstantMaterial (config);
    }

    /**
     * Transform an assimp vector into a balder vector
     * */
    fn readColor (self, color : aiColor4D)-> vec3 {
        makeVec3 (color.r, color.g, color.b)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          VERTICES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Process a solid mesh whose material is a simple color material
     * */
    @unsafe
    fn loadSolidMeshVertices (mut self, mesh : *aiMesh, material : &Material, loadTransform : mat4)-> MeshArray {
        let mut array = MeshArray ();
        array.positions = copy [vec3 () ; mesh.numVertices ()];
        if mesh.normals () != null && VertexEntry::NORMALS in material.shaderConfig.entries {
            array.normals = copy [vec3 () ; mesh.numVertices ()];
        }

        if mesh.tangents () != null && VertexEntry::TANGENTS in material.shaderConfig.entries {
            array.tangents = copy [vec3 () ; mesh.numVertices ()];
        }

        if mesh.textureCoords (0) != null && VertexEntry::TEX_UV in material.shaderConfig.entries {
            array.textureUVs = copy [vec2 () ; mesh.numVertices ()];
        }

        if mesh.textureCoords (1) != null && VertexEntry::TEX_UV2 in material.shaderConfig.entries {
            array.textureUVs2 = copy [vec2 () ; mesh.numVertices ()];
        }

        if mesh.colors (0) != null && VertexEntry::COLORS in material.shaderConfig.entries {
            array.colors = copy [vec3 () ; mesh.numVertices ()];
        }

        for i in 0 .. mesh.numVertices () {
            let pos = mesh.vertices ()[i];
            let v = makeVec4 (pos.x, pos.y, pos.z, 1.f);
            array.positions [i] = (loadTransform * v).xyz;            
            
            if array.normals.len > i {
                let norm = mesh.normals () [i];
                array.normals [i] = makeVec3 (norm.x, norm.y, norm.z);
            }

            if array.tangents.len > i {
                let tan = mesh.tangents () [i];
                array.tangents [i] = makeVec3 (tan.x, tan.y, tan.z);
            }

            if array.textureUVs.len > i {
                let tan = mesh.textureCoords (0) [i];
                array.textureUVs [i] = makeVec2 (tan.x, tan.y);
            }

            if array.textureUVs2.len > i {
                let tan = mesh.textureCoords (1) [i];
                array.textureUVs2 [i] = makeVec2 (tan.x, tan.y);
            }

            if array.colors.len > i {
                let tan = mesh.colors (0) [i];
                array.colors [i] = makeVec3 (tan.r, tan.g, tan.b);
            }
        }

        array
    }



}
