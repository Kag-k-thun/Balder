in camera;

mod ::persp;
mod ::ortho;

use balder::core::{error, driver::_};
use balder::scene::_;
use balder::core::dispose;
use balder::math::_;

use balder::core::shader::{_, buffers::_};
use balder::core::{application::_, shader::_, driver::_, config::_};

use balder::utils::log;

pub def PerspectiveCamera : persp::PerspectiveCamera;
pub def OrthoCamera : ortho::OrthoCamera;

/**
 * Ancestor class of all cameras
 * */
@abstract
pub class Camera over Node3D {

    // The target of the camera
    let mut _target : vec3 = makeVec3 (0.f, 0.f, 0.f);

    let mut _near : f32 = 0.1f;
    let mut _far : f32 = 100.f;

    let mut _proj : mat4 = mat4 ();
    let mut _view : mat4 = mat4 ();
    let mut _viewProj : mat4 = mat4 ();


    // The uniform buffer object containing the matrices of the camera
    let dmut _ubo : (&UniformBufferObject)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (name : [c8], dmut parent : &Node)
        with super (name, alias parent)
    {
        self._position = makeVec3 (-10.f, 10.f, -10.f);
        self._rotation = makeVec3 (0.f, 1.f, 0.);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    @field
    pub fn target (self)-> vec3 {
        self._target
    }

    @field
    pub fn target (mut self, v : vec3) {
        self._target = v;
        self:.updateTransformation ();
    }

    @field
    pub fn near (self)-> f32 {
        self._near
    }

    @field
    pub fn near (mut self, near : f32) {
        self._near = near;
        self:.updateTransformation ();
    }

    @field
    pub fn far (self)-> f32 {
        self._far
    }

    @field
    pub fn far (mut self, far : f32) {
        self._far = far;
        self:.updateTransformation ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMPUTATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over updateTransformation (mut self) atomic self {
        self:.computeView ();
        self:.computeProj ();

        self._viewProj = self._proj * self._view;
        if let Ok (dmut u) = alias self._ubo {
            u:.setData (0, self._proj, commit-> false);
            u:.setData (mat4::size, self._view, commit-> false);
            u:.setData (2 * mat4::size, self._viewProj, commit-> true);
        }
    }

    /**
     * Compute the view matrix
     * */
    fn computeView (mut self) {
        self._view = lookAt!{f32} (self._position, self._target, self._rotation);
    }

    /**
     * Compute the projection matrix
     * */
    fn computeProj (mut self);

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          BINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onEnter (mut self, dmut scene : &Scene) {
        if let Ok (dmut ubo) = alias self._ubo {
            scene:.getWindow ():.insertBin (alias ubo);
        }

        {
            let dmut ubo = copy UniformBufferObject (scene:.getWindow ():.getVulkanDevice (), mat4::size * 3);
            self._ubo = (alias ubo)?;
        } catch {
            err => {
                log::error #("Camera", "Failed to allocate ubo for the camera", err);
            }
        }
    }

    pub over onExit (mut self, dmut scene : &Scene) {
        log::info #("Camera", "onExit");
        if let Ok (dmut ubo) = alias self._ubo {
            scene:.getWindow ():.insertBin (alias ubo);
            self._ubo = none;
        }
    }

    /**
     * @returns: the uniform buffer object of the camera
     * */
    pub fn getUBO (mut self)-> dmut (&UniformBufferObject)? {
        alias self._ubo
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DISPOSE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if self._ubo.hasValue {
                log::error #("Camera", "Forgot to remove camera from the scene before disposing it");
            }
        }
    }

}
