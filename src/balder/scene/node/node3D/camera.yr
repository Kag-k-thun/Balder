in camera;

use balder::core::{error, driver::_};
use balder::scene::_;
use balder::core::dispose;
use balder::math::_;

use balder::core::shader::{_, buffers::_};
use balder::core::{application::_, shader::_, driver::_, config::_};

use balder::utils::log;

pub class Camera over Node3D {

    // The target of the camera
    let mut _target : vec3 = makeVec3 (0.f, 0.f, 0.f);

    // True if use a ortho instead of a perspective projection
    let mut _ortho : bool = false;

    let mut _near : f32 = 0.01f;
    let mut _far : f32 = 100.f;

    prot { // perspective

        // The fov angle of the camera
        let mut _fov : f32 = 90.f;
        let mut _aspect : f32 = 1920.f / 768.f;

    }
    
    prot { // ortho
        let mut _left : f32 = -10.f;
        let mut _right : f32 = 10.f;

        let mut _top : f32 = -10.f;
        let mut _bottom : f32 = 10.f;
    }

    let mut _proj : mat4 = mat4 ();
    let mut _view : mat4 = mat4 ();
    let mut _viewProj : mat4 = mat4 ();

    prot { // window
        // The uniform buffer object containing the matrices of the camera
        let dmut _ubo : &UniformBufferObject;
    }

    pub self (name : [c8], dmut scene : &Scene)
        with super (name,
                    alias scene,
                    position-> makeVec3 (-10.f, 10.f, -10.f),
                    rotation-> makeVec3 (0.f, 1.f, 0.f))
        , _ubo = copy UniformBufferObject (scene:.getWindow ():.getVulkanDevice (), mat4::size * 3)

        throws BalderError
    {
        self._aspect = cast!f32 (scene.width) / cast!f32 (scene.height);
        scene:.aspectChanged ():.connect (self._scene:.getWindow ():.getSlotEmitter (), &self:.updateAspect);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    @field
    pub fn target (self)-> vec3 {
        self._target
    }

    pub fn setTarget (mut self, v : vec3) {
        self._target = v;
        self:.updateTransformation ();
    }

    @field
    pub fn fov (self)-> f32 {
        self._fov
    }

    pub fn setFov (mut self, fov : f32) {
        self._fov = fov;
        self:.updateTransformation ();
    }

    @field
    pub fn aspect (self)-> f32 {
        self._aspect
    }

    pub fn setAspect (mut self, aspect : f32) {
        self._aspect = aspect;
        self:.updateTransformation ();
    }

    @field
    pub fn left (self)-> f32 {
        self._left
    }

    pub fn setLeft (mut self, left : f32) {
        self._left = left;
        self:.updateTransformation ();
    }

    @field
    pub fn right (self)-> f32 {
        self._right
    }

    pub fn setRight (mut self, right : f32) {
        self._right = right;
        self:.updateTransformation ();
    }

    @field
    pub fn top (self)-> f32 {
        self._top
    }

    pub fn setTop (mut self, top : f32) {
        self._top = top;
        self:.updateTransformation ();
    }


    @field
    pub fn bottom (self)-> f32 {
        self._bottom
    }

    pub fn setBottom (mut self, bottom : f32) {
        self._bottom = bottom;
        self:.updateTransformation ();
    }

    @field
    pub fn near (self)-> f32 {
        self._near
    }

    pub fn setNear (mut self, near : f32) {
        self._near = near;
        self:.updateTransformation ();
    }

    @field
    pub fn far (self)-> f32 {
        self._far
    }

    pub fn setFar (mut self, far : f32) {
        self._far = far;
        self:.updateTransformation ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMPUTATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over updateTransformation (mut self) atomic self {
        self._view = lookAt!{f32} (self._position, self._target, self._rotation);

        if self._ortho {
            self._proj = ortho!{f32} (self._left, self._right, self._bottom, self._top, self._near, self._far);
        } else {
            self._proj = perspective!{f32} (self._fov, self._aspect, self._near, self._far);
        }

        self._viewProj = self._proj * self._view;
        self._ubo:.setData (0, self._proj, commit-> false);
        self._ubo:.setData (mat4::size, self._view, commit-> false);
        self._ubo:.setData (2 * mat4::size, self._viewProj, commit-> true);
    }

    fn updateAspect (mut self, w : u32, h : u32) {
        self:.setAspect (cast!f32 (w) / cast!f32 (h));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          BINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn bind (self, dmut desc : &DescriptorSet) {
        desc:.setUniform (UniformNames::CAMERA, self._ubo)?;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DISPOSE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._scene:.aspectChanged ():.disconnect (&self:.updateAspect);
            self._scene:.getWindow ():.insertBin (alias self._ubo);
        }
    }

}
