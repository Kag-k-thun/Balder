in light;

use balder::core::{error, driver::_};
use balder::scene::_;
use balder::core::dispose;
use balder::math::_;

use balder::utils::log;

pub enum : u32
| DIRECTION = 1
| POINT     = 2
| SPOT      = 3
| AREA      = 4
 -> LightType;

/**
 * A light in the scene
 * */
pub class Light over Node3D {
    
    let dmut _scene : (&Scene)? = none;
    let mut _id : u32 = u32::max;
    
    let mut _color : vec3 = makeVec3 (1.f, 1.f, 1.f);    
    let mut _type : LightType = LightType::DIRECTION;
    let _castShadow : bool;    

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * @params:
     *    - castShadow: true if the light cast shadows on the scene
     * */
    pub self (name : [c8], dmut parent : &Node, castShadow : bool = false)        
        with super (name, alias parent)
        , _castShadow = castShadow
    {}            

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    @field
    pub fn castShadow (self)-> bool {
        self._castShadow
    }

    @field
    pub fn color (self)-> vec3 {
        self._color
    }

    @field
    pub fn type (self)-> LightType {
        self._type
    }

    /**
     * Get the index of the light in the composition shader 
     * */
    pub fn getIndex (self)-> u32 {
        self._id
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    @field
    pub fn type (mut self, k : LightType) {
        self._type = k;
        self:.updateTransformation ();
    }

    @field
    pub fn color (mut self, c : vec3) {
        self._color = c;
        self:.updateTransformation ();
    }

    /**
     * Set the index of the light in the composition shader 
     * */
    pub fn setIndex (mut self, id : u32) {
        self._id = id;
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          UPDATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over updateTransformation (mut self) {
        if let Ok (dmut scene) = alias self._scene {
            log::info #("Light", "update", self._type);
            scene:.updateLight (alias self);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          BINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    pub over onEnter (mut self, dmut scene : &Scene) {
        log::info #("Light", "enter");
        self._scene = (alias scene)?;
        scene:.registerLight (alias self);
    }

    pub over onExit (mut self, dmut scene : &Scene) {
        log::info #("Light", "exit");
        scene:.freeLight (alias self);
        
        self._scene = none;
        self._id = u32::max;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DISPOSE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    impl Disposable {
        pub over dispose (mut self) {
            if self._scene.hasValue {
                log::error #("Light", "Light was not detached from scene");
            }
        }
    }
    
} 
