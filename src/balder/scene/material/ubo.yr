mod balder::scene::material::ubo;

import balder::core::vulkan::utils;
import balder::core::vulkan::_;
import balder::core::error;
import vulkan::_;

import std::collection::map;

/**
 * Ancestor of all materials
 */
pub class @abstract UniformBufferObject {

    // The buffers containing the uniform values
    let dmut _uniformBuffers = HashMap!{[c32], dmut &Buffer}::new ();

    // let dmut _uniformTextures = HashMap!{[c32], dmut &Texture2D}::new ();

    /**
     * Create an empty ubo
     */
    prot self () {}

    /**
     * @returns: true iif the ubo has a buffer named 'name'
     */
    pub def @final hasUniform (self, name : [c32])-> bool {
        name in self._uniformBuffers
    }

    /**
     * Bind the uniform buffers to a descriptor set
     * @params:
     *    - desc: the descriptor set to bind
     */
    pub def @final bind (mut self, dmut desc : &DescriptorSet)
        throws &BalderError
    {
        for j, _ in self._uniformBuffers {
            let dmut b = self._uniformBuffers:.find (j);
            match ref b {
                Ok (dmut buf : _) => {
                    desc:.bind (j, alias buf);
                }
            }
        }
    }
   
    /**
     * @returns: the buffer associated to the value 'name'
     */
    pub def @final getUniform (mut self, name : [c32])-> dmut &Buffer
        throws &BalderError
    {
        import std::conv;
        
        let dmut m = self._uniformBuffers:.find (name);
        match ref m {
            Ok (dmut buf : _) => { return alias buf; }
            _ => {
                throw BalderError::new ("Uniform buffer has no uniform field named '"s8 ~ to![c8] (name) ~ "'"s8);
            }
        };
    }
    
    impl Disposable {

        pub over dispose (mut self) {
            for i, _ in self._uniformBuffers {
                let dmut m = self._uniformBuffers:.find (i);
                match ref m {
                    Ok (dmut uni : _) => uni:.dispose ();
                }                
            }

            self._uniformBuffers:.clear ();
        }
        
    }
    
}

/**
 * @template:
 *      - T: the structure describing the material
 */
pub class UniformBufferObject {struct T} over UniformBufferObject {

    /**
     * Create a material and all its buffers
     */
    pub self (dmut device : &VulkanDevice)
        throws &BalderError
    {
        cte for i in 0us .. (__pragma!field_offsets (T)).len {
            let type = getDescriptorType!{__pragma!field_type (T, (__pragma!field_names (T))[i])} ();
            cte if (type == VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) {
                let dmut buf = device:.getMemoryAllocator ():.allocBuffer (
                    cast!u64 (sizeof (__pragma!field_type (T, (__pragma!field_names (T))[i]))),
                    cast!u32 (VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |
                              VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT),
                    cast!u32 (VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
                    );
                
                self._uniformBuffers:.insert ((__pragma!field_names (T))[i], alias buf);
            } else {
                cte assert (false, "Unknwon uniform type");           
            }
        }
    }
    
}
