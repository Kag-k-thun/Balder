mod balder::math::matrix;
import balder::math::vector;
import std::io;
import std::math;

/***
 * ==================================================================================
 * ==================================================================================
 * =========================           MATRIX ERROR             =====================
 * ==================================================================================
 * ==================================================================================
 */

pub class MatrixError over Exception {

    pub let msg : [c8];
    
    pub self (msg : [c8]) with msg = msg {}

    impl Streamable {

        pub over toStream (self, dmut stream : &StringStream) {
            self::super.toStream (alias stream);
        }
        
    }
    
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================           MATRIX TYPES             =====================
 * ==================================================================================
 * ==================================================================================
 */
    
pub struct    
| a1 : f32 = 1.f
| b1 : f32 = 0.f
| a2 : f32 = 0.f
| b2 : f32 = 1.f
 -> mat2;

pub def makeMat2 (a1 : f32, b1 : f32, a2 : f32, b2 : f32)-> mat2 {
    mat2 (a1-> a1, b1-> b1,
          a2-> a2, b2-> b2
          )
}


pub struct
| a1 : f32 = 1.f
| b1 : f32 = 0.f
| c1 : f32 = 0.f
| a2 : f32 = 0.f
| b2 : f32 = 1.f
| c2 : f32 = 0.f
| a3 : f32 = 0.f
| b3 : f32 = 0.f
| c3 : f32 = 1.f
 -> mat3;

pub def makeMat3 (a1 : f32, b1 : f32, c1 : f32, a2 : f32, b2 : f32, c2 : f32, a3 : f32, b3 : f32, c3 : f32)-> mat3 {
    mat3 (a1-> a1, b1-> b1, c1-> c1,
          a2-> a2, b2-> b2, c2-> c2,
          a3-> a3, b3-> b3, c3-> c3
          )
}

pub struct
| a1 : f32 = 1.f
| b1 : f32 = 0.f
| c1 : f32 = 0.f
| d1 : f32 = 0.f
| a2 : f32 = 0.f
| b2 : f32 = 1.f
| c2 : f32 = 0.f
| d2 : f32 = 0.f
| a3 : f32 = 0.f
| b3 : f32 = 0.f 
| c3 : f32 = 1.f
| d3 : f32 = 0.f
| a4 : f32 = 0.f
| b4 : f32 = 0.f
| c4 : f32 = 0.f
| d4 : f32 = 1.f
 -> mat4;

pub def makeMat4 (a1 : f32, b1 : f32, c1 : f32, d1 : f32, a2 : f32, b2 : f32, c2 : f32, d2 : f32, a3 : f32, b3 : f32, c3 : f32, d3 : f32, a4 : f32, b4 : f32, c4 : f32, d4 : f32)-> mat4 {
    mat4 (a1-> a1, b1-> b1, c1-> c1, d1-> d1,
          a2-> a2, b2-> b2, c2-> c2, d2-> d2,
          a3-> a3, b3-> b3, c3-> c3, d3-> d3,
          a4-> a4, b4-> b4, c4-> c4, d4-> d4
          )
}

pub def Matrix {2u32} ()-> mat2 {
    mat2 ()
}

pub def Matrix {3u32} ()-> mat3 {
    mat3 ()
}

pub def Matrix {4u32} ()-> mat4 {
    mat4 ()
}
    
pub def isMatrix {T} () -> bool {
    is!T {U of mat2} ||
        is!T {U of mat3} ||
        is!T {U of mat4} 
}

pub def arity {T} ()-> u32 {
    cte if is!T {U of mat2} { 2u32 }
    else cte if is!T {U of mat3} { 3u32 }
    else cte if is!T {U of mat4} { 4u32 }
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================           BINARY SCALAR            =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * Multiply a matrix by a scalar
 */
pub def if (isMatrix!T ()) opBinary {"*", T} (v : T, factor : f32)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &f32 = alias cast!{&f32} (cast!{&void} (alias (resPtr + offset)));
        let b : &f32 = cast!{&f32} (cast!{&void} (vPtr + offset));
        
        *a = *b * factor;
    }

    res
} catch {
    _ => __pragma!panic ();
}


/**
 * Divide a matrix by a scalar
 */
pub def if (isMatrix!T ()) opBinary {"/", T} (a : T, factor : f32)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = *b / u;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================           BINARY VECTOR            =====================
 * ==================================================================================
 * ==================================================================================
 */


/**
 * Multiply a matrix by a vector
 */
pub def if (isMatrix!T () && isVectorF!U () && arity!U () == arity!T ()) opBinary {"*", T, U} (a : T, v : U)-> U {
    let dmut res = U::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    
    let aPtr = cast!{&u8} (cast!{&void} (&a));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    
    cte for i in 0u32 .. arity!T () {
        let mut sum = 0.f;
        cte for j in 0u32 .. arity!T () {
            let offset = (__pragma!field_offsets (T)) [j * arity!T () + i];
            let offset_vec = (__pragma!field_offsets (U)) [j];
            let ia : &f32 = cast!{&f32} (cast!{&void} (aPtr + offset));
            let b : &f32 = cast!{&f32} (cast!{&void} (vPtr + offset_vec));
            
            sum += *ia * *b;            
        }
        
        let offset_vec = (__pragma!field_offsets (U)) [i];
        let dmut b : &f32 = alias cast!{&f32} (cast!{&void} (resPtr + offset_vec));
        *b = sum;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================           BINARY MATRIX            =====================
 * ==================================================================================
 * ==================================================================================
 */


/**
 * Addition two matrices
 */
pub def if (isMatrix!T ()) opBinary {"+", T} (a : T, b : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let aPtr = cast!{&u8} (cast!{&void} (&a));
    let bPtr = cast!{&u8} (cast!{&void} (&b));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut c : &f32 = alias cast!{&f32} (cast!{&void} (alias (resPtr + offset)));
        let ia : &f32 = cast!{&f32} (cast!{&void} (aPtr + offset));
        let ib : &f32 = cast!{&f32} (cast!{&void} (bPtr + offset));
        
        *c = *ia + *ib;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * Subtraction of matrices
 */
pub def if (isMatrix!T ()) opBinary {"-", T} (a : T, b : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let aPtr = cast!{&u8} (cast!{&void} (&a));
    let bPtr = cast!{&u8} (cast!{&void} (&b));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut c : &f32 = alias cast!{&f32} (cast!{&void} (alias (resPtr + offset)));
        let ia : &f32 = cast!{&f32} (cast!{&void} (aPtr + offset));
        let ib : &f32 = cast!{&f32} (cast!{&void} (bPtr + offset));
        
        *c = *ia - *ib;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * Multiplication of matrices
 */
pub def if (isMatrix!T ()) opBinary {"*", T} (a : T, b : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let aPtr = cast!{&u8} (cast!{&void} (&a));
    let bPtr = cast!{&u8} (cast!{&void} (&b));

    cte for i in 0u32 .. arity!T () {
        cte for j in 0u32 .. arity!T () {        
            let mut sum = 0.f;
            cte for k in 0u32 .. arity!T () {
                let offset_a = (__pragma!field_offsets (T)) [k * arity!T () + i];
                let offset_b = (__pragma!field_offsets (T)) [j * arity!T () + k];
                let ia : &f32 = cast!{&f32} (cast!{&void} (aPtr + offset_a));
                let ib : &f32 = cast!{&f32} (cast!{&void} (bPtr + offset_b));
                
                sum += *ia * *ib;
            }
            
            let offset_c = (__pragma!field_offsets (T)) [j * arity!T () + i];
            let dmut c : &f32 = alias cast!{&f32} (cast!{&void} (alias (resPtr + offset_c)));
            
            *c = sum;
        }
    }

    res
} catch {
    _ => __pragma!panic ();
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================              INVERSE               =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * @returns: the inverted copy of a matrix 2
 * @throws: &MatrixError, if the matrix is not invertible
 */
pub def inverse (a : mat2)-> mat2
    throws &MatrixError
{
    let det = a.a1 * a.b2 - a.b1 * a.a2;
    if (det == 0.f) throw MatrixError::new ("Not invertible"s8);

    let invDet = 1.f / det;
    makeMat2 (a.b2 * invDet, -a.b1 * invDet,
          -a.a2 * invDet, a.a1 * invDet)
}


/**
 * @returns: the inverted copy of a matrix 3
 * @throws: &MatrixError, if the matrix is not invertible
 */
pub def inverse (a : mat3)-> mat3
    throws &MatrixError
{
    let det = a.a1 * (a.b2 * a.c3 - a.c2 * a.b3)
        - a.b1 * (a.a2 * a.c3 - a.c2 * a.a3)
        + a.c1 * (a.a2 * a.b3 - a.b2 * a.a3);

    if (det == 0.f) throw MatrixError::new ("Not invertible"s8);

    let invDet = 1.f / det;    
    makeMat3 (
        (a.b2 * a.c3 - a.b3 * a.c2) * invDet,
        -(a.b1 * a.c3 - a.c1 * a.b3) * invDet,
        (a.b1 * a.c2 - a.c1 * a.b2) * invDet,
        -(a.a2 * a.c3 - a.c2 * a.a3) * invDet,
        (a.a1 * a.c3 - a.c1 * a.a3) * invDet,
        -(a.a1 * a.c2 - a.a2 * a.c1) * invDet,        
        (a.a2 * a.b3 - a.a3 * a.b2) * invDet,
        -(a.a1 * a.b3 - a.a3 * a.b1) * invDet,
        (a.a1 * a.b2 - a.a2 * a.b1) * invDet
        )
}


/**
 * @returns: the inverted copy of a matrix 4
 * @throws: &MatrixError, if the matrix is not invertible
 */
pub def inverse (s : mat4)-> mat4 {
    let dmut t : [f32 ; 6] = [0.0f ; 6];
    let a = s.a1, b = s.b1, c = s.c1, d = s.d1;
    let e = s.a2, f = s.b2, g = s.c2, h = s.d2;
    let i = s.a3, j = s.b3, k = s.c3, l = s.d3;
    let m = s.a4, n = s.b4, o = s.c4, p = s.d4;

    let dmut dest : [f32 ; 16] = [0.0f ; 16];
    
    t[0] = k * p - o * l; t[1] = j * p - n * l; t[2] = j * o - n * k;
    t[3] = i * p - m * l; t[4] = i * o - m * k; t[5] = i * n - m * j;    

    dest[0] =   f * t[0] - g * t[1] + h * t[2];
    dest[4] = -(e * t[0] - g * t[3] + h * t[4]);
    dest[8] =   e * t[1] - f * t[3] + h * t[5];
    dest[12] = -(e * t[2] - f * t[4] + g * t[5]);

    dest[1] = -(b * t[0] - c * t[1] + d * t[2]);
    dest[5] =   a * t[0] - c * t[3] + d * t[4];
    dest[9] = -(a * t[1] - b * t[3] + d * t[5]);
    dest[13] =   a * t[2] - b * t[4] + c * t[5];

    t[0] = g * p - o * h; t[1] = f * p - n * h; t[2] = f * o - n * g;
    t[3] = e * p - m * h; t[4] = e * o - m * g; t[5] = e * n - m * f;

    dest[2] =   b * t[0] - c * t[1] + d * t[2];
    dest[6] = -(a * t[0] - c * t[3] + d * t[4]);
    dest[10] =   a * t[1] - b * t[3] + d * t[5];
    dest[14] = -(a * t[2] - b * t[4] + c * t[5]);

    t[0] = g * l - k * h; t[1] = f * l - j * h; t[2] = f * k - j * g;
    t[3] = e * l - i * h; t[4] = e * k - i * g; t[5] = e * j - i * f;

    dest[3] = -(b * t[0] - c * t[1] + d * t[2]);
    dest[7] =   a * t[0] - c * t[3] + d * t[4];
    dest[11] = -(a * t[1] - b * t[3] + d * t[5]);
    dest[15]=   a * t[2] - b * t[4] + c * t[5];

    let det = 1.0f / (a * dest[0] + b * dest[4] + c * dest[8] + d * dest[12]);
    
    return makeMat4 (dest[0] * det, dest[1] * det, dest[2] * det, dest[3] * det,
                     dest[4] * det, dest[5] * det, dest[6] * det, dest[7] * det,
                     dest[8] * det, dest[9] * det, dest[10] * det, dest[11] * det,
                     dest[12] * det, dest[13] * det, dest[14] * det, dest[15] * det);
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================              TRANSPOSE             =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * @returns: the transposed copy of a matrix
 */
pub def if (isMatrix!{T} ()) transpose {T} (a : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    
    let aPtr = cast!{&u8} (cast!{&void} (&a));
    
    cte for i in 0u32 .. arity!T () {
        cte for j in 0u32 .. arity!T () {
            let offset = (__pragma!field_offsets (T)) [j * arity!T () + i];
            let offset_res = (__pragma!field_offsets (T)) [i * arity!T () + j];

            let ia : &f32 = cast!{&f32} (cast!{&void} (aPtr + offset));
            let dmut ires : &f32 = alias cast!{&f32} (cast!{&void} (resPtr + offset_res));
            *ires = *ia;            
        }        
    }

    res
} catch {
    _ => __pragma!panic ();
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================          VECTOR OPERATIONS         =====================
 * ==================================================================================
 * ==================================================================================
 */


/**
 * @returns: a diagonal matrix from a vector
 */
pub def if (isVectorF!U ()) diag {U} (v : U)-> typeof (Matrix!{arity!U ()} ())  {
    let dmut res = Matrix!{arity!U ()} ();
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    
    let vPtr = alias cast!{&u8} (cast!{&void} (&v));

    cte for i in 0u32 .. arity!U () {
        cte for j in 0u32 .. arity!U () {
            let offset_res = (__pragma!field_offsets (typeof (Matrix!{arity!U ()} ()))) [i * arity!U () + j];

            let dmut ires : &f32 = alias cast!{&f32} (cast!{&void} (resPtr + offset_res));
            if (i == j) {
                let offset = (__pragma!field_offsets (U)) [i];
                let iv : &f32 = cast!{&f32} (cast!{&void} (vPtr + offset));
                *ires = *iv;
            } else *ires = 0.f;
        }
    }
    
    res
} catch {
    _ => __pragma!panic ();
}


/**
 * @returns: a translation matrix from a vector
 */
pub def if (isVectorF!U ()) translation {U} (v : U)-> typeof (Matrix!{arity!U () + 1u32} ())  {
    let dmut res = Matrix!{arity!U () + 1u32} ();
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    
    let vPtr = alias cast!{&u8} (cast!{&void} (&v));

    cte for i in 0u32 .. arity!U () {
        let offset_res = (__pragma!field_offsets (typeof (Matrix!{arity!U () + 1u32} ()))) [(arity!U () * (arity!U () + 1u32)) + i];
        let dmut ires : &f32 = alias cast!{&f32} (cast!{&void} (resPtr + offset_res));
        let offset = (__pragma!field_offsets (U)) [i];
        let iv : &f32 = cast!{&f32} (cast!{&void} (vPtr + offset));
        *ires = *iv;        
    }
    
    res
} catch {
    _ => __pragma!panic ();
}


/**
 * @returns: a scaling matrix from a vector
 */
pub def if (isVectorF!U ()) scaling {U} (v : U)-> typeof (Matrix!{arity!U () + 1u32} ())  {
    let dmut res = Matrix!{arity!U () + 1u32} ();
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    
    let vPtr = alias cast!{&u8} (cast!{&void} (&v));

    cte for i in 0u32 .. arity!U () {
        let offset_res = (__pragma!field_offsets (typeof (Matrix!{arity!U () + 1u32} ()))) [(i * (arity!U () + 1u32)) + i];
        let dmut ires : &f32 = alias cast!{&f32} (cast!{&void} (resPtr + offset_res));
        let offset = (__pragma!field_offsets (U)) [i];
        let iv : &f32 = cast!{&f32} (cast!{&void} (vPtr + offset));
        *ires = *iv;        
    }
    
    res
} catch {
    _ => __pragma!panic ();
}


/**
 * @returns: a rotation matrix from an angle (in radians) and an axis
 */
pub def rotation (angle : f32, axis : vec3)-> mat4  {    
    let c = cos (angle);
    let oneMinusC = 1.f - c;
    let s = sin (angle);
    let n = axis.normalize ();
    
    let x = n.x, y = n.y, z = n.z;

    mat4 (
        a1-> x * x * oneMinusC + c,
        a2-> x * y * oneMinusC - z * s,
        a3-> x * z * oneMinusC + y * s,
        b1-> y * x * oneMinusC + z * s,
        b2-> y * y * oneMinusC + c,
        b3-> y * z * oneMinusC - x * s,
        c1-> z * x * oneMinusC - y * s,
        c2-> z * y * oneMinusC + x * s,
        c3-> z * z * oneMinusC + c)
}


/**
 * Rotate along a the X axis
 * @returns: the rotation matrix along the x axis
 */
pub def rotationX (angle : f32)-> mat4 {
    let cosa = cos(angle);
    let sina = sin(angle);
    mat4 (
        b2-> cosa,
        b3-> -sina,
        c2-> sina,
        c3-> cosa
        )
}

/**
 * Rotate along a the X axis
 * @returns: the rotation matrix along the x axis
 */
pub def rotationY (angle : f32)-> mat4 {
    let cosa = cos(angle);
    let sina = sin(angle);
    mat4 (
        c3-> cosa,
        c1-> -sina,
        a3-> sina,
        a1-> cosa
        )
}

/**
 * Rotate along a the X axis
 * @returns: the rotation matrix along the x axis
 */
pub def rotationZ (angle : f32)-> mat4 {
    let cosa = cos(angle);
    let sina = sin(angle);
    mat4 (
        a1-> cosa,
        a2-> -sina,
        b1-> sina,
        b2-> cosa
        )
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================              PROJECTIONS           =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * @returns: a matrix of orthopgraphic projection
 */
pub def ortho (left : f32, right : f32, bottom : f32, top : f32, near : f32, far : f32)-> mat4 {
    let dx = right - left, dy = top - bottom, dz = far - near;

    let tx = -(right + left) / dx;
    let ty = -(top + bottom) / dy;
    let tz = -(far + near)   / dz;

    makeMat4 (2.f / dx,   0.f,      0.f,    0.f,
          0.f,    2.f / dy,   0.f,    0.f,
          0.f,      0.f,   -2.f / dz, 0.f,
          tx,      ty,      tz,     1.f)
}

/**
 * @returns: a matrix of perspective projection
 * @params: 
 *  - fov: fov angle in radians
 */
pub def perspective (fov : f32, aspect : f32, near : f32, far : f32)-> mat4 {
    let f = 1.f / math::tan (fov / 2.f);
    let d = 1.f / (near - far);
    
    makeMat4 (f / aspect, 0.f, 0.f,                     0.f,
              0.f,        f,   0.f,                     0.f,
              0.f,        0.f, (far + near) * d,     -1.f,
              0.f,        0.f, 2.f * d * far * near,  0.f)
}

/**
 * @returns: a matrix of look at projection
 */
pub def lookAt (eye : vec3, target : vec3, up : vec3)-> mat4 {
    let Z = (eye - target).normalize ();
    let X = cross(up.opUnary!"-" (), Z).normalize ();
    let Y = cross(Z, X.opUnary!"-" ());

    makeMat4 (a1-> -X.x,
              a2-> -X.y,
              a3-> -X.z,
              a4 -> dot(X, eye),

              b1-> Y.x,
              b2-> Y.y,
              b3-> Y.z,
              b4-> -dot(Y, eye),
              
              c1-> Z.x,
              c2-> Z.y,
              c3-> Z.z,
              c4-> -dot(Z, eye),
              
              d1-> 0.f,
              d2-> 0.f,
              d3-> 0.f,
              d4-> 1.f)
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================             COMPARISON             =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * Aompare two matriaes
 * @returns: true if a and b are equals
 */
pub def if (isMatrix!{T} ()) opEquals {T} (a : T, b : T)-> bool {
    cte for i in 0u32 .. typeof (__pragma!tupleof (a))::arity {
        if (__pragma!tupleof (a)).(i) != (__pragma!tupleof (b)).(i) {
            return false;
        }
    }
    
    true
}
