mod balder::math::vector;
import std::math;


/***
 * ============================================================================
 * ============================================================================
 * =========================           VECTOR 2           =====================
 * ============================================================================
 * ============================================================================
 */

pub struct
| mut x : f32 = 0.f
| mut y : f32 = 0.f
 -> vec2;
pub aka if (is!T {F of f32}) Vector2 {T} = vec2;

pub struct
| mut x : u32 = 0u32
| mut y : u32 = 0u32
 -> uvec2;
pub aka if (is!T {I of u32}) Vector2 {T} = uvec2;

pub struct
| mut x : i32 = 0
| mut y : i32 = 0
 -> ivec2;
pub aka if (is!T {I of i32}) Vector2 {T} = ivec2;

pub def makeVec2 {T} (x : T, y : T)-> Vector2!{T} {
    Vector2!{T} (x-> x, y-> y)
}


/***
 * ============================================================================
 * ============================================================================
 * =========================           VECTOR 3           =====================
 * ============================================================================
 * ============================================================================
 */

pub struct
| mut x : f32 = 0.f
| mut y : f32 = 0.f
| mut z : f32 = 0.f
 -> vec3;
pub aka if (is!T {F of f32}) Vector3 {T} = vec3;

pub struct
| mut x : i32 = 0
| mut y : i32 = 0
| mut z : i32 = 0
 -> ivec3;
pub aka if (is!T {I of i32}) Vector3 {T} = ivec3;

pub struct
| mut x : u32 = 0u32
| mut y : u32 = 0u32
| mut z : u32 = 0u32
 -> uvec3;
pub aka if (is!T {I of u32}) Vector3 {T} = uvec3;

pub def makeVec3 {T} (x : T, y : T, z : T)-> Vector3!{T} {
    Vector3!{T} (x-> x, y-> y, z-> z)
}



/***
 * ============================================================================
 * ============================================================================
 * =========================           VECTOR 4           =====================
 * ============================================================================
 * ============================================================================
 */

pub struct
| mut x : f32 = 0.f
| mut y : f32 = 0.f
| mut z : f32 = 0.f
| mut w : f32 = 1.f
 -> vec4;
pub aka if (is!T {F of f32}) Vector4 {T} = vec4;

pub struct
| mut x : i32 = 0
| mut y : i32 = 0
| mut z : i32 = 0
| mut w : i32 = 1
 -> ivec4;
pub aka if (is!T {I of i32}) Vector4 {T} = ivec4;

pub struct
| mut x : u32 = 0u32
| mut y : u32 = 0u32
| mut z : u32 = 0u32
| mut w : u32 = 0u32
 -> uvec4;
pub aka if (is!T {I of u32}) Vector4 {T} = uvec4;

pub def makeVec4 {T} (x : T, y : T, z : T, w : T)-> Vector4!{T} {
    Vector4!{T} (x-> x, y-> y, z-> z, w-> w)
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================           TEMPLATE TESTS           =====================
 * ==================================================================================
 * ==================================================================================
 */

pub def isVectorF {T} () -> bool {
    is!T {U of vec2} || is!T {U of vec3} || is!T {U of vec4}
}

pub def isVectorI {T} () -> bool {
    is!T {U of ivec2} || is!T {U of ivec3} || is!T {U of ivec4}
}

pub def isVectorU {T} () -> bool {
    is!T {U of uvec2} || is!T {U of uvec3} || is!T {U of uvec4}
}

pub def isVectorF {T, N : u32} () -> bool {
    (is!T {U of vec2} && N <= 2u32) || (is!T {U of vec3} && N <= 3u32) || (is!T {U of vec4} && N <= 4u32)
}

pub def isVectorI {T, N : u32} () -> bool {
    (is!T {U of ivec2} && N <= 2u32) || (is!T {U of ivec3} && N <= 3u32) || (is!T {U of ivec4} && N <= 4u32)
}

pub def isVectorU {T, N : u32} () -> bool {
    (is!T {U of uvec2} && N <= 2u32) || (is!T {U of uvec3} && N <= 3u32) || (is!T {U of uvec4} && N <= 4u32)
}

pub def isVector {T} () -> bool {
    isVectorF!T () || isVectorU!{T} () || isVectorI!T ()
}

pub def isVector {T, N : u32} () -> bool {
    isVectorF!{T, N} () || isVectorU!{T, N} () || isVectorI!{T, N} ()
}

pub def isVector {T, U} () -> bool {
    (isVectorF!T () && is!U {F of f32}) ||
        (isVectorU!{T} () && is!U {J of u32}) ||
        (isVectorI!T () && is!U {I of i32})
}


pub aka Vector {T, N : u32} = cte if (N == 2u32) { Vector2!{T} } else cte if (N == 3u32) { Vector3!{T} } else cte if (N == 4u32) { Vector4!{T} } 

pub def arity {T} () -> u32 {
    cte if (is!T {U of vec2} || is!T {U of ivec2} || is!T {U of uvec2}) { 2u32 }
    else cte if (is!T {U of vec3} || is!T {U of ivec3} || is!T {U of uvec3}) { 3u32 }
    else cte if (is!T {U of vec4} || is!T {U of ivec4} || is!T {U of uvec4}) { 4u32 }
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================             EXTRACTION             =====================
 * ==================================================================================
 * ==================================================================================
 */


/**
 * Exctract a vector 2 from a vector
 */
pub def if (isVector!{T, 2u32} ()) xy {T} (v : T)-> Vector2!{__pragma!field_type (T, "x")} {
    makeVec2 (v.x, v.y)
}

/**
 * Exctract a vector 3 from a vector
 */
pub def if (isVector!{T, 3u32} ()) xyz {T} (v : T)-> Vector3!{__pragma!field_type (T, "x")} {
    makeVec3 (v.x, v.y, v.z)
}

/**
 * Exctract a vector 3 from a vector
 */
pub def if (isVector!{T, 4u32} ()) xyzw {T} (v : T)-> Vector4!{__pragma!field_type (T, "x")} {
    makeVec4 (v.x, v.y, v.z, v.w)
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================           FLOATING POINT           =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * @return: a normalize version of a vector
 */
pub def if (isVectorF!T ()) normalize {T} (v : T)-> T {
    v / v.length ()
}

/**
 * @returns: the lenght of a vector
*/
pub def if (isVectorF!T ()) length {T} (v : T)-> f32 {
    let mut res = 0.f;
    for i in __pragma!tupleof (v) {
        res += i * i;
    }
    sqrt (res)
}

/**
 * @return: the distance between two vectors
 */
pub def if (isVectorF!T ()) distance {T} (v : T, u : T)-> f32 {
    (u - v).length ()
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================            UNARY VECTOR            =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * @returns: the opposite of the vector
 */
pub def if (isVector!{T} ()) opUnary {"-", T} (v : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &(typeof (v.x)) = alias cast!{&typeof (v.x)} (cast!{&void} (alias (resPtr + offset)));
        let b : &(typeof (v.x)) = cast!{&typeof(v.x)} (cast!{&void} (vPtr + offset));
        
        *a = -(*b);
    }

    res
} catch {
    _ => __pragma!panic ();
}

/***
 * ==================================================================================
 * ==================================================================================
 * =========================           BINARY SCALAR            =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * Divide a vector by a scalar
 * @returns: the divided vector
 */
pub def if (isVector!{T, U} ()) opBinary {"/", T, U} (v : T, u : U)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = *b / u;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * Divide a scalar vector by vector
 * @returns: the divided vector
 */
pub def if (isVector!{T, U} ()) opBinaryRight {"/", T, U} (v : T, u : U)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = u / *b;
    }

    res
} catch {
    _ => __pragma!panic ();
}


/**
 * Addition a scalar to a vector
 * @returns: the result vector
 */
pub def if (isVector!{T, U} ()) opBinary {"+", T, U} (v : T, u : U)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = *b + u;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * @returns: the sum between a vector and a scalar
 */
pub def if (isVector!{T, U} ()) opBinaryRight {"+", T, U} (v : T, u : U)-> T {
    opBinary!{"+", T, U} (v, u)
}


/**
 * Multiply a vector a vector by a scalar
 * @returns: the result vector
 */
pub def if (isVector!{T, U} ()) opBinary {"*", T, U} (v : T, u : U)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = *b * u;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * @returns: the multiplication between a vector and a scalar
 */
pub def if (isVector!{T, U} ()) opBinaryRight {"*", T, U} (v : T, u : U)-> T {
    opBinary!{"*", T, U} (v, u)
}


/**
 * Substract a scalar to a vector
 * @returns: the result vector
 */
pub def if (isVector!{T, U} ()) opBinary {"-", T, U} (v : T, u : U)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = *b - u;
    }

    res
} catch {
    _ => __pragma!panic ();
}


/**
 * Substract a scalar to a vector
 * @returns: the result vector
 */
pub def if (isVector!{T, U} ()) opBinaryRight {"-", T, U} (v : T, u : U)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &U = alias cast!{&U} (cast!{&void} (alias (resPtr + offset)));
        let b : &U = cast!{&U} (cast!{&void} (vPtr + offset));
        
        *a = u - *b;
    }

    res
} catch {
    _ => __pragma!panic ();
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================           BINARY VECTOR            =====================
 * ==================================================================================
 * ==================================================================================
 */



/**
 * Substraction of two vectors 
 * @returns: the result vector
 */
pub def if (isVector!{T} ()) opBinary {"-", T} (v : T, u : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    let uPtr = cast!{&u8} (cast!{&void} (&u));
    
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &(typeof (v.x)) = alias cast!{&typeof (v.x)} (cast!{&void} (alias (resPtr + offset)));
        let b : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (vPtr + offset));
        let c : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (uPtr + offset));
        
        *a = *b - *c;
    }

    res
} catch {
    _ => __pragma!panic ();
}


/**
 * Addition of two vectors 
 * @returns: the result vector
 */
pub def if (isVector!{T} ()) opBinary {"+", T} (v : T, u : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    let uPtr = cast!{&u8} (cast!{&void} (&u));
    
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &(typeof (v.x)) = alias cast!{&typeof (v.x)} (cast!{&void} (alias (resPtr + offset)));
        let b : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (vPtr + offset));
        let c : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (uPtr + offset));
        
        *a = *b + *c;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * Division of two vectors 
 * @returns: the result vector
 */
pub def if (isVector!{T} ()) opBinary {"/", T} (v : T, u : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    let uPtr = cast!{&u8} (cast!{&void} (&u));
    
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &(typeof (v.x)) = alias cast!{&typeof (v.x)} (cast!{&void} (alias (resPtr + offset)));
        let b : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (vPtr + offset));
        let c : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (uPtr + offset));
        
        *a = *b / *c;
    }

    res
} catch {
    _ => __pragma!panic ();
}

/**
 * Multiplication of two vectors (not dot product)
 * @returns: the result vector
 */
pub def if (isVector!{T} ()) opBinary {"*", T} (v : T, u : T)-> T {
    let dmut res = T::init;
    let dmut resPtr = alias cast!{&u8} (cast!{&void} (alias &res));
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    let uPtr = cast!{&u8} (cast!{&void} (&u));
    
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let dmut a : &(typeof (v.x)) = alias cast!{&typeof (v.x)} (cast!{&void} (alias (resPtr + offset)));
        let b : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (vPtr + offset));
        let c : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (uPtr + offset));
        
        *a = *b * *c;
    }

    res
} catch {
    _ => __pragma!panic ();
}


/***
 * ==================================================================================
 * ==================================================================================
 * =========================          DOT/CROSS...              =====================
 * ==================================================================================
 * ==================================================================================
 */

/**
 * Dot product of two vectors 
 * @returns: the result vector
 */
pub def if (isVector!{T} ()) dot {T} (v : T, u : T)-> __pragma!field_type (T, "x") {
    let mut sum =
        cte if (is!{__pragma!field_type (T, "x")}{F of f32}) { 0.f }
    else { (__pragma!field_type (T, "x"))::init }
    
    let vPtr = cast!{&u8} (cast!{&void} (&v));
    let uPtr = cast!{&u8} (cast!{&void} (&u));
    
    cte for i in 0us .. (__pragma!field_offsets (T)).len {
        let offset = (__pragma!field_offsets (T)) [i];
        let b : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (vPtr + offset));
        let c : &(typeof (v.x)) = cast!{&typeof (v.x)} (cast!{&void} (uPtr + offset));
        
        sum += (*b) * (*c);
    }

    sum
} catch {
    _ => __pragma!panic ();
}

/**
 * Cross product of two vectors 
 * @returns: the result vector
 */
pub def if (isVector!{T, 3u32} ()) cross {T} (v : T, u : T)-> T {
    makeVec3 (v.y * u.z - v.z * u.y,
       v.z * u.x - v.x * u.z,
       v.x * u.y - v.y * u.x)
}

/**
 * reflect of two vectors 
 * @returns: the result vector
 */
pub def if (isVector!{T} ()) reflect {T} (v : T, u : T)-> T  {
    cte if (is!{__pragma!field_type (T, "x")}{I of i32}) {
        v - (2 * dot (u, v)) * u
    } else cte if (is!{__pragma!field_type (T, "x")}{I of u32}) {
        v - (2u32 * dot (u, v)) * u
    } else cte if (is!{__pragma!field_type (T, "x")}{I of f32}) {
        v - (2.f * dot (u, v)) * u
    }
}       


pub def if (isVectorF!{T} ()) angle {T} (v : T, u : T)-> f32 {
    let aN = v.normalize ();
    let bN = u.normalize ();
    let dp = dot (aN, bN);

    if (dp < 0.f)
        return cast!f32 (PI) - 2.f * math::asin ((bN.opUnary!"-" () - aN).length () / 2.f);
    else
        return 2.f * math::asin ((bN - aN).length () / 2.f);
}


/***
 * ===================================================================================
 * ===================================================================================
 * =========================             COMPARISON              =====================
 * ===================================================================================
 * ===================================================================================
 */

/**
 * Compare two vectors
 * @returns: true if v and u are equals
 */
pub def if (isVector!{T} ()) opEquals {T} (v : T, u : T)-> bool {
    cte for i in 0u32 .. typeof (__pragma!tupleof (v))::arity {
        if (__pragma!tupleof (v)).(i) != (__pragma!tupleof (u)).(i) {
            return false;
        }
    }
    
    true
}




