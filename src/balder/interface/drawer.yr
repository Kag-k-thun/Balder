in drawer;

use balder::core::_;

use balder::core::{_,
                   shader::_,
                   shader::buffers::_,
                   application::_,
                   driver::_,
                   config::_};

use balder::{utils::_, math::_};
use balder::interface::shape::_;

use std::io;

/**
 * Shape drawer that draws 2D elements on the window
 * */
@final
pub class ShapeDrawer {

    let dmut _window : &Window;
    let dmut _subpass : &DrawSubpass;
    
    let mut _windowDimension : uvec2 = uvec2 ();

    let dmut _colorShader : &RefCount!{&Shader};
    let dmut _textureShader : &RefCount!{&Shader};

    let dmut _quadColorVBO   : &VertexBufferObject = copy VertexBufferObject ();
    let dmut _quadTextureVBO : &VertexBufferObject = copy VertexBufferObject ();
    let dmut _quadIBO        : &IndexBufferObject!{u16} = copy IndexBufferObject!{u16} ();

    let dmut _colorShapes : [usize => &ColorShape] = copy [];
    let dmut _textureShapes : [usize => &TextureShape] = copy [];        

    let dmut _uid       : usize = 1us;
    let mut _needRedraw : bool = false;    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut win : &Window)
        with _window = alias win
        , _colorShader = win:.emptyResource!{&RasterShader} ()
        , _textureShader = win:.emptyResource!{&RasterShader} ()
        , _subpass = alias win:.getVulkanDevice ():.getSwapchain ():.getRenderPass ()
    {
        let dim = win.getDimension ();
        self._windowDimension = makeVec2 (dim._0, dim._1);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the widget drawer on the given window
     * */
    pub fn configure (mut self)
        throws BalderError
    {
        self._colorShader = self._window:.loadResource!{&RasterShader} (DefaultShaders::COLOR_2D);
        self._textureShader = self._window:.loadResource!{&RasterShader} (DefaultShaders::TEXTURE_2D);

        self._quadIBO:.update (alias self._window:.getVulkanDevice (), copy [1u32, 0u32, 2u32,
                                                                             2u32, 0u32, 3u32]);

        self._quadColorVBO:.update (alias self._window:.getVulkanDevice (),
                                    4us,
                                    copy [-1.f, -1.f,
                                          -1.f, 1.f,
                                          1.f, 1.f,
                                          1.f, -1.f]);

        self._quadTextureVBO:.update (alias self._window:.getVulkanDevice (),
                                      4us,
                                      copy [-1.f, -1.f, 0.0f, 0.0f,
                                            -1.f, 1.f, 0.0f, 1.0f,
                                            1.f, 1.f, 1.0f, 1.0f,
                                            1.f, -1.f, 1.0f, 0.0f]);

        self._subpass:.onDraw ():.connect (&self:.onPassDraw);
    } catch {
        err => {
            log::error #("Drawer", "Failed to create widget drawer", err);
            throw err;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the window on which the drawing is done
     * */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the dimension of the drawing window
     * */
    pub fn getDimension (self)-> uvec2 {
        self._windowDimension
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          ADDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a color quad in the window to draw
     * */
    pub fn registerColorQuad (mut self, position : vec2 = vec2 (), color : vec4 = vec4 (), size : vec2 = vec2 ())-> dmut &ColorShape
        throws BalderError
    {
        atomic self {
            let dmut s = (alias self._colorShader:.get ())?;
            if let Ok (dmut sh) = alias s {
                let dmut result = copy ColorShape (self._uid,
                                                   alias self,
                                                   alias sh,
                                                   self._quadColorVBO,
                                                   self._quadIBO);
                self._uid += 1;

                let dim = self._window.getDimension ();
                result:.setWindowDimension (makeVec2 (cast!f32 (dim._0), cast!f32 (dim._1)));
                result:.setPosition (position);
                result:.setSize (size);                
                result:.setColor (color);                
                result:.setLevel (1);
                result:.show ();

                self._colorShapes [result.uid] = alias result;
                self:.redraw ();
                return alias result;
            }
        }

        throw copy BalderError ("Invalid shape drawer");
    }

    /**
     * Register a textured quad in the window to draw
     * */
    pub fn registerTextureQuad (mut self, dmut texture : &RefCount!{&Texture}, position : vec2 = vec2 (), color : vec4 = vec4 (), size : vec2 = vec2 ())-> dmut &TextureShape
        throws BalderError
    {
        atomic self {            
            let dmut s = (alias self._textureShader:.get ())?;
            if let Ok (dmut sh) = alias s {
                let dmut result = copy TextureShape (self._uid,
                                                     alias self,
                                                     alias sh,
                                                     self._quadTextureVBO,
                                                     self._quadIBO,
                                                     alias texture);

                self._uid += 1;

                let dim = self._window.getDimension ();
                result:.setWindowDimension (makeVec2 (cast!f32 (dim._0), cast!f32 (dim._1)));
                result:.setPosition (position);
                result:.setSize (size);                
                result:.setColor (color);
                result:.setLevel (1);

                self._textureShapes [result.uid] = alias result;
                self:.redraw ();
                return alias result;
            }
        }

        throw copy BalderError ("Invalid shape drawer");
    }

    /**
     * Remove a shape from the drawer either color or texture
     * @params:
     *    - uid: the uid of the shape to remove
     * */
    pub fn removeShape (mut self, uid : usize) {
        if !self:.removeTextureShape (uid) {
            if !self:.removeColorShape (uid) {
                log::error #("ShapeDrawer", "Removing a shape that was not created by the drawer ? -> ", uid);
            }
        }
    }

    /**
     * Remove a texture shape from the drawer
     * */
    prv fn removeTextureShape (mut self, uid : usize)-> bool {
        atomic self {
            if let Ok (dmut sh) = alias self._textureShapes [uid] {
                self._textureShapes:.remove (uid);
                self._window:.insertBin (alias sh);
                
                self:.redraw ();
                return true;
            }
        }

        false
    }

    /**
     * Remove a color shape from the drawer
     * */
    prv fn removeColorShape (mut self, uid : usize)-> bool {
        atomic self {
            if let Ok (dmut sh) = alias self._colorShapes [uid] {
                self._colorShapes:.remove (uid);
                self._window:.insertBin (alias sh);                

                self:.redraw ();
                return true;
            }
        }

        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method connected to the signal of the drawing subpass
     * @trigger: the subpass is redrawn
     * */
    fn onPassDraw (mut self) {
        let dmut cmd = self._subpass:.createCommandAllocator!{&IndexedDrawCommandAllocator} ();
        atomic self {
            { // Register shapes
                for _, c in self._colorShapes { // if !c.isHidden () {
                    cmd:.registerIndexedObject (c.getNbPoints ());
                }

                for _, t in self._textureShapes { // if !t.isHidden () {
                    cmd:.registerIndexedObject (t.getNbPoints ());
                }
            }

            {
                cmd:.finalizeRegister ();
            } catch {
                err => {
                    log::error #("ShapeDrawer", "Failed to register shape to draw", err);
                    return;
                }
            }
            
            { // Draw colors
                let dmut s = (alias self._colorShader:.get ())?;
                if let Ok (dmut sh) = alias s {
                    sh.select (cmd.getCommandBuffer ());
                }        
                
                for _, dmut c in alias self._colorShapes { // if !c.isHidden () {
                    c.draw (alias cmd);
                }
            }

            { // Draw textures
                let dmut s = (alias self._textureShader:.get ())?;
                if let Ok (dmut sh) = alias s {
                    sh.select (cmd.getCommandBuffer ());
                }

                for _, dmut t in alias self._textureShapes { // if !t.isHidden () {
                    t.draw (alias cmd);
                }
            }            
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          TRIGGERS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Triggered when the window change size
     * */
    pub fn onWindowResize (mut self, x : u32, y : u32) {
        atomic self {
            for _, dmut c in alias self._colorShapes {
                c:.setWindowDimension (makeVec2 (cast!f32 (x), cast!f32 (y)));
            }

            for _, dmut c in alias self._textureShapes {
                c:.setWindowDimension (makeVec2 (cast!f32 (x), cast!f32 (y)));
            }

            self._windowDimension = makeVec2 (x, y);
        }
    }

    @{final}
    pub fn redraw (mut self) {
        self._needRedraw = true;
    }

    /**
     * Commit the change of shapes in the last iteration
     * */
    pub fn commit (mut self) {
        atomic self {
            let mut forceFrame = false;
            for _, dmut c in alias self._colorShapes {
                if (c:.commit ()) {
                    forceFrame = true;
                }
            }

            for _, dmut c in alias self._textureShapes {
                if (c:.commit ()) {
                    forceFrame = true;
                }
            }

            if self._needRedraw {
                self._window:.redrawPipeline ();                
                self._needRedraw = false;
            }

            if forceFrame {
                self._window:.forceFrame ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLEARING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Clear all loaded widgets
     * */
    pub fn clear (mut self) {
        atomic self {
            for _, dmut c in alias self._colorShapes {
                self._window:.insertBin (alias c);                
            }

            for _, dmut c in alias self._textureShapes {
                self._window:.insertBin (alias c);                
            }
            
            self._colorShapes = copy [];
            self._textureShapes = copy [];
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self:.clear ();

            atomic self {
                self._colorShader:.dispose ();
                self._textureShader:.dispose ();                                
                
                self._window:.insertBin (alias self._quadColorVBO);
                self._window:.insertBin (alias self._quadTextureVBO);
                self._window:.insertBin (alias self._quadIBO);
            }
        }
    }

}
