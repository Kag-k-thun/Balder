in drawer;

use balder::core::_;

use balder::core::{_,
                   shader::_,
                   shader::buffers::_,
                   application::_,
                   driver::_,
                   config::{_, shader::_}};

use balder::{utils::_, math::_};
use balder::interface::shape::_;

use std::io;

/**
 * Shape drawer that draws 2D elements on the window
 * */
@final
pub class ShapeDrawer {

    let dmut _window : &Window;
    let dmut _subpass : &DrawSubpass;
    
    let mut _windowDimension : uvec2 = uvec2 ();    
    
    let dmut _colorShader : &RefCount!{&Shader};        
    let dmut _textureShader : &RefCount!{&Shader};    
    
    let dmut _quadColorVBO   : &VertexBufferObject = copy VertexBufferObject ();
    let dmut _quadTextureVBO : &VertexBufferObject = copy VertexBufferObject ();
    let dmut _quadIBO        : &IndexBufferObject!{u16} = copy IndexBufferObject!{u16} ();        

    // The shape sorted by their drawing order
    let dmut _shapeList : &ShapeList = copy ShapeList ();
    
    let dmut _uid       : usize = 1us;
    let mut _needRedraw : bool = false;    
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut win : &Window)
        with _window = alias win
        , _colorShader = win:.emptyResource!{&RasterShader} ()
        , _textureShader = win:.emptyResource!{&RasterShader} ()
        , _subpass = alias win:.getVulkanDevice ():.getSwapchain ():.getRenderPass ()
    {
        let dim = win.getDimension ();
        self._windowDimension = makeVec2 (dim._0, dim._1);        
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Configure the widget drawer on the given window
     * */
    pub fn configure (mut self)
        throws BalderError
    {
        let dmut device = self._window:.getVulkanDevice ();
        
        self._colorShader = self._window:.loadResource!{&RasterShader} (DefaultShaders::COLOR_2D);                        
        self._textureShader = self._window:.loadResource!{&RasterShader} (DefaultShaders::TEXTURE_2D);
                
        self._quadIBO:.update (alias device, copy [1u32, 0u32, 2u32,
                                                   2u32, 0u32, 3u32]);

        self._quadColorVBO:.update (alias device,
                                    4us,
                                    copy [-1.f, -1.f,
                                          -1.f, 1.f,
                                          1.f, 1.f,
                                          1.f, -1.f]);

        self._quadTextureVBO:.update (alias device,
                                      4us,
                                      copy [-1.f, -1.f, 0.0f, 0.0f,
                                            -1.f, 1.f, 0.0f, 1.0f,
                                            1.f, 1.f, 1.0f, 1.0f,
                                            1.f, -1.f, 1.0f, 0.0f]);
        
        self._subpass:.onDraw ():.connect (&self:.onPassDraw);
    } catch {
        err => {
            log::error #("Drawer", "Failed to create widget drawer", err);
            throw err;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the window on which the drawing is done
     * */
    pub fn getWindow (mut self)-> dmut &Window {
        alias self._window
    }

    /**
     * @returns: the dimension of the drawing window
     * */
    pub fn getDimension (self)-> uvec2 {
        self._windowDimension
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          ADDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a color quad in the window to draw
     * */
    pub fn registerColorQuad (mut self, position : vec2 = vec2 (), color : vec4 = vec4 (), size : vec2 = vec2 (), level : u32 = 1)-> dmut &ColorShape
        throws BalderError
    {
        atomic self {
            let dmut s = (alias self._colorShader:.get ())?;
            if let Ok (dmut sh) = alias s {
                let dmut result = copy ColorShape (self._uid,
                                                   alias self,
                                                   alias sh,
                                                   self._quadColorVBO,
                                                   self._quadIBO);
                self._uid += 1;
                                
                result:.setPosition (position);
                result:.setSize (size);                
                result:.setColor (color);                
                result:.setLevel (level);
                result:.show ();
                
                self._shapeList:.insert (alias result);                
                
                self:.redraw ();
                return alias result;
            }
        }

        throw copy BalderError ("Invalid shape drawer");
    }

    /**
     * Register a textured quad in the window to draw
     * */
    pub fn registerTextureQuad (mut self, dmut texture : &RefCount!{&Texture}, position : vec2 = vec2 (), color : vec4 = vec4 (), size : vec2 = vec2 (), level : u32 = 1)-> dmut &TextureShape
        throws BalderError
    {
        atomic self {            
            let dmut s = (alias self._textureShader:.get ())?;
            if let Ok (dmut sh) = alias s {
                let dmut result = copy TextureShape (self._uid,
                                                     alias self,
                                                     alias sh,
                                                     self._quadTextureVBO,
                                                     self._quadIBO,
                                                     alias texture);

                self._uid += 1;
                                
                result:.setPosition (position);
                result:.setSize (size);                
                result:.setColor (color);
                result:.setLevel (level);
                
                self._shapeList:.insert (alias result);                
                
                self:.redraw ();
                return alias result;
            }
        }

        throw copy BalderError ("Invalid shape drawer");
    }

    /**
     * Remove a shape from the drawer either color or texture
     * @params:
     *    - uid: the uid of the shape to remove
     * */
    pub fn removeShape (mut self, uid : usize) {
        if let Ok (dmut sh) = alias self._shapeList:.remove (uid) {
            self._window:.insertBin (alias sh);
            self:.redraw ();            
        } else {                    
            log::error #("ShapeDrawer", "Removing a shape that was not created by the drawer ? -> ", uid);            
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          DRAWING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method connected to the signal of the drawing subpass
     * @trigger: the subpass is redrawn
     * */
    fn onPassDraw (mut self) {
        let dmut cmd = copy IndexedDrawCommandAllocator (alias self._subpass);
        let frame = self._subpass.getCurrentFrame ();
        
        atomic self {
            { // Register shapes
                for s in self._shapeList { // if !c.isHidden () {
                    cmd:.registerIndexedObject (s.getNbPoints ());
                }                
            }

            {
                cmd:.finalizeRegister ();
            } catch {
                err => {
                    log::error #("ShapeDrawer", "Failed to register shape to draw", err);
                    return;
                }
            }

            {
                let mut current = 0;
                let dmut cSh = alias self._colorShader:.get ();
                let dmut tSh = alias self._textureShader:.get ();

                { // pushing the window dimension
                    cSh.select (cmd.getCommandBuffer ());                    
                    cSh:.setPush (cmd.getCommandBuffer (), UniformNames::WINDOW, self._windowDimension);
                }
                
                for dmut s in alias self._shapeList {
                    if current == 0 && (s of TextureShape) {
                        current = 1;
                        tSh.select (cmd.getCommandBuffer ());
                        s.draw (frame, alias cmd);
                    }
                    else if current == 1 && (s of ColorShape) {
                        current = 0;
                        cSh.select (cmd.getCommandBuffer ());
                    }                    
                }
            } catch {
                err => log::error #("ShapeDrawer", "Failed to draw...", err);                    
            }
        }
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          TRIGGERS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Triggered when the window change size
     * */
    pub fn onWindowResize (mut self, x : u32, y : u32) {
        atomic self {
            self._windowDimension = makeVec2 (x, y);                        
        }
    }

    @{final}
    pub fn redraw (mut self) {
        self._needRedraw = true;
    }

    /**
     * Commit the change of shapes in the last iteration
     * */
    pub fn commit (mut self) {
        atomic self {
            let mut forceFrame = false;
            for dmut c in alias self._shapeList {
                if (c:.commit ()) {
                    forceFrame = true;
                }
            }
            
            if self._needRedraw {
                self._window:.redrawPipeline ();                
                self._needRedraw = false;
            }

            if forceFrame {
                self._window:.forceFrame ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLEARING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Clear all loaded widgets
     * */
    pub fn clear (mut self) {
        atomic self {            
            for dmut c in alias self._shapeList {
                self._window:.insertBin (alias c);                
            }

            self._shapeList = copy ShapeList ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self:.clear ();

            atomic self {                                                        
                self._colorShader:.dispose ();
                self._textureShader:.dispose ();                                
                
                self._window:.insertBin (alias self._quadColorVBO);
                self._window:.insertBin (alias self._quadTextureVBO);
                self._window:.insertBin (alias self._quadIBO);
            }
        }
    }

}
