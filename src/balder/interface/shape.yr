in shape;

use balder::math::_;
use balder::core::{_,
                   shader::_,
                   shader::buffers::_,
                   application::_,
                   driver::_,
                   config::{_, shader::_}};

use balder::utils::_;
use balder::interface::drawer;

use ::vulkan::core;

pub mod ::color;
pub mod ::texture;
pub mod ::list;

extern (C) fn printf (c : *c8, ...);

record World {
    pub let mut pos : vec2 = vec2 ();
    pub let mut size : vec2 = vec2 ();
    pub let mut color : vec4 = vec4 ();
    
    pub let mut level : u32 = 0;
            
    pub self () {}
}

/**
 * Ancestor class of shapes that are drawn in 2D by the ShapeDrawer
 * */
@abstract
pub class Shape {

    pub let uid : usize;

    let dmut _context : &ShapeDrawer;

    let _vbo : &VertexBufferObject;
    let _ibo : &IndexBufferObject;

    let dmut _ubo : &UniformBufferObject;
    let dmut _descSet : (&DescriptorSet)?;

    let mut _hidden : bool = false;    
    let mut _needRedraw : bool = false;
    let mut _changed : bool = false;

    let mut _world : World = World ();
    let mut _scissors : vec4 = vec4 ();
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (uid : usize,
              dmut drawer : &ShapeDrawer,
              vbo : &VertexBufferObject,
              ibo : &IndexBufferObject,
              dmut ubo : &UniformBufferObject,
              dmut descSet : &DescriptorSet)

        with uid = uid
        , _context = alias drawer
        , _vbo = vbo
        , _ibo = ibo
        , _ubo = alias ubo
        , _descSet = (alias descSet)?
    
    {        
        descSet:.setUniform (UniformNames::WORLD, ubo);
    }

    __dtor (mut self) {
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the position of the shape in the window (in pixels, (0,0) being top left corner)
     * */
    pub fn setPosition (mut self, pos : vec2) {
        self._world.pos = pos;        
        self._changed = true;
    }

    /**
     * Change the size of the shape in the window (in pixels)
     */
    pub fn setSize (mut self, size : vec2) {
        self._world.size = size;        
        self._changed = true;
    }

    /**
     * Change the roundeness of the corner of the shape
     */
    pub fn setLevel (mut self, v : u32) {
        self._world.level = v;
        self._changed = true;
    }

    /**
     * Change the color of the shape
     */
    pub fn setColor (mut self, v : vec4) {
        self._world.color = v;
        self._changed = true;
    }
    
    /**
     * Change the scissors of the shape
     */
    pub fn setScissors (mut self, pos : vec2, size : vec2) {
        self._scissors = makeVec4 (pos.x, pos.y, pos.x + size.x, pos.y + size.y);
        self._changed = true;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          HIDE/SHOW          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    @field
    pub fn level (self)-> u32 {
        self._world.level
    }
    
    /**
     * Hide the shape in the next drawing
     * */
    @final
    pub fn hide (mut self) {
        if !self._hidden {
            self._hidden = true;
            self._needRedraw = true;
        }
    }

    /**
     * Show the shape in the next drawing
     * */
    @final
    pub fn show (mut self) {
        if self._hidden {
            self._hidden = false;
            self._needRedraw = true;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          COMMIT          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Commit the modifications of the shape to be rendered in the next frame
     * */
    pub fn commit (mut self)-> bool {
        let mut toReturn = false;
        if self._changed {            
            self._ubo:.setData (0, self._world, commit-> true);
            self._changed = false;

            toReturn = true;
        }

        if self._needRedraw {
            self._context:.redraw ();
            self._needRedraw = false;
        }

        toReturn
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: true iif the shape is hidden (and therefore must not be drawn)
     * */
    @final
    pub fn isHidden (self)-> bool {
        self._hidden 
    }

    /**
     * @returns: the number of points composing the shape
     * */
    @final
    pub fn getNbPoints (self)-> u32 {
        self._ibo.getNbPoints ()
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Draw the shape
     * @assume: already registered and at correct index
     * */
    @final
    pub fn draw (self, frame : u32, dmut cmd : &IndexedDrawCommandAllocator) {
        if let Ok (ds) = self._descSet {
            let mut scissor = VkRect2D ();
            scissor.offset.x = cast!i32 (self._scissors.x);
            scissor.offset.y = cast!i32 (self._scissors.y);
            
            scissor.extent.width = cast!u32 (self._scissors.z);
            scissor.extent.height = cast!u32 (self._scissors.w);
                        
            vkCmdSetScissor (cmd.getCommandBuffer (), 0, 1, &scissor);
            
            ds.select (frame, cmd.getCommandBuffer ());
            self._vbo.select (cmd.getCommandBuffer ());
            self._ibo.select (cmd.getCommandBuffer ());

            cmd:.drawNextIndexed ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {            
            if let Ok (dmut ds) = alias self._descSet {
                ds:.dispose ();                                
                self._descSet = none;
            }
            
            self._ubo:.dispose ();            
        }
    }

}
