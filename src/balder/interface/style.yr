in style;

use std::algorithm::searching;
use std::{config, config::_, conv};

use balder::core::error;
use balder::interface::_;
use balder::math::_;
use balder::utils::palette;

/**
 * Style definition
 * */
pub record Style {

    pub let mut backgroundColor = (false, vec4 ());
    pub let mut borderColor = (false, vec4 ());
    pub let mut textColor = (false, vec4 ());
    pub let mut selectionColor = (false, vec4 ());

    pub let mut font = (false, "");
    pub let mut fontSize = (false, 0u32);

    pub let dmut borderSize = (false, 0u32);
    pub let dmut radius = (false, 0u32);

    pub let dmut paddingSize = [(false, WidgetSize ()) ; 5];
    pub let dmut marginSize = [(false, WidgetSize ()) ; 5];


    pub self () {}

    pub fn opEquals (self, other : Style)-> bool {
        if self.backgroundColor != other.backgroundColor { return false; }
        if self.borderColor != other.borderColor { return false; }
        if self.textColor != other.textColor { return false; }
        if self.selectionColor != other.selectionColor { return false; }

        if self.font != other.font { return false; }
        if self.fontSize != other.fontSize { return false; }

        if self.borderSize != other.borderSize { return false; }
        if self.paddingSize != other.paddingSize { return false; }
        if self.marginSize != other.marginSize { return false; }

        if self.radius != other.radius { return false; }

        true
    }

}


/**
 * Manager of defined styles
 * */
pub class StyleManager {

    // The list of defined style classes
    let dmut _classes : [[c8] => Style] = copy [];

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create an empty style manager
     * */
    pub self () {}

    /**
     * Create a style manager from a configuration containing styles
     * */
    pub self (cfg : &Config)
        throws BalderError
    {
        self:.load (cfg);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONFIGURATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a configuration file containing multiple classes
     * */
    pub fn load (mut self, cfg : &Config)
        throws BalderError
    {
        if let d : &Dict = cfg {
            for name, cl in d[] {
                self:.registerClass (name, cl);
            }
        } else {
            throw copy BalderError ("Expected a dictionnary in style configuration");
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Register a style for a class
     * @params:
     *    - name: the name of the style
     *    - style: the registered style
     * */
    pub fn registerClass (mut self, name : [c8], style : Style) {
        self._classes [name] = style;
    }

    /**
     * Register a style for a class from a configuration
     * @params:
     *    - name: the name of the style
     *    - style: the registered style
     * */
    pub fn registerClass (mut self, name : [c8], style : &Config)
        throws BalderError
    {
        let mut resultStyle = Style ();
        if let Ok (back) = style ["background-color"]? {
            resultStyle.backgroundColor = (true, self.loadColor (back.to!{[c8]} ()));
        }

        if let Ok (back) = style ["selection-color"]? {
            resultStyle.selectionColor = (true, self.loadColor (back.to!{[c8]} ()));
        }

        if let Ok (bo) = style ["border-color"]? {
            resultStyle.borderColor = (true, self.loadColor (bo.to!{[c8]} ()));
        }

        if let Ok (txt) = style ["text-color"]? {
            resultStyle.textColor = (true, self.loadColor (txt.to!{[c8]} ()));
        }

        if let Ok (font) = style ["font"]? {
            resultStyle.font = (true, font.to!{[c8]} ());
        }

        if let Ok (fontSize) = style ["font-size"]? {
            resultStyle.fontSize = (true, fontSize.to!{u32} ());
        }

        if let Ok (s) = style ["border"]? {
            resultStyle.borderSize = (true, s.to!{u32} ());
        }

        resultStyle.paddingSize = self.loadSizes (style, "padding");
        resultStyle.marginSize = self.loadSizes (style, "margin");

        if let Ok (s) = style ["radius"]? {
            resultStyle.radius = (true, s.to!{u32} ());
        }

        self._classes [name] = resultStyle;
    } catch {
        b : &BalderError => throw b;
        err : _ => throw copy BalderError ("Failed to load style configuration " ~ err.to!{[c8]} ());
    }


    /**
     * Load a color that can be formatted using hexadecimal code (e.g. #FFFFFF), or using palette code (e.g. purple!10)
     * @returns: the vec4 of the rgba components of the color
     * */
    fn loadColor (self, color : [c8])-> vec4
        throws BalderError
    {
        {
            if let Ok (pos) = color.find (';') {
                let transparency = color [pos + 1 .. $].to!{f32} ();
                let mut res = self.loadColor (color [0 .. pos]);
                return makeVec4 (res.xyz, transparency);
            }

            if color.len != 0 && color [0] == '#' {
                return balder::utils::palette::colorFromHex (("0x" ~ color [1 .. $]).to!{u32, "x"} ());
            }

            if let Ok (pos) = color.find ('!') {
                let strength = cast!f32 (color [pos + 1 .. $].to!{u32} ()) / 100.f;
                let name = color [0 .. pos];

                return ColorPalette.get (name, strength);
            }
        } catch {
            b : &BalderError => throw b;
            _ => throw copy BalderError ("Failed to load color : " ~ color);
        }

        throw copy BalderError ("Failed to load color : " ~ color);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SIZES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the size configuration
     * @params:
     *    - style: the configuration
     *    - kind: the kind of sizes to read
     * @returns: the sizes for all, top, bottom, left right where i._0 is set to true if set
     * */
    fn loadSizes (self, style : &Config, kind : [c8])-> [(bool, WidgetSize) ; 5]
        throws BalderError
    {
        let dmut result = [(false, WidgetSize ()) ; 5];
        if let Ok (s) = style [kind]? {
            result [0] = (true, WidgetSize (s));
        }

        if let Ok (s) = style [kind ~ "-top"]? {
            result [1] = (true, WidgetSize (s));
        } else result [1] = result [0];

        if let Ok (s) = style [kind ~ "-bottom"]? {
            result [2] = (true, WidgetSize (s));
        } else result [2] = result [0];

        if let Ok (s) = style [kind ~ "-left"]? {
            result [3] = (true, WidgetSize (s));
        } else result [3] = result [0];

        if let Ok (s) = style [kind ~ "-right"]? {
            result [4] = (true, WidgetSize (s));
        } else result [4] = result [0];

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Retreive a style from a list of class names and the kind of widget that will be rendered
     * @params:
     *    - classList: the list of class to load
     * @returns: the composition of the style from the list of classes
     * @info: the order of classList is important, last class overrides the previous one
     * */
    pub fn get (self, classList : [c8])-> Style {
        let mut resultStyle = Style ();
        let mut current = classList;

        while current.len > 0 {
            let fst = if let Ok (pos) = current.find ('.') {
                let fst = current [0 .. pos];
                current = current [pos + 1 .. $];
                fst
            } else {
                let fst = current;
                current = "";
                fst
            };

            if let Ok (s) = self._classes [fst] {
                if s.backgroundColor.0 { resultStyle.backgroundColor = s.backgroundColor; }
                if s.selectionColor.0 { resultStyle.selectionColor = s.selectionColor; }
                if s.textColor.0 { resultStyle.textColor = s.textColor; }
                if s.borderColor.0 { resultStyle.borderColor = s.borderColor; }

                if s.font.0 { resultStyle.font = s.font; }

                if s.fontSize.0 { resultStyle.fontSize = s.fontSize; }

                if s.borderSize.0 { resultStyle.borderSize = s.borderSize; }
                if s.radius.0 { resultStyle.radius = s.radius; };

                for i in 0 .. 5 {
                    if s.marginSize [i].0 { resultStyle.marginSize [i] = s.marginSize [i]; }
                    if s.paddingSize [i].0 { resultStyle.paddingSize [i] = s.paddingSize [i]; };
                }


            }
        }

        resultStyle
    }

}
