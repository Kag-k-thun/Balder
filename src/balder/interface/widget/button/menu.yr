in menu;

use balder::core::application::_;
use balder::core::_;
use balder::math::_;

use balder::interface::_;
use balder::utils::_;

use balder::interface::widget::text::label;
use balder::interface::widget::layout::menu;
use balder::interface::widget::alignement;

use ::std::fs::path;

/**
 * A menu button is a button that once clicked (or just hovered depending on its configuration) opens a floating menu item list
 * */
pub class MenuButton over Button {

    // The menu item to display on click
    let dmut _menu : (&Widget)? = none;

    // The id of the menu in the root floating layout (to open and close it)
    let mut _menuId : usize = 0;

    // if true display the menu even if the button is just hovered
    let mut _onlyHover : bool = false;

    // The alignement of the menu when opened
    let mut _xalign : XAlign = XAlign::LEFT;

    // The alignement of the menu when opened
    let mut _yalign : YAlign = YAlign::BOTTOM;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8])
        with super (alias manager, name, WidgetKeys::MENU_BUTTON)
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn setMenu (mut self, dmut menu : &Widget) {
        self:.closeMenu ();
        self._menu = (alias menu)?;
    }

    pub fn setMenuAlignment (mut self, xalign : XAlign, yalign : YAlign) {
        self:.closeMenu ();
        self._xalign = xalign;
        self._yalign = yalign;
    }

    pub fn setOnlyHover (mut self, b : bool) {
        self:.closeMenu ();
        self._onlyHover = b;
    }

    pub over onAttach (mut self, parentPath : Path) {
        self.__super__:.onAttach (parentPath);
    }

    pub over setMenuContext (mut self, dmut menu : &MenuLayout) {
        self._menuContext = (alias menu)?;
        if let Ok (dmut i) = alias self._menu {
            i:.setMenuContext (alias menu);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onHover (mut self, _ : vec2)-> dmut (&Widget)? {
        if !self.isHover () {
            if self._onlyHover && !self:.menuExists () {
                if let Ok (dmut menuCtx) = alias self._menuContext {
                    menuCtx:.closeAllNonParentMenu (self._path);
                }

                self:.openMenu ();
            }
        }

        self:.setHover (true);
        (alias self)?
    }

    pub over onClick (mut self, _ : vec2, _ : u8)-> dmut (&Widget)? {
        if let Ok (dmut menuCtx) = alias self._menuContext {
            menuCtx:.closeAllNonParentMenu (self._path);
        }

        self:.openMenu ();

        self:.setChecked (true);
        (alias self)?
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          OPEN/CLOSE MENU          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Open the menu associated to the button on the screen
     * */
    fn openMenu (mut self) {
        self:.closeMenu ();
        if let Ok (dmut menu) = alias self._menu {
            if let Ok (dmut menuCtx) = alias self._menuContext {
                let x = match self._xalign {
                    XAlign::LEFT => { self._absolutePosition.x }
                    XAlign::RIGHT => { self._absolutePosition.x + self._absoluteSize.x }
                    _ => { self._absolutePosition.x + (self._absoluteSize.x)/2.f }
                };

                let y = match self._yalign {
                    YAlign::TOP => { self._absolutePosition.y }
                    YAlign::BOTTOM => { self._absolutePosition.y + self._absoluteSize.y }
                    _ => { self._absolutePosition.y + (self._absoluteSize.y)/2.f }
                };

                self._menuId = menuCtx:.openMenu (alias menu,
                                             x-> WidgetSize (pix-> cast!u32 (x)),
                                             y-> WidgetSize (pix-> cast!u32 (y)),
                                             fromMenuBar-> true,
                                                  by-> self._path);
            } else {
                log::error #("MenuButton", "Menu cannot be opened outside a menu layout context");
            }
        }
    }

    /**
     * Close the item menu associated to the button
     * */
    fn closeMenu (mut self) {
        if self._menuId != 0 {
            if let Ok (dmut menuCtx) = alias self._menuContext {
                menuCtx:.closeChildMenus (self._path);
                menuCtx:.closeMenu (self._menuId);
            } else {
                log::error #("MenuButton", "Menu cannot be opened outside a menu layout context");
                panic;
            }

            self._menuId = 0;
        }
    }

    /**
     * Verify that the menu of the button is open
     * @returns: true if still open on the root layout
     * */
    fn menuExists (mut self)-> bool {
        if self._menuId == 0 {
            return false;
        }

        if let Ok (menuCtx) = self._menuContext {
            if !menuCtx.isMenuOpened (self._menuId) {
                self._menuId = 0;
            }
        }

        self._menuId != 0
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSABLE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            self:.closeMenu ();

            if let Ok (dmut d) = alias self._menu {
                d:.dispose ();
            }

            self.__super__:.dispose ();
        }


    }



}
