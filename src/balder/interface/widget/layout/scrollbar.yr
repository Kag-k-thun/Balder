in scrollbar;

use ::std::algorithm::comparison;

use std::io;

use balder::utils::_;
use balder::core::{_, application::_};
use balder::math::_;

use balder::interface::_;
use balder::interface::widget::_;

use ::sdl2::_;

pub class ScrollLayout over Layout {

    // The scrollable layout
    let dmut _layout : &LinearLayout;

    // The size of the scrollbar square
    let _scrollSize : WidgetSize;

    // true iif the layout was hovered in last hover
    let mut _lastHoverLayout = false;

    prot { // computed sizes

        // The size of the scrollbar relative to the layout
        let mut _relScrollBarSize : vec2 = vec2 ();

        // The position of the scrollbar
        let mut _relScrollBarPos : vec2 = vec2 ();

        // The current shifting of the scrollbar
        let mut _scrollShift = 0.f;

        // The length of the scrollable part
        let mut _scrollLen = 0.f;

    }

    prot { // Colors

        // The color of the scrollbar
        let _scrollColor : vec4 = vec4 ();

        // The color of the scrollbar when hovered
        let _scrollHoverColor : vec4 = vec4 ();

        // The color of the scrollbar when clicked
        let _scrollClickColor : vec4 = vec4 ();

        // The current color of the scrollbar
        let mut _currentColor : vec4 = vec4 ();

    }

    prot { // slide/scroll

        // The slide start when sliding event starts
        let mut _slideStart : vec2 = vec2 ();

        // The scroll start when scroll event starts
        let mut _scrollStart : f32 = 0.f;

        // The cursor to display when hovering the scrollbar
        let dmut _scrollMouseCursor : *SDL_Cursor = SDL_CreateSystemCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_HAND);

        // The default cursor of the system (to restore when on hover end)
        let _defaultMouseCursor : *SDL_Cursor = SDL_GetDefaultCursor ();

    }

    prot { // Shape

        // The shape of the scrollbar to draw
        let dmut _shape : (&Shape)? = none;

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8], dmut layout : &LinearLayout,
              scrollSize : WidgetSize = WidgetSize (minPix-> 10),
              scrollColor : vec4 = ColorPalette.get (DefaultColorPalettes::GREY, 0.f),
              scrollHoverColor : vec4 = ColorPalette.get (DefaultColorPalettes::GREY, 0.1f),
              scrollClickColor : vec4 = ColorPalette.get (DefaultColorPalettes::GREY, 0.2f))

        with super (alias manager, name)
        , _layout = alias layout
        , _scrollSize = scrollSize
        , _scrollColor = scrollColor
        , _scrollHoverColor = scrollHoverColor
        , _scrollClickColor = scrollClickColor
        , _currentColor = scrollColor
    {
        let dmut shDr = manager:.getApplication ():.getShapeDrawer ();

        {
            let dmut shape = shDr:.registerQuad (vec2 (), self._scrollColor, vec2 ());
            self._shape = (alias shape)?;
        } catch {
            err => {
                log::error #("Scrollbar", "Failed to add shape : ", err);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    prot over onUpdateSizes (mut self, pos : vec2, viewport : vec2, depth : u32) {
        self._layout:.updateSizes (pos, viewport, depth);
        let maxDepth = self._layout.getMaxDepth ();
        let layoutSize = self._layout.getFullLength ();

        self._depth = maxDepth + 1;

        if (layoutSize <= 1.f) {
            self._scrollShift = 0.f;
            self._scrollLen = 1.f;
            self._layout:.setShift (0.f);
            if let Ok (dmut sh) = alias self._shape {
                sh:.hide (); // no scrollbar if not needed
            }

            return;
        }

        self._scrollLen = 1.f / layoutSize;
        self._scrollShift = -(self._layout.shift / layoutSize);

        if self._scrollShift + self._scrollLen > 1.f {
            self._scrollShift = 1.f - self._scrollLen;
        }

        self._layout:.setShift (-(self._scrollShift * layoutSize));
        if self._layout.isVertical () {
            self._relScrollBarSize = makeVec2 (self.clampSize (WidgetSize (relative-> self._scrollLen), viewport.x),
                                               self.clampSize (self._scrollSize, viewport.y));

            self._relScrollBarPos = makeVec2 (self.clampSize (WidgetSize (relative-> self._scrollShift), viewport.x),
                                              1.f - self._relScrollBarSize.y);

        } else {
            self._relScrollBarSize = makeVec2 (self.clampSize (self._scrollSize, viewport.x),
                                               self.clampSize (WidgetSize (relative-> self._scrollLen), viewport.y));

            self._relScrollBarPos = makeVec2 (1.f - self._relScrollBarSize.x,
                                              self.clampSize (WidgetSize (relative-> self._scrollShift), viewport.y));
        }

        if let Ok (dmut sh) = alias self._shape {
            sh:.setPosition ((self._relScrollBarPos - pos) * viewport);
            sh:.setSize (self._relScrollBarSize * viewport);
            sh:.setLevel (self._depth);
            sh:.show ();
        }
    }

    pub over hide (mut self) {
        self._layout:.hide ();
        if let Ok (dmut sh) = alias self._shape {
            sh:.hide ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over getMaxDepth (self)-> u32 {
        // The depth of the scrollbar is already computed to be bigger than anything within the layout
        self._depth
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onHover (mut self, pos : vec2) {
        if self.mouseOnLayout (pos) {
            self._layout:.onHover (pos);
            self._lastHoverLayout = true;
            self:.changeScrollColor (self._scrollColor);
        } else {
            if self._lastHoverLayout {
                self._lastHoverLayout = false;
                self._layout:.onHoverEnd ();
            }

            self:.changeScrollColor (self._scrollHoverColor);
        }
    }

    pub over onHoverEnd (mut self) {
        if self._lastHoverLayout {
            self._layout:.onHoverEnd ();
            self._lastHoverLayout = false;
        }

        self:.changeScrollColor (self._scrollColor);
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut sh) = alias self._shape {
                sh:.dispose ();
                self._shape = none;
            }

            self._layout:.dispose ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn changeScrollColor (mut self, color : vec4) {
        if self._currentColor != color {
            self._currentColor = color;
            if let Ok (dmut sh) = alias self._shape {
                sh:.setColor (color);
            }
        }
    }

    fn mouseOnLayout (self, pos : vec2)-> bool {
        if self._scrollLen != 1.f {
            if self.isInSquare (pos, self._relScrollBarPos, self._relScrollBarPos + self._relScrollBarSize) {
                return false;
            }
        }

        true
    }

}
