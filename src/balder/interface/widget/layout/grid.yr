in grid;

use ::std::algorithm::comparison;

use std::io;

use balder::core::_;
use balder::math::_;
use balder::interface::_;
use balder::interface::widget::_;


pub class GridLayout over Layout {

    // The widget in the grid
    let dmut _childs : [(&Widget)?] = [];

    // The border size
    let _border : WidgetSize;

    // The margin between the columns
    let _margin : WidgetSize;

    // The number of columns in the grid
    let _cols : u32;

    // The number of rows in the grid
    let _rows : u32;

    // The widget that was hovered the last (to send onHoverEnd)
    let dmut _lastHover : (&Widget)? = none;

    // Relative sizes computed on updateSize
    let mut _relMarginSize : vec2 = vec2 ();
    let mut _relBorderSize : vec2 = vec2 ();
    let mut _relCellSize : vec2 = vec2 ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8], columns : u32, rows : u32, margin : WidgetSize = WidgetSize (), border : WidgetSize = WidgetSize ())
        with super (alias manager, name)
        , _margin = margin
        , _border = border
        , _lastHover = none
        , _cols = columns
        , _rows = rows
        , _childs = copy [none ; columns * rows]
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the drawing size of the inner widgets
     */
    prot over onUpdateSizes (mut self, pos : vec2, viewport : vec2, depth : i32) {
        self._relMarginSize = makeVec2 (self.clampSize (self._margin, viewport.x),
                                        self.clampSize (self._margin, viewport.y));

        self._relBorderSize = makeVec2 (self.clampSize (self._margin, viewport.x),
                                        self.clampSize (self._margin, viewport.y));


        let nbMarginsX = cast!f32 (if self._cols != 0 { self._cols - 1 } else { 0 });
        let nbMarginsY = cast!f32 (if self._rows != 0 { self._rows - 1 } else { 0 });

        self._relCellSize = makeVec2 (1.0f / cast!{f32} (self._cols) - (self._relMarginSize.x * nbMarginsX) - self._relBorderSize.x,
                                      1.0f / cast!{f32} (self._rows) - (self._relMarginSize.y * nbMarginsY) - self._relBorderSize.y);

        let mut currentX = self._relBorderSize.x;
        let absCellSize = self._relCellSize * viewport;
        for i in 0 .. self._cols {
            let mut currentY = self._relBorderSize.y;
            for j in 0 .. self._rows {
                if let Ok (dmut c) = alias self._childs [i * self._rows + j] {
                    let absCellPos = makeVec2 (currentX, currentY) * viewport + pos;
                    c:.updateSizes (absCellPos, absCellSize, depth + 1);
                }

                currentY += self._relCellSize.y + self._relMarginSize.y;
            }

            currentX += self._relCellSize.x + self._relMarginSize.x;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSERT CHILDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Insert a child in the layout
     * @warning: child is disposed when layout is disposed
     * */
    pub fn insertChild (mut self, col : u32, row : u32, dmut ch : &Widget) {
        self._childs [col * self._rows + row] = (alias ch)?;
        self._manager:.updateWidgets ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the signal to the childs
     * @params:
     *   - pos: the relative position of the cursor within the layout
     */
    pub over onHover (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            if let Ok (dmut h) = alias self._lastHover && h !is c {
                h:.onHoverEnd ();
            }

            c:.onHover (v);
            self._lastHover = (alias c)?;
        } else {
            if let Ok (dmut h) = alias self._lastHover {
                h:.onHoverEnd ();
            }
        }
    }

    /**
     * Propagate the signal to the childs
     */
    pub over onHoverEnd (mut self) {
        if let Ok (dmut h) = alias self._lastHover {
            h:.onHoverEnd ();
            self._lastHover = none;
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClickLeft (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onClickLeft (v);
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClickLeftEnd (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onClickLeftEnd (v);
        }
    }

    /**
     * Propagate the event to the childrens
     */
    pub over onScroll (mut self, pos : vec2, amountX : i32, amountY : i32)-> bool {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            return c:.onScroll (v, amountX, amountY);
        }

        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            for i in 0 .. self._childs.len {
                if let Ok (dmut c) = alias self._childs [i] {
                    c:.dispose ();
                    self._childs [i] = none;
                }
            }

            if let Ok (dmut sh) = alias self._shape {
                sh:.dispose ();
                self._shape = none;
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns:
     *  - .1 : the widget on which the mouse is positionned
     *  - .2 : the position of the mouse relative to the widget
     */
    fn mouseToWidget (mut self, pos : vec2)-> dmut (&Widget, vec2)? {
        if pos.y < self._relBorderSize.y || pos.y > 1.f - self._relBorderSize.y {
            return none;
        }

        if pos.x < self._relBorderSize.x || pos.x > 1.f - self._relBorderSize.x {
            return none;
        }

        return none;
    }
}
