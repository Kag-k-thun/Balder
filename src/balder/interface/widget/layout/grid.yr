in grid;

use ::std::algorithm::comparison;

use std::io;

use balder::core::_;
use balder::math::_;
use balder::interface::_;
use balder::interface::widget::_;


pub class GridLayout over Layout {

    // The widget in the grid
    let dmut _childs : [(&Widget)?] = [];

    // The border size
    let _border : WidgetSize;

    // The margin between the columns
    let _margin : WidgetSize;

    // The number of columns in the grid
    let _cols : u32;

    // The number of rows in the grid
    let _rows : u32;

    // The widget that was hovered the last (to send onHoverEnd)
    let dmut _lastHover : (&Widget)? = none;

    // Relative sizes computed on updateSize
    let mut _relMarginSize : vec2 = vec2 ();
    let mut _relBorderSize : vec2 = vec2 ();
    let mut _relCellSize : vec2 = vec2 ();

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8], columns : u32, rows : u32, margin : WidgetSize = WidgetSize (), border : WidgetSize = WidgetSize ())
        with super (alias manager, name)
        , _margin = margin
        , _border = border
        , _lastHover = none
        , _cols = columns
        , _rows = rows
        , _childs = copy [none ; columns * rows]
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the drawing size of the inner widgets
     */
    prot over onUpdateSizes (mut self, pos : vec2, viewport : vec2, depth : i32) {
        if self._childs.len == 0 { return; }

        self._relMarginSize = makeVec2 (self.clampSize (self._margin, viewport.x),
                                        self.clampSize (self._margin, viewport.y));

        self._relBorderSize = makeVec2 (self.clampSize (self._border, viewport.x),
                                        self.clampSize (self._border, viewport.y));


        let nbCells = makeVec2 (cast!f32 (self._cols), cast!f32 (self._rows));
        let absCellSize = (viewport - ((self._relBorderSize * 2.f + self._relMarginSize * (nbCells - 1.f)) * viewport)) / nbCells;
        self._relCellSize = absCellSize / viewport;

        let mut currentX = self._relBorderSize.x;
        for i in 0 .. self._cols {
            let mut currentY = self._relBorderSize.y;
            for j in 0 .. self._rows {
                if let Ok (dmut c) = alias self._childs [i * self._rows + j] {
                    let absCellPos = makeVec2 (currentX, currentY) * viewport + pos;
                    c:.updateSizes (absCellPos, absCellSize, depth + 1);
                }

                currentY += self._relCellSize.y + self._relMarginSize.y;
            }

            currentX += self._relCellSize.x + self._relMarginSize.x;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSERT CHILDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Insert a child in the layout
     * @warning: child is disposed when layout is disposed
     * */
    pub fn insertChild (mut self, col : u32, row : u32, dmut ch : &Widget) {
        self._childs [col * self._rows + row] = (alias ch)?;
        self._manager:.updateWidgets ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the signal to the childs
     * @params:
     *   - pos: the relative position of the cursor within the layout
     */
    pub over onHover (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            if let Ok (dmut h) = alias self._lastHover && h !is c {
                h:.onHoverEnd ();
            }

            c:.onHover (v);
            self._lastHover = (alias c)?;
        } else {
            if let Ok (dmut h) = alias self._lastHover {
                h:.onHoverEnd ();
            }
        }
    }

    /**
     * Propagate the signal to the childs
     */
    pub over onHoverEnd (mut self) {
        if let Ok (dmut h) = alias self._lastHover {
            h:.onHoverEnd ();
            self._lastHover = none;
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClickLeft (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onClickLeft (v);
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClickLeftEnd (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onClickLeftEnd (v);
        }
    }

    /**
     * Propagate the event to the childrens
     */
    pub over onScroll (mut self, pos : vec2, amountX : i32, amountY : i32)-> bool {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            return c:.onScroll (v, amountX, amountY);
        }

        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            for i in 0 .. self._childs.len {
                if let Ok (dmut c) = alias self._childs [i] {
                    c:.dispose ();
                    self._childs [i] = none;
                }
            }

            if let Ok (dmut sh) = alias self._shape {
                sh:.dispose ();
                self._shape = none;
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns:
     *  - .1 : the widget on which the mouse is positionned
     *  - .2 : the position of the mouse relative to the widget
     */
    fn mouseToWidget (mut self, pos : vec2)-> dmut (&Widget, vec2)? {
        if self._childs.len == 0 { return none; }

        if pos.y <= self._relBorderSize.y || pos.y >= (1.f - self._relBorderSize.y) {
            return none;
        }

        if pos.x <= self._relBorderSize.x || pos.x >= (1.f - self._relBorderSize.x) {
            return none;
        }

        let x = (pos.x - self._relBorderSize.x) / (1.0f - (self._relBorderSize.x * 2.f));
        let y = (pos.y - self._relBorderSize.y) / (1.0f - (self._relBorderSize.y * 2.f));

        let cellX = cast!u32 (x * cast!f32 (self._cols));
        let cellY = cast!u32 (y * cast!f32 (self._rows));

        if cellY >= self._rows || cellX >= self._cols { return none; }

        let cellPosition = self._relBorderSize + makeVec2 ((self._relCellSize.x + self._relMarginSize.x) * cast!f32 (cellX),
                                                           (self._relCellSize.y + self._relMarginSize.y) * cast!f32 (cellY));

        let relPos = (pos - cellPosition) / self._relCellSize;
        if relPos.x >= 0.f && relPos.x <= 1.f && relPos.y >= 0.f && relPos.y <= 1.f {
            if let Ok (dmut c) = alias self._childs [cellX * self._rows + cellY] {
                return (alias c, relPos)?;
            }
        }

        return none;
    }
}
