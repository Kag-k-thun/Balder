in tab;

use ::std::algorithm::comparison;

use std::{io, time::_};

use balder::utils::_;
use balder::core::{_, application::_};
use balder::core::shader::_;
use balder::math::_;

use balder::interface::_;
use balder::interface::widget::_;
use balder::interface::widget::layout::linear;
use balder::interface::widget::text::label;

use ::sdl2::mouse;
use ::sdl2::events;


record Tab {

    // The bacground shape of the tabs
    pub let dmut shape : (&Shape)? = none;
    pub let dmut border : (&Shape)? = none;

    pub let dmut label : (&Label)? = none;

    pub let mut head : [c8];

    // The content to display when tab is selected
    pub let dmut widget : &Widget;

    // Position of the tab content
    pub let dmut relPos : vec2;
    pub let dmut relSize : vec2;

    pub self (dmut widget : &Widget, head : [c8], relPos : vec2 = vec2 (), relSize : vec2 = vec2 ())
        with widget = alias widget
        , head = head
        , relPos = relPos
        , relSize = relSize
    {}
}

pub class TabLayout over Widget {

    prot { // Tabs and layout

        // The list of tabs
        let dmut _tabs : [Tab] = [];

        // The selected layout
        let dmut _layout : (Tab)? = none;

        // The selected tab index
        let dmut _selectedIndex : usize = 0;

        // The relative size of a tab header
        let mut _tabRelSize : vec2 = vec2 ();

        // The relative size of a tab header
        let mut _tabInnerRelSize : vec2 = vec2 ();

        // The size of the border
        let mut _borderRelSize : vec2 = vec2 ();

    }

    prot { // mouse events

        // True if the selected layout is the last widget being hovered
        let dmut _lastHoverLayout : bool = false;

        // The index of the tab being hovered (>= self._tabs.len if none)
        let dmut _hoverIndex : usize = usize::max;

    }



    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */


    pub self (dmut manager : &WidgetManager, name : [c8])
        with super (alias manager, name, WidgetKeys::TAB_LAYOUT)
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self) {
        self._attached = true;
        if let Ok (dmut w) = alias self._layout {
            w.widget:.onAttach ();
        }

        for dmut t in alias self._tabs {
            if let Ok (dmut lbl) = alias t.label {
                lbl:.onAttach ();
            }
        }
    }

    pub over onDetach (mut self) {
        self._attached = false;
        if let Ok (dmut w) = alias self._layout {
            w.widget:.onDetach ();
        }

        for dmut t in alias self._tabs {
            if let Ok (dmut lbl) = alias t.label {
                lbl:.onDetach ();
            }
        }

        self:.dispose ();
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSERT CHILDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Insert a new tab in the layout
     * @params:
     *    - head: the name displayed as a label in the header tab
     *    - ch: the widget displayed when tab is selected
     * */
    pub fn insertTab (mut self, head : [c8], dmut ch : &Widget) {
        self._tabs ~= [Tab (alias ch, head, relPos-> makeVec2 (0.f, 0.f), relSize-> makeVec2 (0.f, 0.f))];
        if !self._layout.hasValue {
            self._layout = (alias self._tabs [0])?;
            self._selectedIndex = (self._tabs.len - 1);

            if self._attached {
                self._tabs [0].widget:.onAttach ();
            }
        }

        self:.insertHeader (head, self._selectedIndex == (self._tabs.len - 1));
        self._manager:.updateWidgets ();
    }

    fn insertHeader (mut self, head : [c8], selected : bool) {
        let dmut newLbl = copy Label (alias self._manager, head);
        newLbl:.setText (head);

        self._tabs [$ - 1].label = (alias newLbl)?;

        let dmut shDr = self._manager:.getShapeDrawer ();
        {
            let dmut shape = shDr:.registerColorQuad ();
            let selectStyle = self._manager:.getStyleManager ().get (self._widgetKind,
                                                                     self._styleClasses,
                                                                     !selected,
                                                                     selected,
                                                                     false);


            let tabStyle = selectStyle.getSubStyle ("tab");

            shape:.setRadius (tabStyle.radius._1);
            shape:.setColor (tabStyle.getColor (WidgetShapeKind::BACKGROUND));

            let dmut border = shDr:.registerColorQuad ();
            border:.setRadius (tabStyle.radius._1);
            border:.setColor (tabStyle.getColor (WidgetShapeKind::BORDER));


            self._tabs [$ - 1].shape = (alias shape)?;
            self._tabs [$ - 1].border = (alias border)?;
        } catch {
            err => {
                log::error #("TabLayout", "Failed to construct shapes : ", err);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        let minSize = self._absoluteSize.y / cast!f32 (cast!u32 (self._tabs.len));
        let tabWidth = std::algorithm::comparison::min (minSize, 100.f);
        let tabHeight = 40.f;

        let wpos = makeVec2 (self._absolutePosition.x, self._absolutePosition.y + tabHeight);
        let wsize = makeVec2 (self._absoluteSize.x, self._absoluteSize.y - tabHeight);

        if !self._layout.hasValue && self._tabs.len != 0 {
            self._layout = (alias self._tabs [0])?;
        }

        if let Ok (dmut w) = alias self._layout {
            let (sciPos, sciEnd) = self.getScissors (wpos, wsize);

            w.widget:.setSize (wpos, wsize, self._depth + 3);
            w.widget:.setScissors (sciPos, sciEnd);

            w.relPos = (wpos - self._absolutePosition) / self._absoluteSize;
            w.relSize = (wsize / self._absoluteSize);

            self._layout = (alias w)?;
        }


        let pixel = WidgetSize (pix-> self._currentStyle.getSubStyle ("tab").borderSize._1);
        let borderSize = makeVec2 (self.clampSize (pixel, self._absoluteSize.x) * self._absoluteSize.x,
                                   self.clampSize (pixel, self._absoluteSize.y) * self._absoluteSize.y);


        self._tabRelSize = makeVec2 (tabWidth / self._absoluteSize.x, tabHeight / self._absoluteSize.y);
        self._tabInnerRelSize = makeVec2 (tabWidth - borderSize.x, tabHeight - borderSize.y) / self._absoluteSize;
        self._borderRelSize = (borderSize / self._absoluteSize) / 2.f;
    }

    
    over onUpdateScissors (mut self) {
        if let Ok (dmut w) = alias self._layout {
            let wpos = w.relPos * self._absoluteSize + self._absolutePosition;
            let wsize = w.relSize * self._absoluteSize;

            let (sciPos, sciEnd) = self.getScissors (wpos, wsize);
            w.widget:.setScissors (sciPos, sciEnd);
        }
    }
    
    over onHide (mut self) {
        if let Ok (dmut w) = alias self._layout {
            w.widget:.hide ();
        }

        for dmut t in alias self._tabs {
            if let Ok (dmut s) = alias t.shape {
                s:.hide ();
            }

            if let Ok (dmut s) = alias t.label {
                s:.hide ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over getMaxDepth (self)-> u32 {
        let mut max = self._depth;
        if let Ok (w) = self._layout {
            let i = w.widget.getMaxDepth ();
            if max < i  { max = i; }
        }

        max + 3
    }

    pub over find (mut self, names : [[c8]])-> dmut (&Widget)? {
        if names.len == 0 { return none; }

        for dmut w in alias self._tabs {
            if w.widget.name == names [0] {
                if names.len == 1 { return (alias w.widget)?; }
                else return w.widget:.find (names [1 .. $]);
            }
        }

        none
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          TICK EVENTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the tick events to childrens
     * */
    pub over onTick (mut self, delta : Duration) {
        if let Ok (dmut w) = alias self._layout {
            w.widget:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onHover (mut self, pos : vec2)-> dmut (&Widget)? {
        if let Ok (index) = self.mouseOnTab (pos) {
            self._hoverIndex = index;
            self:.onApplyStyle ();

            if self._lastHoverLayout {
               if let Ok (dmut w) = alias self._layout {
                   w.widget:.onLoseHoverFocus ();
               }

                self._lastHoverLayout = false;
            }


            return (alias self)?;
        } else if let Ok ((dmut w, relPos)) = alias self:.mouseOnLayout (pos) {
            self._lastHoverLayout = true;

            if self._hoverIndex != self._tabs.len {
                self._hoverIndex = self._tabs.len;
                self:.onApplyStyle ();
            }

            return w:.onHover (relPos);
        }

        self:.onLoseHoverFocus ();

        none
    }

    pub over onLoseHoverFocus (mut self) {
        if self._lastHoverLayout {
            if let Ok (dmut w) = alias self._layout {
                w.widget:.onLoseHoverFocus ();
            }

            self._lastHoverLayout = false;
        }

        if self._hoverIndex != self._tabs.len {
            self._hoverIndex = self._tabs.len;
            self:.onApplyStyle ();
        }

    }

    pub over onClick (mut self, pos : vec2, button : u8)-> dmut (&Widget)? {
        if let Ok (index) = self.mouseOnTab (pos) {
            self:.selectTab (index);

            return (alias self)?;
        } else if let Ok ((dmut w, relPos)) = alias self:.mouseOnLayout (pos) {
            return w:.onClick (relPos, button);
        }

        none
    }

    pub over onDoubleClick (mut self, pos : vec2)-> dmut (&Widget)? {
        if let Ok (_) = self.mouseOnTab (pos) {
            return self:.onClick (pos, SDL_BUTTON_LEFT);
        } else if let Ok ((dmut w, relPos)) = alias self:.mouseOnLayout (pos) {
            return w:.onDoubleClick (relPos);
        }

        none
    }

    pub over onScroll (mut self, pos : vec2, amountX : i32, amountY : i32)-> bool {
        if let Ok ((dmut w, relPos)) = alias self:.mouseOnLayout (pos) {
            return w:.onScroll (relPos, amountX, amountY);
        }

        false
    }

    fn selectTab (mut self, index : usize) {
        if let Ok (dmut l) = alias self._layout {
            l.widget:.onDetach ();
        }

        let r = if index != self._tabs.len {
            index
        } else { 0 };

        self._layout = (alias self._tabs [r])?;
        self._selectedIndex = r;
        self._tabs [r].widget:.onAttach ();

        self._manager:.updateWidgets ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          STYLE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onApplyStyle (mut self) {
        let defaultStyle = self._manager:.getStyleManager ().get (self._widgetKind,
                                                                  self._styleClasses,
                                                                  false,
                                                                  false,
                                                                  false);

        let selectedStyle = self._manager:.getStyleManager ().get (self._widgetKind,
                                                                   self._styleClasses,
                                                                   false,
                                                                   true,
                                                                   false);

        let hoverStyle = self._manager:.getStyleManager ().get (self._widgetKind,
                                                                self._styleClasses,
                                                                true,
                                                                false,
                                                                false);

        let defaultTab = defaultStyle.getSubStyle ("tab");
        let hoverTab = hoverStyle.getSubStyle ("tab");
        let selectTab = selectedStyle.getSubStyle ("tab");

        let mut relPos = vec2 ();
        for i, dmut t in alias self._tabs {
            let spos = relPos * self._absoluteSize + self._absolutePosition;
            let ssize = self._tabRelSize * self._absoluteSize;
            let bsize = self._tabInnerRelSize * self._absoluteSize;
            let bpos = spos + (self._borderRelSize * self._absoluteSize);

            let (sciPos, sciEnd) = self.getScissors (spos, ssize);

            if let Ok (dmut sh) = alias t.shape {
                let (bsciPos, bsciEnd) = self.getScissors (bpos, bsize);

                sh:.setPosition (bpos);
                sh:.setSize (bsize);
                sh:.setScissors (bsciPos, bsciEnd);

                if i == self._selectedIndex {
                    sh:.setColor (selectTab.getColor (WidgetShapeKind::BACKGROUND));
                    sh:.setRadius (selectTab.getRadius (WidgetShapeKind::BACKGROUND));
                } else if i == self._hoverIndex {
                    sh:.setColor (hoverTab.getColor (WidgetShapeKind::BACKGROUND));
                    sh:.setRadius (hoverTab.getRadius (WidgetShapeKind::BACKGROUND));
                } else {
                    sh:.setColor (defaultTab.getColor (WidgetShapeKind::BACKGROUND));
                    sh:.setRadius (defaultTab.getRadius (WidgetShapeKind::BACKGROUND));
                }

                sh:.setLevel (self._depth + 1);
            }


            if let Ok (dmut sh) = alias t.border {
                sh:.setPosition (spos);
                sh:.setSize (ssize);
                sh:.setScissors (sciPos, sciEnd);

                if i == self._selectedIndex {
                    sh:.setColor (selectTab.getColor (WidgetShapeKind::BORDER));
                    sh:.setRadius (selectTab.getRadius (WidgetShapeKind::BORDER));
                } else if i == self._hoverIndex {
                    sh:.setColor (hoverTab.getColor (WidgetShapeKind::BORDER));
                    sh:.setRadius (hoverTab.getRadius (WidgetShapeKind::BORDER));
                } else {
                    sh:.setColor (defaultTab.getColor (WidgetShapeKind::BORDER));
                    sh:.setRadius (defaultTab.getRadius (WidgetShapeKind::BORDER));
                }

                sh:.setLevel (self._depth);
            }


            if let Ok (dmut lbl) = alias t.label {
                lbl:.setSize (spos, ssize, self._depth + 2);
                lbl:.setScissors (sciPos, sciEnd);

                if i == self._selectedIndex {
                    lbl:.setStyle (selectTab);
                } else if i == self._hoverIndex {
                    lbl:.setStyle (hoverTab);
                } else {
                    lbl:.setStyle (defaultTab);
                }
            }

            relPos.x += self._tabRelSize.x + (1.f / self._absoluteSize.x);
        }


        if let Ok (dmut w) = alias self._layout {
            w.widget:.onApplyStyle ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            for dmut i in alias self._tabs {
                i.widget:.dispose ();
                if let Ok (dmut l) = alias i.label {
                    l:.dispose ();
                    i.label = none;
                }

                if let Ok (dmut sh) = alias i.shape {
                    sh:.dispose ();
                    i.shape = none;
                }

                if let Ok (dmut sh) = alias i.border {
                    sh:.dispose ();
                    i.border = none;
                }
            }

            self._layout = none;
            self._super_:.dispose ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    fn mouseOnTab (self, pos : vec2)-> usize? {
        let mut relPos = vec2 ();
        if let Ok (inPaddingPos) = self.isInPadding (pos) {
            for i in 0 .. self._tabs.len {
                let a = relPos;
                let b = self._tabRelSize + a;

                if let Ok (_) = self.isInSquare (inPaddingPos, a, b) {
                    return (i)?;
                }

                relPos.x += self._tabRelSize.x;
            }
        }

        none
    }

    fn mouseOnLayout (mut self, pos : vec2)-> dmut (&Widget, vec2)? {
        if let Ok (inPaddingPos) = self.isInPadding (pos) {
            if let Ok (dmut w) = alias self._layout {
                if let Ok (relPos) = self.isInSquare (inPaddingPos, w.relPos, w.relSize) {
                    if let Ok (_) = w.widget.isInBorder (relPos) {
                        return (alias w.widget, relPos)?;
                    }
                }
            }
        }

        none
    }


}
