in linear;

use ::std::algorithm::comparison;

use std::io;

use balder::core::_;
use balder::math::_;
use balder::interface::_;
use balder::interface::widget::_;

pub class LinearLayout over Layout {

    // The columns of the layout
    let dmut _childs : [(WidgetSize, &Widget, vec2, vec2)] = [];

    // The border size
    let _border : WidgetSize;

    // The margin between the columns
    let _margin : WidgetSize;

    // If true widget are draw vertically, horizontally otherwise
    let _vertical : bool;

    // The size of the border relative to window size
    let mut _relBorderSize : f32 = 0.f;

    // The widget that was hovered the last (to send onHoverEnd)
    let dmut _lastHover : (&Widget)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8], margin : WidgetSize = WidgetSize (), border : WidgetSize = WidgetSize (), vertical : bool = true)
        with super (alias manager, name)
        , _margin = margin
        , _vertical = vertical
        , _lastHover = none
        , _border = border
    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the drawing size of the inner widgets
     */
    pub over onUpdateSizes (mut self, pos : vec2, viewport : vec2, depth : i32) {
        let m = self.clampSize (makeVec2 (self._margin.relative, self._margin.relative), self._margin, viewport);
        let b = self.clampSize (makeVec2 (self._border.relative, self._border.relative), self._border, viewport);

        let relMarginDrawSize = if (self._vertical) { m.x } else { m.y }
        let relBorderDrawSize = if (self._vertical) { b.y } else { b.x }
        self._relBorderSize = relBorderDrawSize;

        let mut current = 0.f;
        for col in 0 .. self._childs.len {
            let x = self._childs [col]._0.relative - relMarginDrawSize;
            let relColumnSize = self.clampSize (makeVec2 (max (0.f, x), max (0.f, x)),
                                                self._childs [col]._0,
                                                viewport);

            if self._vertical {
                let wpos =  makeVec2 ((current + relMarginDrawSize / 2.f), relBorderDrawSize / 2.f) * viewport + pos;
                let wsize = makeVec2 (relColumnSize.x, 1.f - relBorderDrawSize) * viewport;

                self._childs [col]._1:.updateSizes (wpos, wsize, depth + 1);
                self._childs [col]._2 = (wpos - self._absolutePosition) / self._absoluteSize;
                self._childs [col]._3 = wsize / self._absoluteSize;

                current  += relColumnSize.x + relMarginDrawSize;
            } else {
                let wpos =  makeVec2 (relBorderDrawSize / 2.f, (current + relMarginDrawSize / 2.f)) * viewport + pos;
                let wsize = makeVec2 (1.f - relBorderDrawSize, relColumnSize.y) * viewport;

                self._childs [col]._1:.updateSizes (wpos, wsize, depth + 1);
                self._childs [col]._2 = (wpos - self._absolutePosition) / self._absoluteSize;
                self._childs [col]._3 = wsize / self._absoluteSize;

                current  += relColumnSize.y + relMarginDrawSize;
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSERT CHILDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Insert a child in the layout
     * @warning: child is disposed when layout is disposed
     * */
    pub fn insertChild (mut self, size : WidgetSize, dmut ch : &Widget) {
        self._childs ~= [(size, alias ch, makeVec2 (0.f, 0.f), makeVec2 (0.f, 0.f))];
        self._manager:.updateWidgets ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the signal to the childs
     * @params:
     *   - pos: the relative position of the cursor within the layout
     */
    pub over onHover (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            if let Ok (dmut h) = alias self._lastHover && h !is c {
                h:.onHoverEnd ();
            }

            c:.onHover (v);
            self._lastHover = (alias c)?;
        } else {
            if let Ok (dmut h) = alias self._lastHover {
                h:.onHoverEnd ();
            }
        }
    }

    /**
     * Propagate the signal to the childs
     */
    pub over onHoverEnd (mut self) {
        if let Ok (dmut h) = alias self._lastHover {
            h:.onHoverEnd ();
            self._lastHover = none;
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClickLeft (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onClickLeft (v);
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClickLeftEnd (mut self, pos : vec2) {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onClickLeftEnd (v);
        }
    }

    /**
     * Propagate the event to the childrens
     */
    pub over onScroll (mut self, pos : vec2, amountX : i32, amountY : i32)-> bool {
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            return c:.onScroll (v, amountX, amountY);
        }

        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            for dmut c in alias self._childs {
                c._1:.dispose ();
            }

            if let Ok (dmut sh) = alias self._shape {
                sh:.dispose ();
                self._shape = none;
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns:
     *  - .1 : the index of the widget on which the mouse is positionned
     *  - .2 : the position of the mouse relative to the widget
     */
    fn mouseToWidget (mut self, pos : vec2)-> dmut (&Widget, vec2)? {
        for i in 0 .. self._childs.len {
            let a = self._childs [i]._2;
            let b = a + self._childs [i]._3;

            if self._vertical {
                if (pos.x >= a.x && pos.x <= b.x && pos.y >= (self._relBorderSize / 2.f) && pos.y <= (1.f - self._relBorderSize / 2.f)) {
                    let relPos = makeVec2 ((pos.x - a.x) / (b.x - a.x),
                                           (pos.y - self._relBorderSize / 2.f) / (1.0f - self._relBorderSize));

                    return (alias self._childs [i]._1, relPos)?;
                }
            } else {
                if (pos.y >= a.y && pos.y <= b.y && pos.x >= (self._relBorderSize / 2.f) && pos.x <= (1.f - self._relBorderSize / 2.f)) {
                    let relPos = makeVec2 ((pos.x - self._relBorderSize / 2.f) / (1.0f - self._relBorderSize),
                                           (pos.y - a.y) / (b.y - a.y));

                    return (alias self._childs [i]._1, relPos)?;
                }
            }
        }

        return none;
    }

}
