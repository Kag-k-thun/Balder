in linear;

use ::std::algorithm::comparison;

use std::{io, time::_, fs::path};

use balder::utils::_;
use balder::core::_;
use balder::math::_;
use balder::interface::_;
use balder::interface::widget::_;

use balder::interface::widget::layout::menu;

record Child {
    pub let dmut widget : &Widget;
    pub let dmut relPos : vec2;
    pub let dmut relSize : vec2;
    pub let dmut level : u32;
    pub let dmut size : WidgetSize;

    pub self (dmut widget : &Widget, relPos : vec2, relSize : vec2, level : u32, size : WidgetSize)
        with widget = alias widget
        , relPos = relPos
        , relSize = relSize
        , level = level
        , size = size
    {}
}


pub class LinearLayout over Layout {

    // The columns of the layout
    let dmut _childs : [Child] = [];

    // If true widget are draw vertically, horizontally otherwise
    let _vertical : bool;

    // The current shifting (wheel)
    let mut _shift : f32 = 0.f;

    // The relative size of the widget (may be greater than 1 if containes too much widgets to fit on screenÂ°)
    let mut _relFullSize : f32 = 0.f;

    // The widget that was hovered the last (to send onHoverEnd)
    let dmut _lastHover : (&Widget)? = none;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8], vertical : bool = true)
        with super (alias manager, name, WidgetKeys::LINEAR_LAYOUT)
        , _vertical = vertical
        , _lastHover = none

    {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self, parentPath : Path) {
        self.__super__:.onAttach (parentPath);

        for dmut i in alias self._childs {
            i.widget:.onAttach (self._path);
        }
    }

    pub over setMenuContext (mut self, dmut menu : &MenuLayout) {
        self._menuContext = (alias menu)?;
        for dmut i in alias self._childs {
            i.widget:.setMenuContext (alias menu);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Compute the drawing size of the inner widgets
     */
    over onUpdateSize (mut self) {
        if self._childs.len == 0 {
            return;
        }

        let mut current = 0.f;
        for col in 0 .. self._childs.len {
            let (wpos, wsize) = if self._vertical {
                let relColumnSize = self.clampSize (self._childs [col].size, self._absoluteSize.x);
                let wpos = makeVec2 (current + self._shift, 0.f) * self._absoluteSize + self._absolutePosition;
                let wsize = makeVec2 (relColumnSize, 1.f) * self._absoluteSize;
                self._relFullSize = current + relColumnSize;

                current  += relColumnSize;

                (wpos, wsize)
            } else {
                let relColumnSize = self.clampSize (self._childs [col].size, self._absoluteSize.y);
                let wpos =  makeVec2 (0.f, current + self._shift) * self._absoluteSize + self._absolutePosition;
                let wsize = makeVec2 (1.f, relColumnSize) * self._absoluteSize;
                self._relFullSize = current + relColumnSize;

                current  += relColumnSize;

                (wpos, wsize)
            };

            self._childs [col].widget:.setSize (wpos, wsize, self._depth + 1);
            let (sciPos, sciEnd) = self.getScissors (wpos, wsize);

            self._childs [col].widget:.setScissors (sciPos, sciEnd);

            self._childs [col].relPos = (wpos - self._absolutePosition) / self._absoluteSize;
            self._childs [col].relSize = wsize / self._absoluteSize;
        }
    }

    over onUpdateScissors (mut self) {
        for dmut i in alias self._childs {
            let wpos = (i.relPos * self._absoluteSize) + self._absolutePosition;
            let wsize = (i.relSize * self._absoluteSize);
            let (sciPos, sciEnd) = self.getScissors (wpos, wsize);

            i.widget:.setScissors (sciPos, sciEnd);
        }
    }

    over onHide (mut self) {
        for dmut i in alias self._childs {
            i.widget:.hide ();
        }
    }

    over onShow (mut self) {
        for dmut i in alias self._childs {
            i.widget:.show ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INSERT CHILDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Insert a child in the layout
     * @warning: child is disposed when layout is disposed
     * */
    pub fn insertChild (mut self, dmut ch : &Widget, level : u32 = 0) {
        let size = if self._vertical {
            ch.getStyle ().getWidth ()
        } else {
            ch.getStyle ().getHeight ()
        };

        self._childs ~= [Child (alias ch, makeVec2 (0.f, 0.f), makeVec2 (0.f, 0.f), level, size)];
        std::algorithm::sorting::sort (alias self._childs, |x, y| => { x.level < y.level });

        self._manager:.updateWidgets ();
    }

    /**
     * @returns: the number of childs in the layout
     * */
    pub fn getNbChilds (self)-> u32 {
        cast!u32 (self._childs.len)
    }

    /**
     * @returns: the size of a given child in the layout
     * @params:
     *   - index: the index of the child
     * */
    pub fn getChildSize (self, index : u32)-> WidgetSize {
        self._childs [index].size
    }

    /**
     * @returns: the size of a given child in the layout
     * @params:
     *   - index: the index of the child
     * */
    pub fn getChild (self, index : u32)-> &Widget {
        self._childs [index].widget
    }

    /**
     * Set the size of a given child in the layout
     * @params:
     *   - index: the index of the child
     *   - size: the size to set
     * */
    pub fn setChildSize (mut self, index : u32, size : WidgetSize) {
        self._childs [index].size = size;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SET/GET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Make the layout scroll up/down
     * */
    pub fn setShift (mut self, scroll : f32) {
        let oldShift = self._shift;

        for col in 0 .. self._childs.len {
            let mut wpos = self._childs [col].relPos; // * self._absoluteSize + self._absolutePosition;
            let wsize = self._childs [col].relSize * self._absoluteSize;

            if self._vertical {
                wpos = makeVec2 (wpos.x - oldShift + scroll, wpos.y);
            } else {
                wpos = makeVec2 (wpos.x, wpos.y - oldShift + scroll);
            }

            self._childs [col].relPos = wpos;
            self._childs [col].widget:.setSize (wpos * self._absoluteSize + self._absolutePosition, wsize, self._depth + 1);
        }

        self._shift = scroll;
        self:.onUpdateScissors ();
    }

    /**
     * The current shifting of the layout
     * */
    @field
    pub fn shift (self)-> f32 {
        self._shift
    }

    /**
     * @returns: true iif the widgets in the layout are rendered left to right (up to bottom otherwise)
     * */
    pub fn isVertical (self)-> bool {
        self._vertical
    }

    pub over getMaxDepth (self)-> u32 {
        let mut max = self._depth;
        for i in self._childs {
            let chD = i.widget.getMaxDepth ();
            if chD > max { max = chD; }
        }

        max
    }

    /**
     * @returns: the full length of the layout relative to the window, (i.e. width if vertical, height otherwise)
     * @info: this can be greater than 1, depending on the size of inner elements
     * */
    pub fn getFullLength (self)-> f32 {
        self._relFullSize
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          TICK EVENTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the tick events to childrens
     * */
    pub over onTick (mut self, delta : Duration) {
        for dmut c in alias self._childs {
            c.widget:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over find (mut self, names : [[c8]])-> dmut (&Widget)? {
        if names.len == 0 { return none; }

        for dmut c in alias self._childs {
            if c.widget.name == names [0] {
                if names.len == 1 { return (alias c.widget)?; }
                else return c.widget:.find (names [1 .. $]);
            }
        }

        none
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the signal to the childs
     * @params:
     *   - pos: the relative position of the cursor within the layout
     */
    pub over onHover (mut self, pos : vec2)-> dmut (&Widget)? {
        let mut canBeSelf = true;
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos, ref canBeSelf) {
            if let Ok (dmut w) = alias self._lastHover && c !is w {
                w:.onLoseHoverFocus ();
            }

            self._lastHover = (alias c)?;
            return c:.onHover (v);
        }

        if let Ok (dmut w) = alias self._lastHover {
            w:.onLoseHoverFocus ();
            self._lastHover = none;
        }

        if canBeSelf {
            self:.setHover (true);
            (alias self)?
        } else {
            none
        }
    }

    pub over onLoseHoverFocus (mut self) {
        if let Ok (dmut c) = alias self._lastHover {
            c:.onLoseHoverFocus ();
            self._lastHover = none;
        }

        self:.setHover (false);
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onClick (mut self, pos : vec2, button : u8)-> dmut (&Widget)? {
        let mut canBeSelf = true;
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos, ref canBeSelf) {
            return c:.onClick (v, button);
        }

        if canBeSelf {
            (alias self)?
        } else {
            none
        }
    }

    /**
     * Propagate the signal to the childrens
     */
    pub over onDoubleClick (mut self, pos : vec2)-> dmut (&Widget)? {
        let mut canBeSelf = true;
        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos, ref canBeSelf) {
            return c:.onDoubleClick (v);
        }

        if canBeSelf {
            (alias self)?
        } else {
            none
        }
    }

    /**
     * Propagate the scrolling signal to children
     * */
    pub over onScroll (mut self, pos : vec2, amountX : i32, amountY : i32)-> bool {
        let mut ignore = true;
        let res = if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos, ref ignore) {
            c:.onScroll (v, amountX, amountY)
        } else { false };

        self:.onHover (pos);
        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        pub over dispose (mut self) {
            self._attached = false;

            for dmut c in alias self._childs {
                c.widget:.dispose ();
            }

            self._super_:.dispose ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns:
     *  - .1 : the widget on which the mouse is positionned
     *  - .2 : the position of the mouse relative to the widget
     */
    fn mouseToWidget (mut self, pos : vec2, ref mut canBeSelf : bool)-> dmut (&Widget, vec2)? {
        canBeSelf = true;

        let inPaddingPos = {
            let a = (self._absolutePosition - self._absoluteFullPosition) / self._absoluteFullSize;
            let b = (self._absoluteSize / self._absoluteFullSize);

            (pos - a) / b
        };

        for i in 0 .. self._childs.len {
            let a = self._childs [i].relPos;
            let b = a + self._childs [i].relSize;

            if let Ok (relPos) = self.isInSquare (inPaddingPos, a, b) {
                canBeSelf = false;
                if let Ok (_) = self._childs [i].widget.isInBorder (relPos) {
                    return (alias self._childs [i].widget, relPos)?
                }
            }
        }

        none
    }

}
