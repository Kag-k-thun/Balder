in d3scene;



use ::std::fs::path;

use balder::core::{shader::_, application::_};
use balder::core::_;
use balder::math::_;

use balder::interface::_;
use balder::utils::_;

use balder::{scene, scene::_};
use ::std::time::_;

/**
 * A widget containing and displaying a 3D scene
 * */
pub class Scene3DLayout over Widget {

    // The scene to render
    let dmut _scene : (&Scene)? = none;

    // The width of the scene
    let mut _w : u32 = 0;

    // The height of the scene
    let mut _h : u32 = 0;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager, name : [c8], width : u32, height : u32)
        with super (alias manager, name, WidgetKeys::SCENE_3D)
        , _w = width
        , _h = height
    {
        self._hasBackground = false;
        self._hasBorder = false;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self, parentPath : Path) {
        self.__super__:.onAttach (parentPath);

        {
            let dmut scene = copy Scene (self._manager:.getWindow (), self.name, self._w, self._h);
            scene:.setDimension (self._w, self._h);
            self._scene = (alias scene)?;

            if let Ok (dmut text) = alias scene:.getOutputTexture () {
                self:.registerTextureShape (WidgetShapeKind::IMAGE, alias text);
            }

            self:.registerColorShape (WidgetShapeKind::BACKGROUND);
        } catch {
            err => {
                log::error #("Scene3DLayout", "Failed to create scene", err);
            }
        }
    }

    over computeBackgroundImageSize (self)-> (vec2, vec2) {
        let test = self._absolutePostBorderSize.x < self._absolutePostBorderSize.y;
        let (pos, size) = if test {
            let xsize = self._absolutePostBorderSize.y;
            let xpos = self._absolutePostBorderPosition.x + (self._absolutePostBorderSize.x - xsize) / 2.f;

            (makeVec2 (xpos, self._absolutePostBorderPosition.y), makeVec2 (xsize, self._absolutePostBorderSize.y))
        } else {
            let ysize = self._absolutePostBorderSize.x;
            let ypos = self._absolutePostBorderPosition.y + (self._absolutePostBorderSize.y - ysize) / 2.f;

            (makeVec2 (self._absolutePostBorderPosition.x, ypos), makeVec2 (self._absolutePostBorderSize.x, ysize))
        }

        (pos, size)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        if let Ok (dmut scene) = alias self._scene {
            scene:.setAspect (cast!u32 (self._absoluteSize.x), cast!u32 (self._absoluteSize.y));
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          TICK EVENTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Event emitted by the application at each UI frameo
     * */
    pub over onTick (mut self, delta : Duration) {
        if let Ok (dmut scene) = alias self._scene {
            scene:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the scene displayed by the widget
     * */
    pub fn getScene (mut self)-> dmut (&Scene)? {
        alias self._scene
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self.__super__:.dispose ();

            if let Ok (dmut sc) = alias self._scene {
                sc:.dispose ();
                self._scene = none;
            }
        }
    }

}
