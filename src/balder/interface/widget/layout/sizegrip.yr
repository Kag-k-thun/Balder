in sizegrip;

use ::std::algorithm::comparison;

use std::{io, time::_};

use balder::utils::_;
use balder::core::{_, application::_};
use balder::core::shader::_;
use balder::math::_;

use balder::interface::_;
use balder::interface::widget::_;
use balder::interface::widget::layout::linear;

use ::sdl2::mouse;
use ::sdl2::events;


record Child {
    pub let dmut widget : &Widget;
    pub let dmut relPos : vec2;
    pub let dmut relSize : vec2;
    pub let dmut level : u32;
    pub let dmut size : WidgetSize;

    pub self (dmut widget : &Widget, relPos : vec2 = vec2 (), relSize : vec2 = vec2 (), level : u32 = 0, size : WidgetSize = WidgetSize (relative-> 0.5))
        with widget = alias widget
        , relPos = relPos
        , relSize = relSize
        , level = level
        , size = size
    {}
}

pub class SizeGripLayout over Widget {

    let dmut _childs : [Child ; 2];

    let mut _vertical : bool;


    prot { // Shapes

        // The shape displaying the grip
        let dmut _sizeGripShape : (&Shape)? = none;

        // The relative size of the grip
        let dmut _relGripSize : vec2 = vec2 ();

        // The relative position of the grip
        let dmut _relGripPos : vec2 = vec2 ();

        // The relative position of the bounding box of the grip (larger than displayed size)
        let dmut _relGripBoxPos : vec2 = vec2 ();

        // The relative size of the bounding box of the grip (larger than displayed size)
        let dmut _relGripBoxSize : vec2 = vec2 ();

    }

    prot { // grip background image

        // The background image of the grip shape
        let dmut _sizeGripImageShape : (&Shape)? = none;

        // The background image of the grip shape
        let mut _currentGripImage : [c8] = "";

        // The texture of the grip
        let dmut _gripTexture : &RefCount!{&Texture2D};

        // The size of the texture in pixels
        let dmut _gripTextureSize : uvec2 = uvec2 ();

    }

    prot {

        // The size of the left widget from the grip
        let dmut _default : [(WidgetSize, vec2) ; 2] = [(WidgetSize (), vec2 ()) ; 2];

        // The mouse position start when sliding event starts in pixels
        let mut _slideStart : vec2 = vec2 ();

    }

    prot { // mouse events

        // The widget that was hovered the last (to send onHoverEnd)
        let dmut _lastHover : (&Widget)? = none;

        // Set to true iif the cursor if over the grip
        let mut _lastHoverGrip : bool = false;

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */


    pub self (dmut manager : &WidgetManager, name : [c8], dmut left : &Widget, dmut right : &Widget, vertical : bool)
        with super (alias manager, name, WidgetKeys::SIZE_GRIP)
        , _childs = [Child (alias left), Child (alias right)]
        , _vertical = vertical
        , _gripTexture = manager:.getWindow ():.emptyResource!{&Texture2D} ()
    {
        if self._vertical && left.getStyle ().hasWidth () {
            self._childs [0].size = left.getStyle ().getWidth ();
        }

        if !self._vertical && left.getStyle ().hasHeight () {
            self._childs [0].size = left.getStyle ().getHeight ();
        }

        if self._vertical && right.getStyle ().hasWidth () {
            self._childs [1].size = right.getStyle ().getWidth ();
        }

        if !self._vertical && right.getStyle ().hasHeight () {
            self._childs [1].size = right.getStyle ().getHeight ();
        }

        // Normalization of the sizes to keep the sum = 1
        let mut relL = self._childs [0].size.relative;
        let mut relR = self._childs [1].size.relative;

        relL = clamp (relL, 0.01f, 0.99f);
        relR = clamp (relR, 0.01f, 0.99f);

        self._childs [0].size = WidgetSize (relative-> relL / (relL + relR));
        self._childs [1].size = WidgetSize (relative-> 1.f - (relL / (relL + relR)));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self) {
        self._attached = true;
        self._childs [0].widget:.onAttach ();
        self._childs [1].widget:.onAttach ();

        let dmut shDr = self._manager:.getShapeDrawer ();
        {
            let dmut shape = shDr:.registerColorQuad ();
            shape:.setRadius (self.getStyle ().getSubStyle ("grip").radius._1);

            self._sizeGripShape = (alias shape)?;
        } catch {
            err => {
                log::error #("SizeGrip", "Failed to construct shapes : ", err);
            }
        }
    }

    pub over onDetach (mut self) {
        self._attached = false;
        self._childs [0].widget:.onDetach ();
        self._childs [1].widget:.onDetach ();

        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZE          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        let mut current = 0.f;

        let gripStyle = self.getStyle ().getSubStyle ("grip");
        let gripBoxStyle = self.getStyle ().getSubStyle ("bbox");

        let (maxS, gripSize, gripBoxSize) = if self._vertical {
            (self._absoluteSize.x, gripStyle.getWidth (), gripBoxStyle.getWidth ())
        } else {
            (self._absoluteSize.y, gripStyle.getHeight (), gripBoxStyle.getHeight ())
        };

        self._relGripSize = if self._vertical { makeVec2 (self.clampSize (gripSize, maxS), 1.f) } else { makeVec2 (1.f, self.clampSize (gripSize, maxS)) };
        self._relGripBoxSize = if self._vertical { makeVec2 (self.clampSize (gripBoxSize, maxS), 1.f) } else { makeVec2 (1.f, self.clampSize (gripBoxSize, maxS)) };

        for i in 0 .. self._childs.len {
            let (wpos, wsize) = if self._vertical {
                let relColumnSize = self.clampSize (self._childs [i].size, self._absoluteSize.x) - (self._relGripSize.x / 2.f);
                let wpos = makeVec2 (current, 0.f) * self._absoluteSize + self._absolutePosition;
                let wsize = makeVec2 (relColumnSize, 1.f) * self._absoluteSize;

                current  += relColumnSize + self._relGripSize.x;
                (wpos, wsize)
            } else {
                let relColumnSize = self.clampSize (self._childs [i].size, self._absoluteSize.y) - (self._relGripSize.y / 2.f);
                let wpos =  makeVec2 (0.f, current) * self._absoluteSize + self._absolutePosition;
                let wsize = makeVec2 (1.f, relColumnSize) * self._absoluteSize;

                current  += relColumnSize + self._relGripSize.y;
                (wpos, wsize)
            };

            self._childs [i].widget:.setSize (wpos, wsize, self._depth + 1);
            let (sciPos, sciEnd) = self.getScissors (wpos, wsize);

            self._childs [i].widget:.setScissors (sciPos, sciEnd - sciPos);

            self._childs [i].relPos = (wpos - self._absolutePosition) / self._absoluteSize;
            self._childs [i].relSize = wsize / self._absoluteSize;
        }

        let shift = if self._vertical {
            (makeVec2 (self._childs [0].relSize.x, 0.f),
             makeVec2 (self._childs [0].relSize.x - (self._relGripBoxSize.x/2.f) + (self._relGripSize.x/2.f), 0.f))
        } else {
            (makeVec2 (0.f, self._childs [0].relSize.y),
             makeVec2 (0.f, self._childs [0].relSize.y - (self._relGripBoxSize.y/2.f) + (self._relGripSize.y/2.f)))
        };


        self._relGripPos = self._childs [0].relPos + shift._0;
        self._relGripBoxPos = self._childs [0].relPos + shift._1;
    }

    over onUpdateScissors (mut self) {
        for dmut i in alias self._childs {
            let wpos = (i.relPos * self._absoluteSize) + self._absolutePosition;
            let wsize = (i.relSize * self._absoluteSize);
            let (sciPos, sciEnd) = self.getScissors (wpos, wsize);

            i.widget:.setScissors (sciPos, sciEnd);
        }

        let wpos = self._relGripPos * self._absoluteSize + self._absolutePosition;
        let wsize = self._relGripSize * self._absoluteSize;
        let (sciPos, sciEnd) = self.getScissors (wpos, wsize);

        if let Ok (dmut s) = alias self._sizeGripShape {
            s:.setScissors (sciPos, sciEnd);
        }

        if let Ok (dmut s) = alias self._sizeGripImageShape {
            s:.setScissors (sciPos, sciEnd);
        }
    }

    over onHide (mut self) {
        for dmut i in alias self._childs {
            i.widget:.hide ();
        }

        if let Ok (dmut s) = alias self._sizeGripShape {
            s:.hide ();
        }

        if let Ok (dmut s) = alias self._sizeGripImageShape {
            s:.hide ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over getMaxDepth (self)-> u32 {
        let mut max = self._depth;
        for i in self._childs {
            let chD = i.widget.getMaxDepth ();
            if chD > max { max = chD; }
        }

        max + 2 // back color + back image
    }

    /**
     * @returns: true iif the widgets in the layout are rendered left to right (up to bottom otherwise)
     * */
    pub fn isVertical (self)-> bool {
        self._vertical
    }

    pub over find (mut self, names : [[c8]])-> dmut (&Widget)? {
        if names.len == 0 { return none; }

        for dmut c in alias self._childs {
            if c.widget.name == names [0] {
                if names.len == 1 { return (alias c.widget)?; }
                else return c.widget:.find (names [1 .. $]);
            }
        }

        none
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          TICK EVENTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Propagate the tick events to childrens
     * */
    pub over onTick (mut self, delta : Duration) {
        for dmut c in alias self._childs {
            c.widget:.onTick (delta);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onHover (mut self, pos : vec2)-> dmut (&Widget)? {
        if self.mouseOnGrip (pos) {
            if let Ok (dmut w) = alias self._lastHover {
                w:.onLoseHoverFocus ();
                self._lastHover = none;
            }

            self:.setHover (true);
            if self._vertical {
                self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_SIZEWE);
            } else {
                self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_SIZENS);
            }

            return (alias self)?;
        }

        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_ARROW);
        self:.setHover (false);

        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            if let Ok (dmut w) = alias self._lastHover && c !is w {
                w:.onLoseHoverFocus ();
            }

            self._lastHover = (alias c)?;
            return c:.onHover (v);
        }

        if let Ok (dmut w) = alias self._lastHover {
            w:.onLoseHoverFocus ();
            self._lastHover = none;
        }

        none
    }

    pub over onLoseHoverFocus (mut self) {
        if let Ok (dmut w) = alias self._lastHover {
            w:.onLoseHoverFocus ();
            self._lastHover = none;
        }

        self._lastHoverGrip = false;
        self:.setHover (false);
        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_ARROW)
    }

    pub over onClick (mut self, pos : vec2, button : u8)-> dmut (&Widget)? {
        if self.mouseOnGrip (pos) {
            self._slideStart = self._manager.getMousePosition ();
            self._default [0] = (self._childs [0].size, self._childs [0].relSize * self._absoluteSize);
            self._default [1] = (self._childs [1].size, self._childs [1].relSize * self._absoluteSize);

            return (alias self)?;
        }

        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            return c:.onClick (v, button);
        }

        none
    }

    pub over onDoubleClick (mut self, pos : vec2)-> dmut (&Widget)? {
        if self.mouseOnGrip (pos) {
            return self:.onClick (pos, SDL_BUTTON_LEFT);
        }

        if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            return c:.onDoubleClick (v);
        }

        none
    }

    pub over onScroll (mut self, pos : vec2, amountX : i32, amountY : i32)-> bool {
        let res = if let Ok ((dmut c, v)) = alias self:.mouseToWidget (pos) {
            c:.onScroll (v, amountX, amountY)
        } else { false };

        self:.onHover (pos);
        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          SLIDING EVENT          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onSliding (mut self, _pos_ : vec2, _speed_ : vec2, _ : u8) {
        let pos = self._manager.getMousePosition ();
        let nbPixels = pos - self._slideStart;

        if self._vertical {
            let rel = cast!f32 (nbPixels.x)  / self._absoluteSize.x;
            self._childs [0].size.relative = self._default [0]._0.relative + rel;
            self._childs [1].size.relative = self._default [1]._0.relative - rel;
        } else {
            let rel = cast!f32 (nbPixels.y)  / self._absoluteSize.y;
            self._childs [0].size.relative = self._default [0]._0.relative + rel;
            self._childs [1].size.relative = self._default [1]._0.relative - rel;
        }

        for i in 0 .. self._childs.len {
            if self._childs [i].size.relative < 0.01 { self._childs [i].size.relative = 0.01; }
            else if self._childs [i].size.relative > 0.99 { self._childs [i].size.relative = 0.99; }
        }

        self._manager:.updateWidgets ();
    }

    pub over onGainFocus (mut self) {
        if self._vertical {
            self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_SIZEWE);
        } else {
            self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_SIZENS);
        }
    }

    pub over onLoseFocus (mut self) {
        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_ARROW);
        self:.onLoseHoverFocus ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          STYLE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onApplyStyle (mut self) {
        let gripStyle = self.getStyle ().getSubStyle ("grip");

        self:.loadGripBackTexture (gripStyle);
        if let Ok (dmut ws) = alias self._sizeGripShape {
            ws:.setPosition (self._relGripPos * self._absoluteSize + self._absolutePosition);
            ws:.setSize (self._relGripSize * self._absoluteSize);
            ws:.setColor (gripStyle.getColor (WidgetShapeKind::BACKGROUND));
            ws:.setRadius (gripStyle.getRadius (WidgetShapeKind::BACKGROUND));

            ws:.setLevel (self.getMaxDepth () - 1);
            ws:.show ();
        }

        if let Ok (dmut ws) = alias self._sizeGripImageShape {
            let (pos, size) = self.computeGripTextureSize (gripStyle);

            ws:.setPosition (pos);
            ws:.setSize (size);

            ws:.setLevel (self.getMaxDepth ());
            ws:.setColor (gripStyle.getColor (WidgetShapeKind::IMAGE));
            ws:.setRadius (gripStyle.getRadius (WidgetShapeKind::IMAGE));
            ws:.show ();
        }
    }

    fn computeGripTextureSize (self, gripStyle : &Style)-> (vec2, vec2) {
        let absPos = self._relGripPos * self._absoluteSize + self._absolutePosition;
        let absSize = self._relGripSize * self._absoluteSize;

        if gripStyle.backgroundImageKeepRatio._1 {
            let test = if gripStyle.backgroundImageFill._1 {
                absSize.x < absSize.y
            } else {
                absSize.x > absSize.y
            };

            let (pos, size) = if test {
                let xsize = absSize.y;
                let xpos = absPos.x + (absSize.x - xsize) / 2.f;

                (makeVec2 (xpos, absPos.y), makeVec2 (xsize, absSize.y))
            } else {
                let ysize = absSize.x;
                let ypos = absPos.y + (absSize.y - ysize) / 2.f;

                (makeVec2 (absPos.x, ypos), makeVec2 (absSize.x, ysize))
            }

            (pos, size)
        } else {
            (absPos, absSize)
        }
    }

    /**
     * Load the image shape for the grip slider
     * */
    fn loadGripBackTexture (mut self, gripStyle : &Style) {
        if self._currentGripImage != gripStyle.backgroundImage._1 {
            self._currentGripImage = gripStyle.backgroundImage._1;

            let dmut shDr = self._manager:.getShapeDrawer ();
            if let Ok (dmut ws) = alias self._sizeGripImageShape {
                shDr:.removeShape (ws.uid);
                self._sizeGripImageShape = none;
            }

            self._gripTexture:.dispose ();
            if self._currentGripImage != "" {
                {
                    self._gripTexture = self._manager:.getWindow ():.loadResource!{&Texture2D} (self._currentGripImage);
                } catch {
                    err => {
                        log::error #("SizeGrip", "Failed to load background image", err);
                        return;
                    }
                }

                if !self._gripTexture.isEmpty () {
                    {
                        println ("New texture shape");
                        let dmut newShape = shDr:.registerTextureQuad (texture-> self._gripTexture:.clone ());
                        self._sizeGripImageShape = (alias newShape)?;
                        self._gripTextureSize = makeVec2 (self._gripTexture.get ().width, self._gripTexture.get ().height);
                    } catch {
                        err => {
                            log::error #("SizeGrip", "Failed to create texture background image shape  => ", err);
                            return;
                        }
                    }
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SET          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over isFocusableLeftClick (self)-> bool {
        true
    }

    pub over loseFocusOnReleaseLeft (self)-> bool {
        true
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut s) = alias self._sizeGripShape {
                let dmut shDr = self._manager:.getShapeDrawer ();
                shDr:.removeShape (s.uid);
                self._sizeGripShape = none;
            }

            if let Ok (dmut s) = alias self._sizeGripImageShape {
                let dmut shDr = self._manager:.getShapeDrawer ();
                shDr:.removeShape (s.uid);
                self._sizeGripImageShape = none;
            }

            self._gripTexture:.dispose ();
            self._currentGripImage = "";

            for dmut i in alias self._childs {
                i.widget:.dispose ();
            }

            self._super_:.dispose ();
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          MOUSE BBOX          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: true if the mouse is over the size grip
     * */
    fn mouseOnGrip (self, pos : vec2)-> bool {
        if let Ok (relPos) = self.isInPadding (pos) {
            println (pos, " ", relPos, " ", self._relGripBoxPos, " ", self._relGripPos);

            if let Ok (_) = self.isInSquare (relPos, self._relGripBoxPos, self._relGripBoxPos + self._relGripBoxSize) {
                return true;
            }
        }

        false
    }

    /**
     * @returns:
     *  - .1 : the widget on which the mouse is positionned
     *  - .2 : the position of the mouse relative to the widget
     */
    fn mouseToWidget (mut self, pos : vec2)-> dmut (&Widget, vec2)? {
        if let Ok (inPaddingPos) = self.isInPadding (pos) {
            for i in 0 .. self._childs.len {
                let a = self._childs [i].relPos;
                let b = a + self._childs [i].relSize;

                if let Ok (relPos) = self.isInSquare (inPaddingPos, a, b) {
                    if let Ok (_) = self._childs [i].widget.isInBorder (relPos) {
                        return (alias self._childs [i].widget, relPos)?
                    }
                }
            }
        }

        none
    }

}
