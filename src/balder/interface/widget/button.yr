in button;

pub mod ::push;
pub mod ::menu;

use balder::core::application::_;
use balder::{core::_, math::_};

use balder::interface::_;
use balder::utils::_;
use balder::interface::widget::text::label;

use ::std::algorithm::_;
use ::std::fs::path;

/**
 * Ancestor class of all button elements
 * */
@abstract
pub class Button over Widget {

    let dmut _label : &Label;

    pub self (dmut manager : &WidgetManager, name : [c8], kind : [c8])
        with super (alias manager, name, kind)
        , _label  = copy Label (alias manager, "")
    {}


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn setText (mut self, text : [c8]) {
        self._label:.setText (text);
        self:.computeSize ();
    }

    prot over onApplyStyle (mut self) {
        if let Ok (inner) = self.getStyle ().subItems ["label"] {
            self._label:.setStyle (inner);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          SIZE COMPUTATION          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        self._label:.setSize (self._absolutePosition, self._absoluteSize, self._depth + 1);
        self:.onUpdateScissors ();
    }

    over onUpdateScissors (mut self) {
        let x = max (self._absolutePosition.x, self._scissorPos.x);
        let endx = min (self._absolutePosition.x + self._absoluteSize.x,
                        self._scissorPos.x + self._scissorSize.x);

        let y = max (self._absolutePosition.y, self._scissorPos.y);
        let endy = min (self._absolutePosition.y + self._absoluteSize.y, self._scissorPos.y + self._scissorSize.y);

        self._label:.setScissors (makeVec2 (x, y),
                                  makeVec2 (endx - x, endy - y));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self, parentPath : Path) {
        self.__super__:.onAttach (parentPath);
        self._label:.onAttach (self._path);
    }

    over onHide (mut self) {
        self._label:.hide ();
    }

    over onShow (mut self) {
        self._label:.show ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENT          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onHover (mut self, _ : vec2)-> dmut (&Widget)? {
        self:.setHover (true);
        (alias self)?
    }

    pub over onLoseHoverFocus (mut self) {
        self:.setHover (false);
    }

    pub over onClick (mut self, _ : vec2, _ : u8)-> dmut (&Widget)? {
        self:.setChecked (true);
        (alias self)?
    }

    pub over onClickEnd (mut self, _ : u8)-> dmut (&Widget)? {
        self:.setChecked (false);
        (alias self)?
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._attached = false;

            self._label:.dispose ();
            self.__super__:.dispose ();
        }
    }

}
