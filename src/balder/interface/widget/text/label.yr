in label;

use balder::core::{shader::_,
                   application::_};

use balder::core::_;
use balder::math::_;

use balder::interface::{_, widget::alignement};

use balder::interface::shape::_;
use balder::utils::_;

use std::io;
use std::algorithm::comparison;

pub class Label over Widget {

    // The text displayed by the label
    let mut _text : [c16];

    prot {  // Display configuration

        let mut _forceAlign : bool = false;

        let mut _relTextSize : vec2 = vec2 ();

        let mut _relTextPos : vec2 = vec2 ();

        let mut _relFontSize : u32 = 0u32;
        let mut _relFont : [c8] = [];
    }

    prot {

        // The texture of the shape
        let dmut _texture : (&RefCount!{&Texture2D})? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (dmut manager : &WidgetManager,
              name : [c8])

        with super (alias manager, name, WidgetKeys::LABEL)
        , _text = ""
    {
        self._hasBackground = false;
        self._hasBorder = false;
    }

    over onApplyStyle (mut self) {
        if self._relFont != self.getFont () || self._relFontSize != self.getFontSize () {
            if self._attached && self._text != "" {
                self:.setText (self._text);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self) {
        self._attached = true;
        self:.setText (self._text);
    }

    pub over onDetach (mut self) {
        self._attached = false;
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        if let Ok (d) = self._texture {
            let txt = d.get ();
            let relSize = makeVec2 (cast!f32 (txt.width), cast!f32 (txt.height)) / self._absoluteSize;

            let xalign = if self._forceAlign { XAlign::NONE } else { self.getStyle ().xalign._1 };
            let yalign = if self._forceAlign { YAlign::CENTER } else { self.getStyle ().yalign._1 };

            let mut x = if xalign == XAlign::LEFT || xalign == XAlign::NONE {
                0.f
            } else if xalign == XAlign::RIGHT {
                1.f - relSize.x
            } else { 0.5f - (relSize.x / 2.f) };

            let mut y = if yalign == YAlign::TOP {
                0.f
            } else if yalign == YAlign::BOTTOM {
                1.f - relSize.y
            } else {0.5f - (relSize.y / 2.f) };

            if xalign == XAlign::NONE {
                x = max (0.f, x);
            }

            y = max (0.f, y);

            self._relTextPos = makeVec2 (x, y);
            self._relTextSize = relSize;
        } else {
            self:.hide ();
            self._relTextSize = vec2 ();
            self._relTextPos = vec2 ();
        }
    } catch {
        err => {
            log::error #("Label", "Failed to compute label size ", err);

            self:.hide ();
            self._relTextSize = vec2 ();
            self._relTextPos = vec2 ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Set the text of the label
     * */
    pub fn setText (mut self, text : [c8]) {
        self:.setText (std::conv::to!{[c16]} (text));
    }

    /**
     * Set the text of the label
     * */
    pub fn setText (mut self, text : [c16]) {
        self._text = text;

        if self._attached {
            self._relFont = self.getFont ();
            self._relFontSize = self.getFontSize ();

            let dmut old = alias self._texture;
            {
                if let Ok (dmut t) = alias self._manager:.getFontManager ():.render (text, self.getFont (), self.getFontSize ()) {
                    self._texture = (alias self._manager:.getWindow ():.insertResource (alias t))?;
                } else {
                    self._texture = none;
                }
            } catch {
                err => {
                    log::error #("Label", "failed to set text : ", err);
                    self._texture = none;
                }
            }

            if let Ok (dmut t) = alias self._texture {
                self:.registerTextureShape (WidgetShapeKind::TEXT, t:.clone ());
            } else {
                self:.removeShape (WidgetShapeKind::TEXT);
            }

            if let Ok (dmut o) = alias old {
                o:.dispose ();
            }

            self:.show ();
            self:.computeSize ();
        }
    }

    /**
     * Change the vertical alignement of the label
     * */
    pub fn forceAlign (mut self, force : bool) {
        self._forceAlign = force;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the font used by the label
     * */
    pub fn getFont (self)-> [c8] {
        self.getStyle ().font._1
    }

    /**
     * @returns: the size of the font
     * */
    pub fn getFontSize (self)-> u32 {
        self.getStyle ().fontSize._1
    }

    /**
     * @returns: the size of the displayed text in pixels
     * */
    pub fn getTextSize (self)-> vec2 {
        self._relTextSize * self._absoluteSize
    }

    /**
     * @returns: the position of the displayed text in pixels
     * */
    pub fn getTextPos (self)-> vec2 {
        self._absolutePosition + (self._relTextPos * self._absoluteSize)
    }

    /**
     * @returns: the position and size of the shapes
     * */
    prot over getShapePositionAndSize (self, kind : WidgetShapeKind)-> (vec2, vec2) {
        match kind {
            WidgetShapeKind::TEXT => {
                (self._absolutePosition + (self._relTextPos * self._absoluteSize),
                 self._relTextSize * self._absoluteSize)
            }
            _ => {
                self.__super__.getShapePositionAndSize (kind)
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if let Ok (dmut t) = alias self._texture {
                t:.dispose ();
                self._texture = none;
            }

            self._super_:.dispose ();
        }
    }

}
