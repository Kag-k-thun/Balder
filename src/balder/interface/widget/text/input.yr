in input;


use balder::core::{shader::_, application::_};
use balder::core::_;
use balder::math::_;

use balder::interface::_;
use balder::interface::widget::text::label;

use balder::utils::_;

use std::{io, conv, char, time::_, fs::path};
use std::algorithm::_;

use ::sdl2::{clipboard, keyboard, keycode};
use ::sdl2::mouse;

pub class InputText over Widget {

    // The content of the input text
    let mut _text : [c16] = "";

    // The label to draw the text
    let dmut _label : &Label;

    prot {

        // The maximul length of the text content
        let _maxLen : usize;

        // True iif only numbers are allowed in the input
        let _onlyNumbers : bool;

    }

    prot { // text cursor

        // The cursor position (where to insert text, etc)
        let mut _cursor : usize = 0us;

        // The position of the start (or end) of the selection @warning: might be > self._cursor
        let mut _selectionCursor : usize = 0us;

        // The current shifting of the display, to always keep the cursor in the drawing window
        let mut _clipCursor : f32 = 0.f;

        // If true selectionCursor means something
        let mut _hasSelection : bool = false;

        // True iif we are updating the selection
        let mut _inSelection : bool = false;

        // True iif focused by manager for text input
        let mut _isFocused : bool = false;

        // The tick time to make cursor blinking
        let mut _cursorTimer : Duration = millis (0);

        // True iif the cursor is blinking off
        let mut _cursorOff : bool = false;

        // The speed of the timer blinking
        let mut _cursorTimerSpeed : Duration = millis (700);

        // True iif to make the cursor move at given speed
        let mut _selectionTimer : Duration = millis (0);

        // If -1 or 1, then the cursor moves left or right during onTick
        let mut _selectionSpeed : i32 = 0;

        // The speed of the sliding of selection when going over the input text
        let mut _selectionTimerSpeed : Duration = millis (50);

    }

    prot { // Size

        // the relative size of the cursor
        let mut _cursorSize : vec2 = vec2 ();

        // The relative position of the cursor
        let mut _cursorPos : vec2 = vec2 ();

        // The relative position of the start of the selection
        let mut _selectionPos : vec2 = vec2 ();

        // The size of the selection in pixels
        let mut _selectionSize : vec2 = vec2 ();

        // The shift on the left of the label due to text oversize
        let mut _textShiftLeft : f32 = 0.f;

    }

    prot { // Shapes
        let dmut _cursorShape : (&Shape)? = none;
        let dmut _selectionShape : (&Shape)? = none;

        let mut _cursorColor : vec4 = vec4 ();
    }

    prot { // signals

        let dmut _validateText : (&Signal!{[c8]})? = none;

        // Maibox receiving text input events
        let dmut _slots : (&SlotEmitter)? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new input text
     * */
    pub self (dmut manager : &WidgetManager,
              name : [c8],
              onlyNumbers : bool = false,
              maxLen : usize = 255us)

        with super (alias manager, name, WidgetKeys::INPUT_TEXT)

        , _label = copy Label (alias manager, "")
        , _onlyNumbers = onlyNumbers
        , _maxLen = maxLen
    {}

    prot over onApplyStyle (mut self) {
        if let Ok (inner) = self.getStyle ().subItems ["label"] {
            self._label:.setStyle (inner);
        }

        let mut selectionColor = vec4 ();
        if let Ok (inner) = self._currentStyle.subItems ["selection"] {
            selectionColor = inner.getColor (WidgetShapeKind::SELECTION);
        } else {
            selectionColor = self._currentStyle.getColor (WidgetShapeKind::SELECTION);
        }

        if let Ok (inner) = self._currentStyle.subItems ["cursor"] {
            self._cursorColor = inner.getColor (WidgetShapeKind::TEXT);
        } else {
            self._cursorColor = self._currentStyle.getColor (WidgetShapeKind::TEXT);
        }

        if let Ok (dmut s) = alias self._selectionShape {
            s:.setColor (selectionColor);
        }

        if let Ok (dmut s) = alias self._cursorShape {
            s:.setColor (self._cursorColor);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self, parentPath : Path) {
        self.__super__:.onAttach (parentPath);

        let dmut shDr = self._manager:.getShapeDrawer ();
        {
            let dmut cursorShape = shDr:.registerColorQuad (color-> self._cursorColor);
            self._cursorShape = (alias cursorShape)?;

            let dmut selectionSh = shDr:.registerColorQuad ();
            self._selectionShape = (alias selectionSh)?;
        } catch {
            err => {
                log::error #("TextInput", "Failed to construct shapes : ", err);
            }
        }

        self._label:.onAttach (self._path);
    }

    over onHide (mut self) {
        self._label:.hide ();
        if let Ok (dmut s) = alias self._selectionShape {
            s:.hide ();
        }

        if let Ok (dmut s) = alias self._cursorShape {
            s:.hide ();
        }
    }

    over onShow (mut self) {
        self._label:.show ();
        if let Ok (dmut s) = alias self._selectionShape {
            if self._hasSelection {
                s:.show ();
            }
        }

        if let Ok (dmut s) = alias self._cursorShape {
            s:.show ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        self:.computeCursorSize (self._absolutePosition, self._absoluteSize);
        self:.computeSelectionSize (self._absolutePosition, self._absoluteSize);

        if self._isFocused {
            let wpos = makeVec2 (self._absolutePosition.x - self._textShiftLeft * self._absoluteSize.x,
                                 self._absolutePosition.y);

            self._label:.forceAlign (true);
            self._label:.setSize (wpos, self._absoluteSize, self._depth + 1);
        } else {
            self._label:.forceAlign (false);
            self._label:.setSize (self._absolutePosition, self._absoluteSize, self._depth + 1);
        }

        self:.onUpdateScissors ();
    } catch {
        err => {
            log::error #("InputText", "failed to compute sizes", err);
        }
    }

    over onUpdateScissors (mut self) {
        if let Ok (dmut s) = alias self._cursorShape {
            let (csciPos, csciSize) = self.getScissors (self._cursorPos, self._cursorSize);
            s:.setScissors (csciPos, csciSize);
        }

        {
            self._label:.setScissors (self._scissorPos, self._scissorSize);
        }

        if let Ok (dmut s) = alias self._selectionShape {
            let (sciPos, sciEnd) = self.getScissors (self._selectionPos, self._selectionSize);

            s:.setScissors (sciPos, sciEnd);
        }

    }

    /**
     * Compute the size and the position of the cursor
     * */
    fn computeCursorSize (mut self, pos : vec2, size : vec2)
        throws BalderError
    {
        if let Ok (dmut b) = alias self._cursorShape {
            if self._isFocused {
                let dmut man = self._manager:.getFontManager ();
                let csize = man:.getRenderSize (self._text [0 .. self._cursor],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                self._cursorSize.x = cast!f32 (man:.getRenderSize ("|",
                                                                 self._label.getFont (),
                                                                 self._label.getFontSize ()).x) / 3.f;

                let cpos = makeVec2 (cast!f32 (csize.x) - (self._textShiftLeft * size.x), size.y * 0.15f);
                let s = makeVec2 (self._cursorSize.x, size.y * 0.7);

                b:.setPosition (cpos + pos);
                b:.setSize (s);
                if !self._cursorOff {
                    b:.setLevel (self.getDepth (WidgetShapeKind::TEXT));
                }

                self._cursorPos = cpos + pos;
                self._cursorSize = s;

                b:.show ();
            } else {
                b:.hide ();
            }
        }
    }

    /**
     * Compute the size and the position of the selection quad
     * */
    fn computeSelectionSize (mut self, pos : vec2, size : vec2)
        throws BalderError
    {
        if let Ok (dmut b) = alias self._selectionShape {
            if self._hasSelection {
                let dmut man = self._manager:.getFontManager ();
                let selStart = min (self._cursor, self._selectionCursor);
                let selEnd = max (self._cursor, self._selectionCursor);

                let csize = man:.getRenderSize (self._text [0 .. selStart],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                let cpos = makeVec2 (cast!f32 (csize.x + 2) - (self._textShiftLeft * size.x), size.y * 0.15f);

                let mut selectionSize = cast!f32 (man:.getRenderSize (self._text [selStart .. selEnd],
                                                                      self._label.getFont (),
                                                                      self._label.getFontSize ()).x);

                let s = makeVec2 (selectionSize, size.y * 0.7);
                let sciPos = makeVec2 (pos.x, pos.y);
                let sciSize = makeVec2 (size.x, size.y);

                b:.setPosition (cpos + pos);
                b:.setSize (s);
                b:.setLevel (self.getDepth (WidgetShapeKind::SELECTION));
                b:.setScissors (sciPos, sciSize);

                self._selectionPos = cpos + pos;
                self._selectionSize = s;

                b:.show ();
            } else {
                b:.hide ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          TICK EVENTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onTick (mut self, delta : Duration) {
        if let Ok (dmut m) = alias self._slots {
            m:.emit ();
        }

        if self._isFocused {
            self._cursorTimer += delta;
            self._cursorTimer = millis (self._cursorTimer.allMillis % (self._cursorTimerSpeed.allMillis * 2));

            if let Ok (dmut b) = alias self._cursorShape {
                if self._cursorTimer > self._cursorTimerSpeed && !self._cursorOff {
                    self._cursorOff = true;
                    b:.setColor (makeVec4 (self._cursorColor.xyz, 0.f));
                    b:.setLevel (0);
                } else if self._cursorTimer < self._cursorTimerSpeed && self._cursorOff {
                    self._cursorOff = false;
                    b:.setColor (self._cursorColor);
                    b:.setLevel (self.getDepth (WidgetShapeKind::TEXT));
                }
            }

            if self._selectionSpeed != 0 {
                self._selectionTimer += delta;

                if self._selectionTimer >= self._selectionTimerSpeed {
                    if self._selectionSpeed > 0 { self:.onTextSelectionForwardMove (); }
                    else { self:.onTextSelectionBackwardMove (); }
                    self._selectionTimer = millis (0);
                }

                self._hasSelection = (self._selectionCursor != self._cursor);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onClick (mut self, pos : vec2, button : u8)-> dmut (&Widget)? {
        if button == SDL_BUTTON_LEFT {
            self._hasSelection = false;
            if self._isFocused {
                self._inSelection = true;
                self._cursor = self:.mousePositionToCursor (pos);
                self._selectionCursor = self._cursor;
            }

            self:.resetSelection ();
            self:.computeShifting ();

            return (alias self)?;
        }

        none
    }

    pub over onDoubleClick (mut self, pos : vec2)-> dmut (&Widget)? {
        return self:.onClick (pos, SDL_BUTTON_LEFT);
    }

    pub over onHover (mut self, _ : vec2)-> dmut (&Widget)? {
        if !self._isFocused {
            self:.setHover (true);
        }

        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_IBEAM);
        return (alias self)?;
    }

    pub over onLoseHoverFocus (mut self) {
        if !self._isFocused {
            self:.setHover (false);
        }

        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_ARROW);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          SLIDING EVENTS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onSliding (mut self, pos : vec2, _ : vec2, _ : u8) {
        if self._inSelection {
            if pos.x < 0.f {
                self._cursor = self:.mousePositionToCursor (makeVec2 (0.f, pos.y));
                if self._selectionSpeed != -1 {
                    self._selectionTimer = millis (0);
                    self._selectionSpeed = -1;
                }
                self._hasSelection = (self._selectionCursor != self._cursor);
            } else if pos.x > 1.f {
                self._cursor = self:.mousePositionToCursor (makeVec2 (1.f, pos.y));
                if self._selectionSpeed != 1 {
                    self._selectionTimer = millis (0);
                    self._selectionSpeed = 1;
                }
                self._hasSelection = (self._selectionCursor != self._cursor);
            } else {
                self._selectionSpeed = 0;
                self._cursor = self:.mousePositionToCursor (pos);
                self._hasSelection = (self._selectionCursor != self._cursor);
            }
        }

        self:.resetCursorTimer ();
        self:.computeShifting ();
    }

    pub over onSlidingEnd (mut self, _ : u8) {
        self._selectionSpeed = 0;
        self._selectionTimer = millis (0);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT INPUT EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn eraseSelection (mut self) {
        self._text = self._text [0 .. min (self._cursor, self._selectionCursor)] ~ self._text [max (self._cursor, self._selectionCursor) .. $];
        self._cursor = min (self._cursor, self._selectionCursor);
        self:.resetSelection ();
        self:.setText (self._text);
    }

    pub fn onTextInput (mut self, text : [c8]) {
        let txt = if self._onlyNumbers { self.keepNumbers (text) } else { text };
        if self._hasSelection { // erase selected text
            self:.eraseSelection ();
        }

        if text.len + self._text.len <= self._maxLen {
            let c16Txt = txt.to![c16] ();
            self._text = self._text [0 .. self._cursor] ~ c16Txt ~ self._text [self._cursor .. $];
            self._cursor += c16Txt.len;

            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextErase (mut self, _ : KeyInfo) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor > 0 {
            self._text = self._text [0 .. self._cursor - 1] ~ self._text [self._cursor .. $];
            self._cursor -= 1;

            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextForwardErase (mut self, _ : KeyInfo) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor < self._text.len {
            self._text = self._text [0 .. self._cursor] ~ self._text [self._cursor + 1 .. $];
            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextEraseWord (mut self) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor > 0 {
            let mut start = self._cursor;
            self._cursor -= 1;
            while self._cursor > 0 {
                if self._cursor != self._text.len && self._cursor >= 1 {
                    if self._text [self._cursor].isPunctuation () != self._text [self._cursor - 1].isPunctuation () {
                        break;
                    }
                }

                self._cursor -= 1;
            }

            self._text = self._text [0 .. self._cursor] ~ self._text [start .. $];
            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextForwardEraseWord (mut self) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor < self._text.len {
            let mut end = self._cursor;
            while end < self._text.len {
                if end != self._text.len - 1 {
                    if self._text [end].isPunctuation () != self._text [end + 1].isPunctuation () {
                        end += 1;
                        break;
                    }
                }

                end += 1;
            }

            self._text = self._text [0 .. self._cursor] ~ self._text [end .. $];
            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT FOCUS EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onGainFocus (mut self) {
        self:.startInputText ();

        self._isFocused = true;
        self:.setHover (false);

        self._inSelection = false;
        self._cursor = 0;
        self:.resetCursorTimer ();

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub over onLoseFocus (mut self) {
        self:.stopInputText ();

        self._isFocused = false;
        self._inSelection = false;
        self._textShiftLeft = 0.f;
        self._cursor = 0;

        self:.resetSelection ();
        self:.computeSize ();

        if let Ok (dmut m) = alias self._validateText {
            m:.emit (self._text.to!{[c8]} ());
        }
    }

    pub fn onTextValidate (mut self, _ : KeyInfo) {
        self._manager:.setFocus (none);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXT MOVE EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn onTextForwardMove (mut self, _ : KeyInfo) {
        if self._cursor != self._text.len {
            self._cursor += 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub fn onTextBackwardMove (mut self, _ : KeyInfo) {
        if self._cursor != 0 {
            self._cursor -= 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub fn onTextForwardMoveWord (mut self) {
        if (self._cursor == self._text.len) return;

        while self._cursor < self._text.len {
            if self._cursor != self._text.len - 1 {
                if self._text [self._cursor].isPunctuation () != self._text [self._cursor + 1].isPunctuation () {
                    self._cursor += 1;
                    break;
                }
            }

            self._cursor += 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub fn onTextBackwardMoveWord (mut self) {
        if (self._cursor == 0) return;

        self._cursor -= 1;
        while self._cursor > 0 {
            if self._cursor != self._text.len && self._cursor >= 1 {
                if self._text [self._cursor].isPunctuation () != self._text [self._cursor - 1].isPunctuation () {
                    break;
                }
            }

            self._cursor -= 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT SELECTION EVENTS          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the selection cursor is moved forward (SHIFT + right)
     * */
    pub fn onTextSelectionForwardMove (mut self) {
        if !self._hasSelection {
            self._selectionCursor = self._cursor;
            self._hasSelection = true;
        }

        if self._cursor != self._text.len {
            self._cursor += 1;
        }

        self:.resetCursorTimer ();
        self:.computeShifting ();
    }

    /**
     * Method called when the selection cursor is moved forward (SHIFT + left)
     * */
    pub fn onTextSelectionBackwardMove (mut self) {
        if !self._hasSelection {
            self._selectionCursor = self._cursor;
            self._hasSelection = true;
        }

        if self._cursor != 0us {
            self._cursor -= 1;
        }

        self:.resetCursorTimer ();
        self:.computeShifting ();
    }

    /**
     * Method called when the Ctrl+a is inputed (or selection all is triggered by hand)
     * */
    pub fn onTextSelectionAll (mut self) {
        if self._text.len != 0 {
            self._hasSelection = true;
            self._cursor = self._text.len;
            self._selectionCursor = 0;

            self:.resetCursorTimer ();
            self:.computeShifting ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT COPY/PASTE EVENTS          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Paste text from clipboard to input
     * */
    pub fn onTextPaste (mut self) {
        if SDL_HasClipboardText () {
            let dmut t = SDL_GetClipboardText ();
            if t != null {
                self:.onTextInput (unsafe { t.fromStringZ () });
                etc::c::memory::free (cast!{*void} (t));
            } else {
                log::error #("InputText", "SDL clipboard lied!");
            }
        }
    }

    /**
     * Copy text from input to clipboard
     * */
    pub fn onTextCopy (mut self) {
        if self._hasSelection {
            let selStart = min (self._cursor, self._selectionCursor);
            let selEnd = max (self._cursor, self._selectionCursor);

            let select = self._text [selStart .. selEnd].to!{[c8]} ();
            SDL_SetClipboardText (select.toStringZ ());
        }

        self:.resetCursorTimer ();
    }

    /**
     * Cut text from input to clipboard
     * */
    pub fn onTextCut (mut self) {
        if self._hasSelection {
            let selStart = min (self._cursor, self._selectionCursor);
            let selEnd = max (self._cursor, self._selectionCursor);

            let select = self._text [selStart .. selEnd].to!{[c8]} ();
            SDL_SetClipboardText (select.toStringZ ());

            self._text = self._text [0 .. selStart] ~ self._text [selEnd .. $];

            self:.setText (self._text);
            self:.resetSelection ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the text in the input text
     * @params:
     *    - text: the text to set
     *    - moveCursor: true iif the cursor is put at the end of the text
     * */
    pub fn setText (mut self, text : [c8], moveCursor : bool = false) {
        self:.setText (text.to!{[c16]} (), moveCursor-> moveCursor);
    }

    /**
     * Change the text in the input text
     * @params:
     *    - text: the text to set
     *    - moveCursor: true iif the cursor is put at the end of the text
     * */
    fn setText (mut self, text : [c16], moveCursor : bool = false) {
        self._text = text;
        if (moveCursor) { self._cursor = self._text.len; }

        self:.resetSelection ();
        self:.computeShifting (update-> false);

        self._label:.setText (text);
        self:.computeSize ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over isFocusableLeftClick (self)-> bool {
        true
    }

    pub over getMaxDepth (self)-> u32 {
        self._label.getMaxDepth ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SIGNALS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect to the event emitted when the text input is validated
     * */
    pub fn textValidated (mut self)-> dmut &Signal!{[c8]} {
        if let Ok (dmut m) = alias self._validateText {
            return alias m;
        }

        let dmut s = copy Signal!{[c8]} ();
        self._validateText = (alias s)?;

        alias s
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMPUTATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Convert an absolute mouse position into a text cursor index
     * */
    fn mousePositionToCursor (mut self, pos : vec2)-> usize {
        if self._text.len == 0 {
            return 0us;
        }

        let dmut man = self._manager:.getFontManager ();
        let baseX = -self._textShiftLeft;
        for i in 0 .. self._text.len {
            {
                let size = man:.getRenderSize (self._text [0 .. i + 1],
                                               self._label.getFont (),
                                               self._label.getFontSize ());

                let csize = man:.getRenderSize (self._text [i .. i + 1],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                let toChar = (cast!f32 (size.x) - cast!f32 (csize.x) / 2.f) / self._absoluteSize.x;
                if pos.x <= toChar + baseX {
                    return i;
                }
            } catch {
                _ => return 0us;
            }
        }

        self._text.len
    }

    /**
     * Reset the selection by putting cursor and selectionCursor at the same position
     * */
    fn resetSelection (mut self) {
        if self._cursor > self._text.len { self._cursor = self._text.len; }
        self._selectionCursor = self._cursor;
        self._hasSelection = false;

        self:.resetCursorTimer ();
    }

    /**
     * Reset the cursor timer to force it to be displayed
     * */
    fn resetCursorTimer (mut self) {
        self._cursorTimer = millis (0);
        self._cursorOff = true;
    }

    /**
     * Remove every chararcter in the string that is not a number, a point or the minus sign
     * */
    fn keepNumbers (self, txt : [c8])-> [c8] {
        if self._cursor == 0 && txt == "-" {
            if self._text.len != 0 && self._text [0] == '-' {
                return "";
            }

            return txt;
        }

        if txt == "." {
            if let Ok () = self._text.find ('.') {
                return "";
            }

            return txt;
        }

        if txt.all (|x| => x >= '0' && x <= '9') {
            return txt
        }

        ""
    }

    /**
     * Compute the shifting of the label to make the cursor always visible on screen
     * */
    fn computeShifting (mut self, update : bool = true) {
        let dmut man = self._manager:.getFontManager ();
        {
            let size = man:.getRenderSize (self._text [0 .. self._cursor],
                                           self._label.getFont (),
                                           self._label.getFontSize ());

            let fullSize = man:.getRenderSize (self._text,
                                               self._label.getFont (),
                                               self._label.getFontSize ());

            let relSize = (cast!f32 (size.x)) / self._absoluteSize.x;
            let relFullSize = (cast!f32 (fullSize.x)) / self._absoluteSize.x;
            let limitRight = 1.f - (self._cursorSize.x * 2.f / self._absoluteSize.x);

            if relSize < 1.f && !self._hasSelection {
                self._textShiftLeft = 0.f;
            } else if self._textShiftLeft > relSize {
                self._textShiftLeft = relSize;
            } else if self._textShiftLeft < relSize - limitRight {
                self._textShiftLeft = relSize - limitRight;
            }


            if !self._inSelection {
                // Move the text to the right if there is not enough text after the cursor to fill the remaining part of the input text
                if relFullSize > limitRight && relFullSize - relSize < 1.f {
                    self._textShiftLeft = relFullSize - limitRight;
                }
            }

            if update {
                self:.computeSize ();
            }
        } catch {
            err => {
                log::error #("InputText", "Failed to recompute input size", err);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSABLE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._attached = false;
            self._slots = none;

            if self._isFocused {
                self:.onLoseFocus ();
            }

            self._label:.dispose ();

            if let Ok (dmut b) = alias self._selectionShape {
                self._selectionShape = none;
                b:.dispose ();
            }

            if let Ok (dmut b) = alias self._cursorShape {
                self._cursorShape = none;
                b:.dispose ();
            }

            self._super_:.dispose ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT MODE TOGGLE STATE          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the input mode
     * */
    fn startInputText (mut self) {
        let dmut man = self._manager:.getInputManager ();
        let dmut box = copy SlotEmitter ();
        self._slots = (alias box)?;

        man:.startInputText ();
        man:.textInput ():.connect (alias box, &self:.onTextInput);

        man:.keyboard (KeyInfo (SDLK_BACKSPACE, KeyEvent::DOWN)):.connect (alias box, &self:.onTextErase);
        man:.keyboard (KeyInfo (SDLK_DELETE, KeyEvent::DOWN)):.connect (alias box, &self:.onTextForwardErase);
        man:.keyboard (KeyInfo (SDLK_BACKSPACE, KeyEvent::REPEAT)):.connect (alias box, &self:.onTextErase);
        man:.keyboard (KeyInfo (SDLK_DELETE, KeyEvent::REPEAT)):.connect (alias box, &self:.onTextForwardErase);

        man:.combination (copy [SDLK_LCTRL, SDLK_BACKSPACE]):.connect (alias box, &self:.onTextEraseWord);
        man:.combination (copy [SDLK_LCTRL, SDLK_DELETE]):.connect (alias box, &self:.onTextForwardEraseWord);

        man:.keyboard (KeyInfo (SDLK_LEFT, KeyEvent::DOWN)):.connect (alias box, &self:.onTextBackwardMove);
        man:.keyboard (KeyInfo (SDLK_RIGHT, KeyEvent::DOWN)):.connect (alias box, &self:.onTextForwardMove);
        man:.keyboard (KeyInfo (SDLK_LEFT, KeyEvent::REPEAT)):.connect (alias box, &self:.onTextBackwardMove);
        man:.keyboard (KeyInfo (SDLK_RIGHT, KeyEvent::REPEAT)):.connect (alias box, &self:.onTextForwardMove);

        man:.keyboard (KeyInfo (SDLK_RETURN, KeyEvent::RELEASE)):.connect (alias box, &self:.onTextValidate);
        man:.keyboard (KeyInfo (SDLK_ESCAPE, KeyEvent::RELEASE)):.connect (alias box, &self:.onTextValidate);

        man:.combination (copy [SDLK_LCTRL, SDLK_RIGHT]):.connect (alias box, &self:.onTextForwardMoveWord);
        man:.combination (copy [SDLK_LCTRL, SDLK_LEFT]):.connect (alias box, &self:.onTextBackwardMoveWord);

        man:.combination (copy [SDLK_LCTRL, SDLK_v]):.connect (alias box, &self:.onTextPaste);
        man:.combination (copy [SDLK_LCTRL, SDLK_c]):.connect (alias box, &self:.onTextCopy);
        man:.combination (copy [SDLK_LCTRL, SDLK_x]):.connect (alias box, &self:.onTextCut);
        man:.combination (copy [SDLK_LCTRL, SDLK_a]):.connect (alias box, &self:.onTextSelectionAll);

        man:.combination (copy [SDLK_LSHIFT, SDLK_RIGHT]):.connect (alias box, &self:.onTextSelectionForwardMove);
        man:.combination (copy [SDLK_LSHIFT, SDLK_LEFT]):.connect (alias box, &self:.onTextSelectionBackwardMove);
    }

    /**
     * Change the input mode
     * */
    fn stopInputText (mut self) {
        let dmut man = self._manager:.getInputManager ();
        self._slots = none;

        man:.stopInputText ();
        man:.textInput ():.disconnect (&self:.onTextInput);

        man:.keyboard (KeyInfo (SDLK_BACKSPACE, KeyEvent::DOWN)):.disconnect (&self:.onTextErase);
        man:.keyboard (KeyInfo (SDLK_DELETE, KeyEvent::DOWN)):.disconnect (&self:.onTextForwardErase);
        man:.keyboard (KeyInfo (SDLK_BACKSPACE, KeyEvent::REPEAT)):.disconnect (&self:.onTextErase);
        man:.keyboard (KeyInfo (SDLK_DELETE, KeyEvent::REPEAT)):.disconnect (&self:.onTextForwardErase);

        man:.combination (copy [SDLK_LCTRL, SDLK_BACKSPACE]):.disconnect (&self:.onTextEraseWord);
        man:.combination (copy [SDLK_LCTRL, SDLK_DELETE]):.disconnect (&self:.onTextForwardEraseWord);

        man:.keyboard (KeyInfo (SDLK_LEFT, KeyEvent::DOWN)):.disconnect (&self:.onTextBackwardMove);
        man:.keyboard (KeyInfo (SDLK_RIGHT, KeyEvent::DOWN)):.disconnect (&self:.onTextForwardMove);
        man:.keyboard (KeyInfo (SDLK_LEFT, KeyEvent::REPEAT)):.disconnect (&self:.onTextBackwardMove);
        man:.keyboard (KeyInfo (SDLK_RIGHT, KeyEvent::REPEAT)):.disconnect (&self:.onTextForwardMove);

        man:.keyboard (KeyInfo (SDLK_RETURN, KeyEvent::RELEASE)):.disconnect (&self:.onTextValidate);
        man:.keyboard (KeyInfo (SDLK_ESCAPE, KeyEvent::RELEASE)):.disconnect (&self:.onTextValidate);

        man:.combination (copy [SDLK_LCTRL, SDLK_RIGHT]):.disconnect (&self:.onTextForwardMoveWord);
        man:.combination (copy [SDLK_LCTRL, SDLK_LEFT]):.disconnect (&self:.onTextBackwardMoveWord);

        man:.combination (copy [SDLK_LCTRL, SDLK_v]):.disconnect (&self:.onTextPaste);
        man:.combination (copy [SDLK_LCTRL, SDLK_c]):.disconnect (&self:.onTextCopy);
        man:.combination (copy [SDLK_LCTRL, SDLK_x]):.disconnect (&self:.onTextCut);
        man:.combination (copy [SDLK_LCTRL, SDLK_a]):.disconnect (&self:.onTextSelectionAll);

        man:.combination (copy [SDLK_LSHIFT, SDLK_RIGHT]):.disconnect (&self:.onTextSelectionForwardMove);
        man:.combination (copy [SDLK_LSHIFT, SDLK_LEFT]):.disconnect (&self:.onTextSelectionBackwardMove);
    }




}
