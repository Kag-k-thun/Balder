in input;


use balder::core::{shader::_, application::_};
use balder::core::_;
use balder::math::_;

use balder::interface::_;
use balder::utils::_;

use std::{io, conv, char};
use std::algorithm::_;

pub class InputText over Widget {

    // The content of the input text
    let mut _text : [c16] = "";

    // The label to draw the text
    let dmut _label : &Label;

    prot {

        // The color of the background
        let _backColor : vec4;

        // The color of the selection (when there is a selection)
        let _selectionColor : vec4;

        // The color of the cursor
        let _cursorColor : vec4;

        // The maximul length of the text content
        let _maxLen : usize;

        // True iif only numbers are allowed in the input
        let _onlyNumbers : bool;

        // The size of the border around the text label
        let _borderSize : WidgetSize;

        // The alignement of the text when unfocused
        let _xalign : XAlign;
    }

    prot { // text cursor

        // The cursor position (where to insert text, etc)
        let mut _cursor : usize = 0us;

        // The position of the start (or end) of the selection @warning: might be > self._cursor
        let mut _selectionCursor : usize = 0us;

        // The current shifting of the display, to always keep the cursor in the drawing window
        let mut _clipCursor : f32 = 0.f;

        // If true selectionCursor means something
        let mut _hasSelection : bool = false;

        // True iif we are updating the selection
        let mut _inSelection : bool = false;

        // True iif focused by manager for text input
        let mut _isFocused : bool = false;

    }

    prot { // Size

        // the relative size of the cursor
        let mut _cursorSize : f32 = 0.f;

        // The size of the selection (applicable iif self._hasSelection)
        let mut _selectionSize : f32 = 0.f;

        // The relative position of the cursor
        let mut _cursorPos : vec2 = vec2 ();

        // The relative position of the start of the selection
        let mut _selectionPos : vec2 = vec2 ();

        // The size of the border in pixels
        let mut _borderPixWidth : f32 = 0.f;

        // The shift on the left of the label due to text oversize
        let mut _textShiftLeft : f32 = 0.f;

    }

    prot { // Shapes
        let dmut _backShape : (&Shape)? = none;
        let dmut _cursorShape : (&Shape)? = none;
        let dmut _selectionShape : (&Shape)? = none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new input text
     * */
    pub self (dmut manager : &WidgetManager,
              name : [c8],
              fontPath : [c8],
              fontSize : u32,
              textColor : vec4 = ColorPalette.get (DefaultColorPalettes::GREY, 0.9f),
              backColor : vec4 = ColorPalette.get (DefaultColorPalettes::GREY, 0.f),
              cursorColor : vec4 = ColorPalette.get (DefaultColorPalettes::GREY, 0.9f),
              selectionColor : vec4 = ColorPalette.get (DefaultColorPalettes::PURPLE, 0.5f),
              xalign : XAlign = XAlign::CENTER,
              yalign : YAlign = YAlign::CENTER,
              borderSize : WidgetSize = WidgetSize (pix-> 3),
              onlyNumbers : bool = false,
              maxLen : usize = 255us)

        with super (alias manager, name)
        , _label = copy Label (alias manager, "", fontPath, fontSize, color-> textColor, xalign-> xalign, yalign-> yalign)
        , _backColor = backColor
        , _cursorColor = cursorColor
        , _selectionColor = selectionColor
        , _onlyNumbers = onlyNumbers
        , _maxLen = maxLen
        , _borderSize = borderSize
        , _xalign = xalign
    {
        let dmut shDr = self._manager:.getApplication ():.getShapeDrawer ();
        {
            let dmut backSh = shDr:.registerQuad (vec2 (), self._backColor, vec2 ());
            self._backShape = (alias backSh)?;

            let dmut cursorShape = shDr:.registerQuad (vec2 (), self._cursorColor, vec2 ());
            self._cursorShape = (alias cursorShape)?;

            let dmut selectionSh = shDr:.registerQuad (vec2 (), self._selectionColor, vec2 ());
            self._selectionShape = (alias selectionSh)?;
        } catch {
            err => {
                log::error #("TextInput", "Failed to construct shapes : ", err);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onUpdateSize (mut self, pos : vec2, size : vec2, depth : u32) {
        self._absoluteSize = size;
        self._absolutePosition = pos;
        self._depth = depth;

        if let Ok (dmut b) = alias self._backShape {
            b:.setPosition (pos);
            b:.setSize (size);
            b:.setLevel (depth);
            b:.show ();
        }

        let borderSizePix = makeVec2 (self.clampSize (self._borderSize, size.x),
                                      self.clampSize (self._borderSize, size.y)) * size;

        self._borderPixWidth = borderSizePix.x;

        if self._isFocused {
            let wpos = makeVec2 (pos.x - self._textShiftLeft * size.x, pos.y) + borderSizePix;
            self._label:.setXAlign (XAlign::NONE);
            self._label:.onUpdateSize (wpos, size - (borderSizePix * 2.f), depth + 1);
        } else {
            self._label:.setXAlign (self._xalign);
            self._label:.onUpdateSize (pos + borderSizePix, size - (borderSizePix * 2.f), depth + 1);
        }

        self._label:.setScissors (pos + borderSizePix, size - (borderSizePix * 2.f));
        if let Ok (dmut b) = alias self._cursorShape {
            if self._isFocused {
                let dmut man = self._manager:.getFontManager ();
                let csize = man:.getRenderSize (self._text [0 .. self._cursor],
                                               self._label.getFont (),
                                               self._label.getFontSize ());

                self._cursorSize = cast!f32 (man:.getRenderSize ("l",
                                                                 self._label.getFont (),
                                                                 self._label.getFontSize ()).x) / 2.f;

                let cpos = makeVec2 (cast!f32 (csize.x + 2) - (self._textShiftLeft * size.x), size.y * 0.15f);
                let s = makeVec2 (self._cursorSize, size.y * 0.7);

                b:.setPosition (cpos + pos);
                b:.setSize (s);
                b:.setLevel (depth + 6);
                b:.show ();
            } else {
                b:.hide ();
            }
        }
    } catch {
        err => {
            log::error #("InputText", "failed to compute sizes", err);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onClickLeft (mut self, pos : vec2) {
        self._hasSelection = false;
        if self._isFocused {
            self._inSelection = true;
            self._manager:.setSlideFocus ((alias self)?);
            self._cursor = self:.mousePositionToCursor (pos);
        }

        self:.resetSelection ();
        self:.computeShifting ();
        self._manager:.setLeftClickFocus ((alias self)?);
        self._manager:.setNextClickFocus ((alias self)?);
    }

    pub over onDoubleClick (mut self, pos : vec2) {
        self:.onClickLeft (pos);
    }

    pub over onClickLeftEnd (mut self) {
        self._manager:.setTextFocus ((alias self)?);
        if !self._isFocused {
            self._isFocused = true;
            self._inSelection = false;
        }

        self:.computeShifting ();
        self._manager:.setNextClickFocus ((alias self)?);
    }

    pub over onNextClick (mut self) {
        self._manager:.setTextFocus (none);
        self._isFocused = false;
        self._inSelection = false;
        self._textShiftLeft = 0.f;
        self._cursor = 0;

        self:.resetSelection ();
        self:.onUpdateSize (self._absolutePosition, self._absoluteSize, self._depth);
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT INPUT EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onTextInput (mut self, text : [c8]) {
        let txt = if self._onlyNumbers { self.keepNumbers (text) } else { text };
        if self._hasSelection { // erase selected text
            self._text = self._text [0 .. min (self._cursor, self._selectionCursor)] ~ self._text [max (self._cursor, self._selectionCursor) .. $];
        }

        if text.len + self._text.len <= self._maxLen {
            let c16Txt = txt.to![c16] ();
            self._text = self._text [0 .. self._cursor] ~ c16Txt ~ self._text [self._cursor .. $];
            self._cursor += c16Txt.len;

            self:.setText (self._text);
        }

        self:.resetSelection ();
    }

    pub over onTextErase (mut self) {
        if self._hasSelection {
            self._text = self._text [0 .. min (self._cursor, self._selectionCursor)] ~ self._text [max (self._cursor, self._selectionCursor) .. $];
            self._cursor = min (self._cursor, self._selectionCursor);

            self:.setText (self._text);
        } else if self._cursor > 0 {
            self._text = self._text [0 .. self._cursor - 1] ~ self._text [self._cursor .. $];
            self._cursor -= 1;

            self:.setText (self._text);
        }

        self:.resetSelection ();
    }

    pub over onTextForwardErase (mut self) {
        if self._hasSelection {
            self._text = self._text [0 .. min (self._cursor, self._selectionCursor)] ~ self._text [max (self._cursor, self._selectionCursor) .. $];
            self._cursor = min (self._cursor, self._selectionCursor);

            self:.setText (self._text);
        } else if self._cursor < self._text.len {
            self._text = self._text [0 .. self._cursor] ~ self._text [self._cursor + 1 .. $];
            self:.setText (self._text);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXT MOVE EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onTextForwardMove (mut self) {
        if self._cursor != self._text.len {
            self._cursor += 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub over onTextBackwardMove (mut self) {
        if self._cursor != 0 {
            self._cursor -= 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub over onTextForwardMoveWord (mut self) {
        if (self._cursor == self._text.len) return;

        while self._cursor < self._text.len {
            if self._cursor != self._text.len - 1 {
                if self._text [self._cursor].isPunctuation () != self._text [self._cursor + 1].isPunctuation () {
                    self._cursor += 1;
                    break;
                }
            }

            self._cursor += 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub over onTextBackwardMoveWord (mut self) {
        if (self._cursor == 0) return;

        self._cursor -= 1;
        while self._cursor > 0 {
            if self._cursor != self._text.len && self._cursor >= 1 {
                if self._text [self._cursor].isPunctuation () != self._text [self._cursor - 1].isPunctuation () {
                    break;
                }
            }

            self._cursor -= 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the text in the input text
     * @params:
     *    - text: the text to set
     *    - moveCursor: true iif the cursor is put at the end of the text
     * */
    pub fn setText (mut self, text : [c8], moveCursor : bool = false) {
        self:.setText (text.to!{[c16]} (), moveCursor-> moveCursor);
    }

    /**
     * Change the text in the input text
     * @params:
     *    - text: the text to set
     *    - moveCursor: true iif the cursor is put at the end of the text
     * */
    fn setText (mut self, text : [c16], moveCursor : bool = false) {
        self._text = text;
        if (moveCursor) { self._cursor = self._text.len; }

        self:.resetSelection ();
        self:.computeShifting (update-> false);

        self._label:.setText (text)?;
        self:.onUpdateSize (self._absolutePosition, self._absoluteSize, self._depth);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMPUTATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Convert an absolute mouse position into a text cursor index
     * */
    fn mousePositionToCursor (mut self, pos : vec2)-> usize {
        if self._text.len == 0 {
            return 0us;
        }

        let dmut man = self._manager:.getFontManager ();
        let baseX = -self._textShiftLeft + (self._borderPixWidth / self._absoluteSize.x);
        for i in 0 .. self._text.len {
            {
                let size = man:.getRenderSize (self._text [0 .. i + 1],
                                               self._label.getFont (),
                                               self._label.getFontSize ());

                let csize = man:.getRenderSize (self._text [i .. i + 1],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                let toChar = (cast!f32 (size.x) - cast!f32 (csize.x) / 2.f) / self._absoluteSize.x;
                if pos.x <= toChar + baseX {
                    return i;
                }
            } catch {
                _ => return 0us;
            }
        }

        self._text.len
    }

    /**
     * Reset the selection by putting cursor and selectionCursor at the same position
     * */
    fn resetSelection (mut self) {
        if self._cursor > self._text.len { self._cursor = self._text.len; }
        self._selectionCursor = self._cursor;
        self._hasSelection = false;
    }

    /**
     * Remove every chararcter in the string that is not a number, a point or the minus sign
     * */
    fn keepNumbers (self, txt : [c8])-> [c8] {
        if self._cursor == 0 && txt == "-" {
            if self._text.len != 0 && self._text [0] == '-' {
                return "";
            }

            return txt;
        }

        if txt == "." {
            if let Ok () = self._text.find ('.') {
                return "";
            }

            return txt;
        }

        if txt.all (|x| => x >= '0' && x <= '9') {
            return txt
        }

        ""
    }

    /**
     * Compute the shifting of the label to make the cursor always visible on screen
     * */
    fn computeShifting (mut self, update : bool = true) {
        let dmut man = self._manager:.getFontManager ();
        {
            let size = man:.getRenderSize (self._text [0 .. self._cursor],
                                           self._label.getFont (),
                                           self._label.getFontSize ());

            let relSize = (cast!f32 (size.x)) / self._absoluteSize.x;
            let relBorder = (self._borderPixWidth / self._absoluteSize.x);
            let limitRight = 1.f - relBorder - (self._cursorSize / self._absoluteSize.x);

            if self._textShiftLeft > relSize - relBorder {
                self._textShiftLeft = relSize - relBorder;
            } else if self._textShiftLeft < relSize - limitRight {
                self._textShiftLeft = relSize - limitRight;
            }

            if update {
                self:.onUpdateSize (self._absolutePosition, self._absoluteSize, self._depth);
            }
        } catch {
            err => {
                log::error #("InputText", "Failed to recompute input size", err);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSABLE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            self._label:.dispose ();

            if let Ok (dmut b) = alias self._backShape {
                self._backShape = none;
                b:.dispose ();
            }

            if let Ok (dmut b) = alias self._selectionShape {
                self._selectionShape = none;
                b:.dispose ();
            }

            if let Ok (dmut b) = alias self._cursorShape {
                self._cursorShape = none;
                b:.dispose ();
            }
        }
    }



}
