in input;


use balder::core::{shader::_, application::_};
use balder::core::_;
use balder::math::_;

use balder::interface::_;
use balder::interface::widget::text::label;

use balder::utils::_;

use std::{io, conv, char, time::_, concurrency::signal};
use std::algorithm::_;

use ::sdl2::{clipboard, keyboard, keycode};
use ::sdl2::mouse;

pub class InputText over Widget {

    // The content of the input text
    let mut _text : [c16] = "";

    // The label to draw the text
    let dmut _label : &Label;

    prot {

        // The maximul length of the text content
        let _maxLen : usize;

        // True iif only numbers are allowed in the input
        let _onlyNumbers : bool;

    }

    prot { // text cursor

        // The cursor position (where to insert text, etc)
        let mut _cursor : usize = 0us;

        // The position of the start (or end) of the selection @warning: might be > self._cursor
        let mut _selectionCursor : usize = 0us;

        // The current shifting of the display, to always keep the cursor in the drawing window
        let mut _clipCursor : f32 = 0.f;

        // If true selectionCursor means something
        let mut _hasSelection : bool = false;

        // True iif we are updating the selection
        let mut _inSelection : bool = false;

        // True iif focused by manager for text input
        let mut _isFocused : bool = false;

        // The tick time to make cursor blinking
        let mut _cursorTimer = millis (0);

        // True iif the cursor is blinking off
        let mut _cursorOff = false;

        // The speed of the timer blinking
        let mut _cursorTimerSpeed : Duration = millis (700);

        // True iif to make the cursor move at given speed
        let mut _selectionTimer = millis (0);

        // If -1 or 1, then the cursor moves left or right during onTick
        let mut _selectionSpeed = 0;

        // The speed of the sliding of selection when going over the input text
        let mut _selectionTimerSpeed : Duration = millis (50);

    }

    prot { // Size

        // the relative size of the cursor
        let mut _cursorSize : f32 = 0.f;

        // The size of the selection (applicable iif self._hasSelection)
        let mut _selectionSize : f32 = 0.f;

        // The relative position of the cursor
        let mut _cursorPos : vec2 = vec2 ();

        // The relative position of the start of the selection
        let mut _selectionPos : vec2 = vec2 ();

        // The shift on the left of the label due to text oversize
        let mut _textShiftLeft : f32 = 0.f;

    }

    prot { // Shapes
        let dmut _cursorShape : (&Shape)? = none;
        let dmut _selectionShape : (&Shape)? = none;

        let mut _cursorColor : vec4 = vec4 ();
    }

    prot { // signals

        let dmut _validateText = Signal!{[c8]} ();

    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a new input text
     * */
    pub self (dmut manager : &WidgetManager,
              name : [c8],
              onlyNumbers : bool = false,
              maxLen : usize = 255us)

        with super (alias manager, name, WidgetKeys::INPUT_TEXT)

        , _label = copy Label (alias manager, "")
        , _onlyNumbers = onlyNumbers
        , _maxLen = maxLen
    {}

    prot over onApplyStyle (mut self) {
        if let Ok (inner) = self.getStyle ().subItems ["label"] {
            self._label:.setStyle (inner);
        }

        let mut selectionColor = vec4 ();
        if let Ok (inner) = self._currentStyle.subItems ["selection"] {
            selectionColor = inner.getColor (WidgetShapeKind::SELECTION);
        } else {
            selectionColor = self._currentStyle.getColor (WidgetShapeKind::SELECTION);
        }

        if let Ok (inner) = self._currentStyle.subItems ["cursor"] {
            self._cursorColor = inner.getColor (WidgetShapeKind::TEXT);
        } else {
            self._cursorColor = self._currentStyle.getColor (WidgetShapeKind::TEXT);
        }

        if let Ok (dmut s) = alias self._selectionShape {
            s:.setColor (selectionColor);
            s:.commit (false);
        }

        if let Ok (dmut s) = alias self._cursorShape {
            s:.setColor (self._cursorColor);
            s:.commit (false);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          ATTACH/DETACH          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onAttach (mut self) {
        self._attached = true;
        self:.registerShape (WidgetShapeKind::BACKGROUND);
        self:.registerShape (WidgetShapeKind::BORDER);

        let dmut shDr = self._manager:.getApplication ():.getShapeDrawer ();
        {
            let dmut cursorShape = shDr:.registerQuad (position-> vec2 (),
                                                       size-> vec2 (),
                                                       self._cursorColor);
            self._cursorShape = (alias cursorShape)?;

            let dmut selectionSh = shDr:.registerQuad (position-> vec2 (),
                                                       size-> vec2 (),
                                                       vec4 ());

            self._selectionShape = (alias selectionSh)?;
        } catch {
            err => {
                log::error #("TextInput", "Failed to construct shapes : ", err);
            }
        }

        self._label:.onAttach ();
    }

    pub over onDetach (mut self) {
        self._attached = false;
        self._label:.onDetach ();
        self:.dispose ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DRAW SIZES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    over onUpdateSize (mut self) {
        self:.computeCursorSize (self._absolutePosition, self._absoluteSize);
        self:.computeSelectionSize (self._absolutePosition, self._absoluteSize);

        if self._isFocused {
            let wpos = makeVec2 (self._absolutePosition.x - self._textShiftLeft * self._absoluteSize.x,
                                 self._absolutePosition.y);

            self._label:.forceAlign (true);
            self._label:.setSize (wpos, self._absoluteSize, self._depth + 1);
        } else {
            self._label:.forceAlign (false);
            self._label:.setSize (self._absolutePosition, self._absoluteSize, self._depth + 1);
        }

        self:.onUpdateScissors ();
    } catch {
        err => {
            log::error #("InputText", "failed to compute sizes", err);
        }
    }

    over onUpdateScissors (mut self) {
        if let Ok (dmut s) = alias self._cursorShape {
            s:.setScissors (self._scissorPos, self._scissorSize);
            s:.commit (false);
        }

        let x = max (self._absolutePosition.x, self._scissorPos.x);
        let endx = min (self._absolutePosition.x + self._absoluteSize.x,
                        self._scissorPos.x + self._scissorSize.x);

        let y = max (self._absolutePosition.y, self._scissorPos.y);
        let endy = min (self._absolutePosition.y + self._absoluteSize.y, self._scissorPos.y + self._scissorSize.y);

        self._label:.setScissors (makeVec2 (x, y),
                                  makeVec2 (endx - x, endy - y));

        if let Ok (dmut s) = alias self._selectionShape {
            s:.setScissors (makeVec2 (x, y),
                                  makeVec2 (endx - x, endy - y));
            s:.commit (false);
        }

    }

    /**
     * Compute the size and the position of the cursor
     * */
    fn computeCursorSize (mut self, pos : vec2, size : vec2)
        throws BalderError
    {
        if let Ok (dmut b) = alias self._cursorShape {
            if self._isFocused {
                let dmut man = self._manager:.getFontManager ();
                let csize = man:.getRenderSize (self._text [0 .. self._cursor],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                self._cursorSize = cast!f32 (man:.getRenderSize ("l",
                                                                 self._label.getFont (),
                                                                 self._label.getFontSize ()).x) / 3.f;

                let cpos = makeVec2 (cast!f32 (csize.x + 2) - (self._textShiftLeft * size.x), size.y * 0.15f);
                let s = makeVec2 (self._cursorSize, size.y * 0.7);

                b:.setPosition (cpos + pos);
                b:.setSize (s);
                if !self._cursorOff {
                    b:.setLevel (self.getDepth (WidgetShapeKind::TEXT));
                }

                b:.commit (false);
                b:.show ();
            } else {
                b:.hide ();
            }
        }
    }

    /**
     * Compute the size and the position of the selection quad
     * */
    fn computeSelectionSize (mut self, pos : vec2, size : vec2)
        throws BalderError
    {
        if let Ok (dmut b) = alias self._selectionShape {
            if self._hasSelection {
                let dmut man = self._manager:.getFontManager ();
                let selStart = min (self._cursor, self._selectionCursor);
                let selEnd = max (self._cursor, self._selectionCursor);

                let csize = man:.getRenderSize (self._text [0 .. selStart],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                let cpos = makeVec2 (cast!f32 (csize.x + 2) - (self._textShiftLeft * size.x), size.y * 0.15f);

                let mut selectionSize = cast!f32 (man:.getRenderSize (self._text [selStart .. selEnd],
                                                                      self._label.getFont (),
                                                                      self._label.getFontSize ()).x);

                let s = makeVec2 (selectionSize, size.y * 0.7);
                let sciPos = makeVec2 (pos.x, pos.y);
                let sciSize = makeVec2 (size.x, size.y);

                b:.setPosition (cpos + pos);
                b:.setSize (s);
                b:.setLevel (self.getDepth (WidgetShapeKind::SELECTION));
                b:.setScissors (sciPos, sciSize);
                b:.commit (false);
                b:.show ();
            } else {
                b:.hide ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          TICK EVENTS          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onTick (mut self, delta : Duration) {
        if self._isFocused {
            self._cursorTimer += delta;
            self._cursorTimer = millis (self._cursorTimer.allMillis % (self._cursorTimerSpeed.allMillis * 2));

            if let Ok (dmut b) = alias self._cursorShape {
                if self._cursorTimer > self._cursorTimerSpeed && !self._cursorOff {
                    self._cursorOff = true;
                    b:.setColor (makeVec4 (self._cursorColor.xyz, 0.f));
                    b:.setLevel (0);
                    b:.commit (false);
                } else if self._cursorTimer < self._cursorTimerSpeed && self._cursorOff {
                    self._cursorOff = false;
                    b:.setColor (self._cursorColor);
                    b:.setLevel (self.getDepth (WidgetShapeKind::TEXT));
                    b:.commit (false);
                }
            }

            if self._selectionSpeed != 0 {
                self._selectionTimer += delta;

                if self._selectionTimer >= self._selectionTimerSpeed {
                    if self._selectionSpeed > 0 { self:.onTextSelectionForwardMove (); }
                    else { self:.onTextSelectionBackwardMove (); }
                    self._selectionTimer = millis (0);
                }

                self._hasSelection = (self._selectionCursor != self._cursor);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onClick (mut self, pos : vec2, button : u8)-> dmut &Widget {
        if button == SDL_BUTTON_LEFT {
            self._hasSelection = false;
            if self._isFocused {
                self._inSelection = true;
                self._cursor = self:.mousePositionToCursor (pos);
                self._selectionCursor = self._cursor;
            }

            self:.resetSelection ();
            self:.computeShifting ();
        }

        alias self
    }

    pub over onDoubleClick (mut self, pos : vec2)-> dmut &Widget {
        return self:.onClick (pos, SDL_BUTTON_LEFT);
    }

    pub over onHover (mut self, _ : vec2)-> dmut &Widget {
        if !self._isFocused {
            self:.setHover (true);
        }

        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_IBEAM);
        return alias self;
    }

    pub over onLoseHoverFocus (mut self) {
        if !self._isFocused {
            self:.setHover (false);
        }

        self._manager:.getCursorManager ():.setCursor (SDL_SystemCursor::SDL_SYSTEM_CURSOR_ARROW);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          SLIDING EVENTS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onSliding (mut self, pos : vec2, _ : vec2, _ : u8) {
        if self._inSelection {
            if pos.x < 0.f {
                self._cursor = self:.mousePositionToCursor (makeVec2 (0.f, pos.y));
                if self._selectionSpeed != -1 {
                    self._selectionTimer = millis (0);
                    self._selectionSpeed = -1;
                }
                self._hasSelection = (self._selectionCursor != self._cursor);
            } else if pos.x > 1.f {
                self._cursor = self:.mousePositionToCursor (makeVec2 (1.f, pos.y));
                if self._selectionSpeed != 1 {
                    self._selectionTimer = millis (0);
                    self._selectionSpeed = 1;
                }
                self._hasSelection = (self._selectionCursor != self._cursor);
            } else {
                self._selectionSpeed = 0;
                self._cursor = self:.mousePositionToCursor (pos);
                self._hasSelection = (self._selectionCursor != self._cursor);
            }
        }

        self:.resetCursorTimer ();
        self:.computeShifting ();
    }

    pub over onSlidingEnd (mut self, _ : u8) {
        self._selectionSpeed = 0;
        self._selectionTimer = millis (0);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT INPUT EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn eraseSelection (mut self) {
        self._text = self._text [0 .. min (self._cursor, self._selectionCursor)] ~ self._text [max (self._cursor, self._selectionCursor) .. $];
        self._cursor = min (self._cursor, self._selectionCursor);
        self:.resetSelection ();
        self:.setText (self._text);
    }

    pub fn onTextInput (mut self, text : [c8]) {
        let txt = if self._onlyNumbers { self.keepNumbers (text) } else { text };
        if self._hasSelection { // erase selected text
            self:.eraseSelection ();
        }

        if text.len + self._text.len <= self._maxLen {
            let c16Txt = txt.to![c16] ();
            self._text = self._text [0 .. self._cursor] ~ c16Txt ~ self._text [self._cursor .. $];
            self._cursor += c16Txt.len;

            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextErase (mut self, _ : KeyInfo) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor > 0 {
            self._text = self._text [0 .. self._cursor - 1] ~ self._text [self._cursor .. $];
            self._cursor -= 1;

            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextForwardErase (mut self, _ : KeyInfo) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor < self._text.len {
            self._text = self._text [0 .. self._cursor] ~ self._text [self._cursor + 1 .. $];
            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextEraseWord (mut self) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor > 0 {
            let mut start = self._cursor;
            while self._cursor > 0 {
                if self._cursor != self._text.len && self._cursor >= 1 {
                    if self._text [self._cursor].isPunctuation () != self._text [self._cursor - 1].isPunctuation () {
                        break;
                    }
                }

                self._cursor -= 1;
            }

            self._text = self._text [0 .. self._cursor] ~ self._text [start .. $];
            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    pub fn onTextForwardEraseWord (mut self) {
        if self._hasSelection {
            self:.eraseSelection ();
        } else if self._cursor < self._text.len {
            let mut end = self._cursor;
            while end < self._text.len {
                if end != self._text.len - 1 {
                    if self._text [end].isPunctuation () != self._text [end + 1].isPunctuation () {
                        end += 1;
                        break;
                    }
                }

                end += 1;
            }

            self._text = self._text [0 .. self._cursor] ~ self._text [end .. $];
            self:.setText (self._text);
        }

        self:.resetCursorTimer ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT FOCUS EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over onGainFocus (mut self) {
        self:.startInputText ();

        self._isFocused = true;
        self:.setHover (false);

        self._inSelection = false;
        self._cursor = 0;
        self:.resetCursorTimer ();

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub over onLoseFocus (mut self) {
        self:.stopInputText ();

        self._isFocused = false;
        self._inSelection = false;
        self._textShiftLeft = 0.f;
        self._cursor = 0;

        self:.resetSelection ();
        self:.computeSize ();

        self._validateText.emit (self._text.to!{[c8]} ());
    }

    pub fn onTextValidate (mut self, _ : KeyInfo) {
        self._manager:.setFocus (none);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXT MOVE EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub fn onTextForwardMove (mut self, _ : KeyInfo) {
        if self._cursor != self._text.len {
            self._cursor += 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub fn onTextBackwardMove (mut self, _ : KeyInfo) {
        if self._cursor != 0 {
            self._cursor -= 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub fn onTextForwardMoveWord (mut self) {
        if (self._cursor == self._text.len) return;

        while self._cursor < self._text.len {
            if self._cursor != self._text.len - 1 {
                if self._text [self._cursor].isPunctuation () != self._text [self._cursor + 1].isPunctuation () {
                    self._cursor += 1;
                    break;
                }
            }

            self._cursor += 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }

    pub fn onTextBackwardMoveWord (mut self) {
        if (self._cursor == 0) return;

        self._cursor -= 1;
        while self._cursor > 0 {
            if self._cursor != self._text.len && self._cursor >= 1 {
                if self._text [self._cursor].isPunctuation () != self._text [self._cursor - 1].isPunctuation () {
                    break;
                }
            }

            self._cursor -= 1;
        }

        self:.resetSelection ();
        self:.computeShifting ();
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT SELECTION EVENTS          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the selection cursor is moved forward (SHIFT + right)
     * */
    pub fn onTextSelectionForwardMove (mut self) {
        if !self._hasSelection {
            self._selectionCursor = self._cursor;
            self._hasSelection = true;
        }

        if self._cursor != self._text.len {
            self._cursor += 1;
        }

        self:.resetCursorTimer ();
        self:.computeShifting ();
    }

    /**
     * Method called when the selection cursor is moved forward (SHIFT + left)
     * */
    pub fn onTextSelectionBackwardMove (mut self) {
        if !self._hasSelection {
            self._selectionCursor = self._cursor;
            self._hasSelection = true;
        }

        if self._cursor != 0us {
            self._cursor -= 1;
        }

        self:.resetCursorTimer ();
        self:.computeShifting ();
    }

    /**
     * Method called when the Ctrl+a is inputed (or selection all is triggered by hand)
     * */
    pub fn onTextSelectionAll (mut self) {
        if self._text.len != 0 {
            self._hasSelection = true;
            self._cursor = self._text.len;
            self._selectionCursor = 0;

            self:.resetCursorTimer ();
            self:.computeShifting ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT COPY/PASTE EVENTS          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Paste text from clipboard to input
     * */
    pub fn onTextPaste (mut self) {
        if SDL_HasClipboardText () {
            let dmut t = SDL_GetClipboardText ();
            if t != null {
                self:.onTextInput (unsafe { t.fromStringZ () });
                etc::c::memory::free (cast!{*void} (t));
            } else {
                log::error #("InputText", "SDL clipboard lied!");
            }
        }
    }

    /**
     * Copy text from input to clipboard
     * */
    pub fn onTextCopy (mut self) {
        if self._hasSelection {
            let selStart = min (self._cursor, self._selectionCursor);
            let selEnd = max (self._cursor, self._selectionCursor);

            let select = self._text [selStart .. selEnd].to!{[c8]} ();
            SDL_SetClipboardText (select.toStringZ ());
        }

        self:.resetCursorTimer ();
    }

    /**
     * Cut text from input to clipboard
     * */
    pub fn onTextCut (mut self) {
        if self._hasSelection {
            let selStart = min (self._cursor, self._selectionCursor);
            let selEnd = max (self._cursor, self._selectionCursor);

            let select = self._text [selStart .. selEnd].to!{[c8]} ();
            SDL_SetClipboardText (select.toStringZ ());

            self._text = self._text [0 .. selStart] ~ self._text [selEnd .. $];

            self:.setText (self._text);
            self:.resetSelection ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the text in the input text
     * @params:
     *    - text: the text to set
     *    - moveCursor: true iif the cursor is put at the end of the text
     * */
    pub fn setText (mut self, text : [c8], moveCursor : bool = false) {
        self:.setText (text.to!{[c16]} (), moveCursor-> moveCursor);
    }

    /**
     * Change the text in the input text
     * @params:
     *    - text: the text to set
     *    - moveCursor: true iif the cursor is put at the end of the text
     * */
    fn setText (mut self, text : [c16], moveCursor : bool = false) {
        self._text = text;
        if (moveCursor) { self._cursor = self._text.len; }

        self:.resetSelection ();
        self:.computeShifting (update-> false);

        self._label:.setText (text)?;
        self:.computeSize ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over isFocusableLeftClick (self)-> bool {
        true
    }

    pub over getMaxDepth (self)-> u32 {
        self._label.getMaxDepth ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SIGNALS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect to the event emitted when the text input is validated
     * */
    pub fn connectTextValidate (mut self, f : dg ([c8])-> void) {
        self._validateText:.connect (f);
    }

    /**
     * Disconnect the event emitted when the text input is validated
     * */
    pub fn disconnectTextValidate (mut self, f : dg ([c8])-> void) {
        self._validateText:.disconnect (f);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMPUTATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Convert an absolute mouse position into a text cursor index
     * */
    fn mousePositionToCursor (mut self, pos : vec2)-> usize {
        if self._text.len == 0 {
            return 0us;
        }

        let dmut man = self._manager:.getFontManager ();
        let baseX = -self._textShiftLeft;
        for i in 0 .. self._text.len {
            {
                let size = man:.getRenderSize (self._text [0 .. i + 1],
                                               self._label.getFont (),
                                               self._label.getFontSize ());

                let csize = man:.getRenderSize (self._text [i .. i + 1],
                                                self._label.getFont (),
                                                self._label.getFontSize ());

                let toChar = (cast!f32 (size.x) - cast!f32 (csize.x) / 2.f) / self._absoluteSize.x;
                if pos.x <= toChar + baseX {
                    return i;
                }
            } catch {
                _ => return 0us;
            }
        }

        self._text.len
    }

    /**
     * Reset the selection by putting cursor and selectionCursor at the same position
     * */
    fn resetSelection (mut self) {
        if self._cursor > self._text.len { self._cursor = self._text.len; }
        self._selectionCursor = self._cursor;
        self._hasSelection = false;

        self:.resetCursorTimer ();
    }

    /**
     * Reset the cursor timer to force it to be displayed
     * */
    fn resetCursorTimer (mut self) {
        self._cursorTimer = millis (0);
        self._cursorOff = true;
    }

    /**
     * Remove every chararcter in the string that is not a number, a point or the minus sign
     * */
    fn keepNumbers (self, txt : [c8])-> [c8] {
        if self._cursor == 0 && txt == "-" {
            if self._text.len != 0 && self._text [0] == '-' {
                return "";
            }

            return txt;
        }

        if txt == "." {
            if let Ok () = self._text.find ('.') {
                return "";
            }

            return txt;
        }

        if txt.all (|x| => x >= '0' && x <= '9') {
            return txt
        }

        ""
    }

    /**
     * Compute the shifting of the label to make the cursor always visible on screen
     * */
    fn computeShifting (mut self, update : bool = true) {
        let dmut man = self._manager:.getFontManager ();
        {
            let size = man:.getRenderSize (self._text [0 .. self._cursor],
                                           self._label.getFont (),
                                           self._label.getFontSize ());

            let fullSize = man:.getRenderSize (self._text,
                                               self._label.getFont (),
                                               self._label.getFontSize ());

            let relSize = (cast!f32 (size.x)) / self._absoluteSize.x;
            let relFullSize = (cast!f32 (fullSize.x)) / self._absoluteSize.x;
            let limitRight = 1.f - (self._cursorSize * 2.f / self._absoluteSize.x);

            if relSize < 1.f && !self._hasSelection {
                self._textShiftLeft = 0.f;
            } else if self._textShiftLeft > relSize {
                self._textShiftLeft = relSize;
            } else if self._textShiftLeft < relSize - limitRight {
                self._textShiftLeft = relSize - limitRight;
            }


            if !self._inSelection {
                // Move the text to the right if there is not enough text after the cursor to fill the remaining part of the input text
                if relFullSize > limitRight && relFullSize - relSize < 1.f {
                    self._textShiftLeft = relFullSize - limitRight;
                }
            }

            if update {
                self:.computeSize ();
            }
        } catch {
            err => {
                log::error #("InputText", "Failed to recompute input size", err);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSABLE          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {
        pub over dispose (mut self) {
            if self._isFocused {
                self:.onLoseFocus ();
            }

            self._label:.dispose ();
            self:.disposeShapes ();

            if let Ok (dmut b) = alias self._selectionShape {
                self._selectionShape = none;
                b:.dispose ();
            }

            if let Ok (dmut b) = alias self._cursorShape {
                self._cursorShape = none;
                b:.dispose ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT MODE TOGGLE STATE          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Change the input mode
     * */
    fn startInputText (mut self) {
        let dmut man = self._manager:.getInputManager ();

        man:.startInputText ();
        man:.connectTextInput (&self:.onTextInput);

        man:.connect (KeyInfo (SDLK_BACKSPACE, KeyEvent::DOWN), &self:.onTextErase);
        man:.connect (KeyInfo (SDLK_DELETE, KeyEvent::DOWN), &self:.onTextForwardErase);
        man:.connect (KeyInfo (SDLK_BACKSPACE, KeyEvent::REPEAT), &self:.onTextErase);
        man:.connect (KeyInfo (SDLK_DELETE, KeyEvent::REPEAT), &self:.onTextForwardErase);

        man:.connect (copy [SDLK_LCTRL, SDLK_BACKSPACE], &self:.onTextEraseWord);
        man:.connect (copy [SDLK_LCTRL, SDLK_DELETE], &self:.onTextForwardEraseWord);

        man:.connect (KeyInfo (SDLK_LEFT, KeyEvent::DOWN), &self:.onTextBackwardMove);
        man:.connect (KeyInfo (SDLK_RIGHT, KeyEvent::DOWN), &self:.onTextForwardMove);
        man:.connect (KeyInfo (SDLK_LEFT, KeyEvent::REPEAT), &self:.onTextBackwardMove);
        man:.connect (KeyInfo (SDLK_RIGHT, KeyEvent::REPEAT), &self:.onTextForwardMove);

        man:.connect (KeyInfo (SDLK_RETURN, KeyEvent::RELEASE), &self:.onTextValidate);
        man:.connect (KeyInfo (SDLK_ESCAPE, KeyEvent::RELEASE), &self:.onTextValidate);

        man:.connect (copy [SDLK_LCTRL, SDLK_RIGHT], &self:.onTextForwardMoveWord);
        man:.connect (copy [SDLK_LCTRL, SDLK_LEFT], &self:.onTextBackwardMoveWord);

        man:.connect (copy [SDLK_LCTRL, SDLK_v], &self:.onTextPaste);
        man:.connect (copy [SDLK_LCTRL, SDLK_c], &self:.onTextCopy);
        man:.connect (copy [SDLK_LCTRL, SDLK_x], &self:.onTextCut);
        man:.connect (copy [SDLK_LCTRL, SDLK_a], &self:.onTextSelectionAll);

        man:.connect (copy [SDLK_LSHIFT, SDLK_RIGHT], &self:.onTextSelectionForwardMove);
        man:.connect (copy [SDLK_LSHIFT, SDLK_LEFT], &self:.onTextSelectionBackwardMove);
    }

    /**
     * Change the input mode
     * */
    fn stopInputText (mut self) {
        let dmut man = self._manager:.getInputManager ();

        man:.startInputText ();
        man:.disconnectTextInput (&self:.onTextInput);

        man:.disconnect (KeyInfo (SDLK_BACKSPACE, KeyEvent::DOWN), &self:.onTextErase);
        man:.disconnect (KeyInfo (SDLK_DELETE, KeyEvent::DOWN), &self:.onTextForwardErase);
        man:.disconnect (KeyInfo (SDLK_BACKSPACE, KeyEvent::REPEAT), &self:.onTextErase);
        man:.disconnect (KeyInfo (SDLK_DELETE, KeyEvent::REPEAT), &self:.onTextForwardErase);

        man:.disconnect (copy [SDLK_LCTRL, SDLK_BACKSPACE], &self:.onTextEraseWord);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_DELETE], &self:.onTextForwardEraseWord);

        man:.disconnect (KeyInfo (SDLK_LEFT, KeyEvent::DOWN), &self:.onTextBackwardMove);
        man:.disconnect (KeyInfo (SDLK_RIGHT, KeyEvent::DOWN), &self:.onTextForwardMove);
        man:.disconnect (KeyInfo (SDLK_LEFT, KeyEvent::REPEAT), &self:.onTextBackwardMove);
        man:.disconnect (KeyInfo (SDLK_RIGHT, KeyEvent::REPEAT), &self:.onTextForwardMove);

        man:.disconnect (KeyInfo (SDLK_RETURN, KeyEvent::RELEASE), &self:.onTextValidate);
        man:.disconnect (KeyInfo (SDLK_ESCAPE, KeyEvent::RELEASE), &self:.onTextValidate);

        man:.disconnect (copy [SDLK_LCTRL, SDLK_RIGHT], &self:.onTextForwardMoveWord);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_LEFT], &self:.onTextBackwardMoveWord);

        man:.disconnect (copy [SDLK_LCTRL, SDLK_v], &self:.onTextPaste);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_c], &self:.onTextCopy);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_x], &self:.onTextCut);
        man:.disconnect (copy [SDLK_LCTRL, SDLK_a], &self:.onTextSelectionAll);

        man:.disconnect (copy [SDLK_LSHIFT, SDLK_RIGHT], &self:.onTextSelectionForwardMove);
        man:.disconnect (copy [SDLK_LSHIFT, SDLK_LEFT], &self:.onTextSelectionBackwardMove);
    }




}
