in texture;

use balder::math::_;
use balder::core::{_,
                   shader::_,
                   shader::buffers::_,
                   application::_,
                   driver::_,
                   config::_};

use balder::utils::_;
use balder::interface::drawer;

use std::io;


/**
 * A 2D textured shape
 * */
@final
pub class TextureShape over Shape {

    let dmut _texture : (&RefCount!{&Texture2D})?;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          CTOR/DTOR          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self (uid : usize,
              dmut drawer : &ShapeDrawer,
              dmut shader : &Shader,
              vbo : &VertexBufferObject,
              ibo : &IndexBufferObject,
              dmut texture : &RefCount!{&Texture2D})

        with super (uid,
                    alias drawer,
                    vbo,
                    ibo,
                    ubo-> copy UniformBufferObject (alias shader:.getDevice (), 80),
                    descSet-> shader:.allocateDescriptorSet ())

        , _texture = (alias texture)?

        throws BalderError
    {
        if let Ok (dmut ds) = alias self._descSet {
            if let Ok (dmut t) = alias texture:.get ()? {
                ds:.setTexture (TextureKind::ALBEDO, t);
            }
        }
    }


    impl Disposable {
        pub over dispose (mut self) {
            self.__super__:.dispose ();

            if let Ok (dmut txt) = alias self._texture {
                txt:.dispose ();
                self._texture = none;
            }
        }
    }


}
