in list;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ======================================          LIST          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */


/**
 * A list of shape sorted by level
 * */
@final
pub class ShapeList {

    let dmut _head : (&ShapeNode)? = none;

    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */
    
    /**
     * Insert the shape into the list
     * */
    pub fn insert (mut self, dmut shape : &Shape) {
        let dmut nNode = copy ShapeNode (alias shape);
        
        let dmut last : (&ShapeNode)? = none; 
        let dmut current = alias self._head;        
        while let Ok (dmut h) = alias current {
            if h.shape.level > shape.level {
                if let Ok (dmut l) = alias last {
                    l.next = (alias nNode)?;
                    nNode.next = alias current;
                } else {
                    self._head = (alias nNode)?;
                    nNode.next = alias current;
                }

                return;
            }

            last = alias current;
            current = alias h.next;
        }


        if let Ok (dmut l) = alias last {
            l.next = (alias nNode)?;
        } else {
            self._head = (alias nNode)?;
        }
    }
    
    /**
     * Remove a shape from the list of shapes
     * */
    pub fn remove (mut self, uid : usize)-> dmut (&Shape)? {        
        let dmut last : (&ShapeNode)? = none;
        let dmut current = alias self._head;        
        while let Ok (dmut h) = alias current {
            if h.shape.uid == uid {
                if let Ok (dmut l) = alias last {
                    l.next = alias h.next;                    
                } else {
                    self._head = alias h.next;                    
                }

                return (alias h.shape)?;
            }

            last = alias current;
            current = alias h.next;
        }

        return none;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          ITERATION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */    

    pub fn begin (mut self)-> mut MShapeNodeIterator {
        return MShapeNodeIterator (alias self._head);
    }

    pub fn begin (self)-> CShapeNodeIterator {
        return CShapeNodeIterator (self._head);
    }

    pub fn end (self)-> CShapeNodeIterator {
        return CShapeNodeIterator (none);
    }
    
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ======================================          NODE          ======================================
 * ====================================================================================================
 * ====================================================================================================
 */

@final
class ShapeNode {    
    pub let dmut shape : &Shape;
    pub let dmut next : (&ShapeNode)? = none;

    pub self (dmut shape : &Shape)
        with shape = alias shape        
    {}    
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          ITERATOR          ====================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Mutable version of the list iterator
 * */
record MShapeNodeIterator {
    pub let dmut _current : (&ShapeNode)?;

    pub self (dmut current : (&ShapeNode)?)
        with _current = alias current
    {}
        
    pub fn get {0, 1} (mut self)-> dmut &Shape {
        if let Ok (dmut s) = alias self._current {
            return alias s.shape;
        }
        
        panic;
    }
    
    impl Iterable {
        pub over next (mut self) {
            if let Ok (dmut c) = alias self._current {
                self._current = alias c.next;
            }
        }
    }

    pub fn opEquals (self, o : CShapeNodeIterator)-> bool {
        if let Ok (c) = self._current {
            if let Ok (d) = o._current {
                return c.shape.uid == d.shape.uid;
            }

            return false;
        }

        return !o._current.hasValue;
    }

    pub fn opEquals (self, o : MShapeNodeIterator)-> bool {
        if let Ok (c) = self._current {
            if let Ok (d) = o._current {
                return c.shape.uid == d.shape.uid;
            }

            return false;
        }

        return !o._current.hasValue;
    }
}


/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          CONST ITERATOR          =================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Mutable version of the list iterator
 * */
record CShapeNodeIterator {
    pub let mut _current : (&ShapeNode)?;

    pub self (current : (&ShapeNode)?)
        with _current = current
    {}

    pub fn get {0, 1} (self)-> &Shape {
        if let Ok (s) = self._current {
            return s.shape;
        }
        
        panic;
    }
    
    impl Iterable {
        pub over next (mut self) {
            if let Ok (c) = self._current {
                self._current = c.next;
            }
        }
    }

    pub fn opEquals (self, o : CShapeNodeIterator)-> bool {
        if let Ok (c) = self._current {
            if let Ok (d) = o._current {
                return c.shape.uid == d.shape.uid;
            }

            return false;
        }

        return !o._current.hasValue;
    }
}
