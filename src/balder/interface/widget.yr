in widget;

use balder::core::{shader::_, application::_};
use balder::core::_;
use balder::math::_;

use balder::interface::_;

pub mod ::layout;
pub mod ::box;
pub mod ::label;

@abstract
pub class Widget {

    // The name of the widget
    pub let name : [c8];

    // The manager of the widget
    let dmut _manager : &WidgetManager;

    // The size in pixel of the widget
    let mut _absoluteSize : vec2 = vec2 ();

    // The position of the widget in pixel
    let mut _absolutePosition : vec2 = vec2 ();

    // The depth of the widget (for the rendering order)
    let mut _depth : u32 = 0;

    prot self (dmut manager : &WidgetManager, name : [c8])
        with _manager = alias manager
        , name = name
    {}

    __dtor (mut self) {
        self:.dispose ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GET/SETS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the depth of the widget tree
     * */
    pub fn getMaxDepth (self)-> u32 {
        self._depth
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SIZES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the size of the widget
     * */
    pub fn updateSizes (mut self, pos : vec2, viewport : vec2, depth : u32) {
        self._absoluteSize = viewport;
        self._absolutePosition = pos;
        self._depth = depth;

        self:.onUpdateSizes (pos, viewport, depth);
    }

    /**
     * Method called when the size of the object is outdated and was reactualized
     * */
    prot fn onUpdateSizes (mut self, pos : vec2, viewport : vec2, depth : u32) {
        pos;
        viewport;
        depth;
    }

    /**
     * Hide the widget
     * */
    pub fn hide (mut self) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          MOUSE EVENTS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the object is on the widget
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onHover (mut self, _ : vec2) {}


    /**
     * Method called when the cursor left the widget
     */
    pub fn onHoverEnd (mut self) {}


    /**
     * Method called when the cursor is on the widget and left clicked
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickLeft (mut self, _ : vec2) {}


    /**
     * Method called when the cursor is on the widget and the left clicked is released
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickLeftEnd (mut self, _ : vec2) {}

    /**
     * Method called when the cursor is on the widget and the left clicked is pressed two times in less than __DOUBLE_CLICK_SENSIBILITY__
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onDoubleClick (mut self, _ : vec2) {}

    /**
     * Method called when the cursor is on the widget and left clicked
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickRight (mut self, _ : vec2) {}


    /**
     * Method called when the cursor is on the widget and the left clicked is released
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickRightEnd (mut self, _ : vec2) {}

    /**
     * Method called when the cursor is on the widget and left clicked
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickMiddle (mut self, _ : vec2) {}


    /**
     * Method called when the cursor is on the widget and the left clicked is released
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickMiddleEnd (mut self, _ : vec2) {}


    /**
     * Method called when the mouse cursor is on the widget and the scroll event occurs
     * @params:
     *   - pos: the position of the cursor
     *   - amoutX: the amount of scrolling along the x axis
     *   - amountY: the amount of scrolling along the y axis
     * @returns: true, if the widget did scroll
     */
    pub fn onScroll (mut self, _ : vec2, _ : i32, _ : i32)-> bool {
        false
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT INPUT EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the widget is text focus, and an input event occured
     * @params:
     *   - text: the text that was inputed
     */
    pub fn onTextInput (mut self, _ : [c8]) {}

    /**
     * Method called when the widget is text focus, and the erase event occur
     */
    pub fn onTextErase (mut self) {}

    /**
     * Method called when the widget is text focus, and the forward erase event occur (suppr key)
     */
    pub fn onTextForwardErase (mut self) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          TEXT FOCUS EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the object lose the text focus
     */
    pub fn onLoseTextFocus (mut self) {}


    /**
     * Method called when the widget is text focus, and the validation event occurs (ENTER)
     */
    pub fn onTextValidate (mut self) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          TEXT MOVE EVENTS          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the widget is text focus, and the forward move event occured (right key)
     */
    pub fn onTextForwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the backward move event (left key)
     */
    pub fn onTextBackwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the forward move word event occured (LCTRL + right key)
     */
    pub fn onTextForwardMoveWord (mut self) {}

    /**
     * Method called when the widget is text focus, and the backward move event (LCTRL + left key)
     */
    pub fn onTextBackwardMoveWord (mut self) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT SELECTION EVENTS          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the widget is text focus, and the forward selection move event occured (SHIFT + right key)
     */
    pub fn onTextSelectionForwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the backward selection move event (SHIFT + left key)
     */
    pub fn onTextSelectionBackwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the all selection event occured (LCTRL + a)
     */
    pub fn onTextSelectionAll (mut self) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =============================          TEXT COPY/PASTE EVENTS          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the widget is text focus, and the copy event occured (LCTRL + c)
     */
    pub fn onTextCopy (mut self) {}

    /**
     * Method called when the widget is text focus, and the paste event occured (LCTRL + v)
     */
    pub fn onTextPaste (mut self) {}

    /**
     * Method called when the widget is text focus, and the paste event occured (LCTRL + x)
     */
    pub fn onTextCut (mut self) {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SLIDINGS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Method called when the widget is slide focus, and the slide event occurs
     * @params:
     *    - pos: the mouse position (relative to the widget (@info: can be negative, or > 1.f, if the cursor is not on the widget))
     *    - amout: the size of the slide since the last position of the mouse (relative to the size of the widget)
     */
    pub fn onSliding (mut self, pos : vec2, amout : vec2) {
        pos;
        amout;
    }

    /**
     * Method called when the widget is losing its sliding focus
     * @params:
     *   - pos: the mouse position (relative to the widget (@info: can be negative, or > 1.f, if the cursor is not on the widget))
     */
    pub fn onSlidingEnd (mut self, pos : vec2) {
        pos;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Disposable {

        /**
         * Every widget is disposable
         * Even if this ancestor class Widget doesn't need to be disposed, some child class may
         */
        pub over dispose (mut self) {}
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          PROTECTED          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Clamp a size from a relative size to another relative size, but with garantee of pixel maximum and minimum size
     */
    @final
    fn clampSize (self, clamp : WidgetSize, viewport : f32) -> f32 {
        let size = std::algorithm::comparison::max (0.f, clamp.relative);

        let px_x =  cast!u32 (size * viewport);
        let size_x = if (px_x < clamp.minPix) {
            clamp.minPix
        } else if (px_x > clamp.maxPix) {
            clamp.maxPix
        } else { px_x }

        cast!f32 (size_x) / viewport
    }

    /**
     * Clamp a size from a relative size to another relative size, but with garantee of pixel maximum and minimum size
     */
    @final
    fn clampSize (self, x : f32, clamp : WidgetSize, viewport : f32) -> f32 {
        let size = std::algorithm::comparison::max (0.f, x);

        let px_x = cast!u32 (size * viewport);
        let size_x = if (px_x < clamp.minPix) {
            clamp.minPix
        } else if (px_x > clamp.maxPix) {
            clamp.maxPix
        } else { px_x }

        cast!f32 (size_x) / viewport
    }

    /**
     * @returns: true if the point is in the square
     * */
    fn isInSquare (self, pos : vec2, start : vec2, end : vec2)-> bool {
        return (pos.x >= start.x
                && pos.x <= end.x
                && pos.y >= start.y
                && pos.y <= end.y);
    }

}
