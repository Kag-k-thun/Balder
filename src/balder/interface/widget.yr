in widget;

use balder::core::application::_;
use balder::core::_;
use balder::math::_;

use balder::interface::_;

pub mod ::layout;
pub mod ::box;

@abstract
pub class Widget {

    // The name of the widget
    pub let name : [c8];

    // The manager of the widget
    let dmut _manager : &WidgetManager;

    // The size in pixel of the widget
    let mut _absoluteSize : vec2 = vec2 ();

    // The position of the widget in pixel
    let mut _absolutePosition : vec2 = vec2 ();

    // The shape associated to the widget in the drawer
    let dmut _shape : (&Shape)? = none;

    prot self (dmut manager : &WidgetManager, name : [c8])
        with _manager = alias manager
        , name = name
    {}

    __dtor (mut self) {
        self:.dispose ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SIZES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the size of the widget
     * */
    pub fn updateSizes (mut self, pos : vec2, viewport : vec2, depth : i32) {
        self._absoluteSize = viewport;
        self._absolutePosition = pos;

        self:.onUpdateSizes (pos, viewport, depth);

        if let Ok (dmut sh) = alias self._shape {
            sh:.setPosition (self._absolutePosition); //makeVec2 (0.f, 0.f));
            sh:.setSize (self._absoluteSize);
            sh:.setLevel (depth);
        }
    }

    /**
     * Method called when the size of the object is outdated and was reactualized
     * */
    pub fn onUpdateSizes (mut self, pos : vec2, viewport : vec2, depth : i32) {
        pos;
        viewport;
        depth;
    }

    /***
     * =======================================================================================
     * =======================================================================================
     * =========================           MOUSE EVENTS      =================================
     * =======================================================================================
     * =======================================================================================
     */

    /**
     * Method called when the object is on the widget
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onHover (mut self, _ : vec2) {}


    /**
     * Method called when the cursor left the widget
     */
    pub fn onHoverEnd (mut self) {}


    /**
     * Method called when the cursor is on the widget and left clicked
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickLeft (mut self, _ : vec2) {}


    /**
     * Method called when the cursor is on the widget and the left clicked is released
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickLeftEnd (mut self, _ : vec2) {}

    /**
     * Method called when the cursor is on the widget and the left clicked is pressed two times in less than __DOUBLE_CLICK_SENSIBILITY__
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onDoubleClick (mut self, _ : vec2) {}

    /**
     * Method called when the cursor is on the widget and left clicked
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickRight (mut self, _ : vec2) {}


    /**
     * Method called when the cursor is on the widget and the left clicked is released
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickRightEnd (mut self, _ : vec2) {}

    /**
     * Method called when the cursor is on the widget and left clicked
     * @params:
     *  - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickMiddle (mut self, _ : vec2) {}


    /**
     * Method called when the cursor is on the widget and the left clicked is released
     * @params:
     *   - pos: the position of the cursor relative to the widget between 0 and 1
     */
    pub fn onClickMiddleEnd (mut self, _ : vec2) {}


    /**
     * Method called when the mouse cursor is on the widget and the scroll event occurs
     * @params:
     *   - pos: the position of the cursor
     *   - amoutX: the amount of scrolling along the x axis
     *   - amountY: the amount of scrolling along the y axis
     * @returns: true, if the widget did scroll
     */
    pub fn onScroll (mut self, _ : vec2, _ : i32, _ : i32)-> bool {
        false
    }


    /***
     * ============================================================================================
     * ============================================================================================
     * =========================           TEXT INPUT EVENTS      =================================
     * ============================================================================================
     * ============================================================================================
     */

    /**
     * Method called when the widget is text focus, and an input event occured
     * @params:
     *   - text: the text that was inputed
     */
    pub fn onTextInput (mut self, _ : [c8]) {}

    /**
     * Method called when the widget is text focus, and the erase event occur
     */
    pub fn onTextErase (mut self) {}

    /**
     * Method called when the widget is text focus, and the forward erase event occur (suppr key)
     */
    pub fn onTextForwardErase (mut self) {}


    /***
     * ============================================================================================
     * ============================================================================================
     * =========================           TEXT FOCUS EVENTS      =================================
     * ============================================================================================
     * ============================================================================================
     */

    /**
     * Method called when the object lose the text focus
     */
    pub fn onLoseTextFocus (mut self) {}


    /**
     * Method called when the widget is text focus, and the validation event occurs (ENTER)
     */
    pub fn onTextValidate (mut self) {}


    /***
     * ============================================================================================
     * ============================================================================================
     * =========================           TEXT MOVE EVENTS       =================================
     * ============================================================================================
     * ============================================================================================
     */

    /**
     * Method called when the widget is text focus, and the forward move event occured (right key)
     */
    pub fn onTextForwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the backward move event (left key)
     */
    pub fn onTextBackwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the forward move word event occured (LCTRL + right key)
     */
    pub fn onTextForwardMoveWord (mut self) {}

    /**
     * Method called when the widget is text focus, and the backward move event (LCTRL + left key)
     */
    pub fn onTextBackwardMoveWord (mut self) {}


    /***
     * =================================================================================================
     * =================================================================================================
     * =========================           TEXT SELECTION EVENTS       =================================
     * =================================================================================================
     * =================================================================================================
     */

    /**
     * Method called when the widget is text focus, and the forward selection move event occured (SHIFT + right key)
     */
    pub fn onTextSelectionForwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the backward selection move event (SHIFT + left key)
     */
    pub fn onTextSelectionBackwardMove (mut self) {}

    /**
     * Method called when the widget is text focus, and the all selection event occured (LCTRL + a)
     */
    pub fn onTextSelectionAll (mut self) {}


    /***
     * ==================================================================================================
     * ==================================================================================================
     * =========================           TEXT COPY/PASTE EVENTS       =================================
     * ==================================================================================================
     * ==================================================================================================
     */

    /**
     * Method called when the widget is text focus, and the copy event occured (LCTRL + c)
     */
    pub fn onTextCopy (mut self) {}

    /**
     * Method called when the widget is text focus, and the paste event occured (LCTRL + v)
     */
    pub fn onTextPaste (mut self) {}

    /**
     * Method called when the widget is text focus, and the paste event occured (LCTRL + x)
     */
    pub fn onTextCut (mut self) {}


    /***
     * ===========================================================================================
     * ===========================================================================================
     * =========================           SLIDING  EVENTS       =================================
     * ===========================================================================================
     * ===========================================================================================
     */

    /**
     * Method called when the widget is slide focus, and the slide event occurs
     * @params:
     *    - pos: the mouse position (relative to the widget (@info: can be negative, or > 1.f, if the cursor is not on the widget))
     *    - amout: the size of the slide since the last position of the mouse (relative to the size of the widget)
     */
    pub fn onSliding (mut self, pos : vec2, amout : vec2) {
        pos;
        amout;
    }

    /**
     * Method called when the widget is losing its sliding focus
     * @params:
     *   - pos: the mouse position (relative to the widget (@info: can be negative, or > 1.f, if the cursor is not on the widget))
     */
    pub fn onSlidingEnd (mut self, pos : vec2) {
        pos;
    }


    /***
     * ================================================================================
     * ================================================================================
     * =========================        MISCELLANEOUS        ==========================
     * ================================================================================
     * ================================================================================
     */

    impl Disposable {

        /**
         * Every widget is disposable
         * Even if this ancestor class Widget doesn't need to be disposed, some child class may
         */
        pub over dispose (mut self) {
            if let Ok (dmut sh) = alias self._shape {
                sh:.dispose ();
                self._shape = none;
            }
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          PROTECTED          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Clamp a size from a relative size to another relative size, but with garantee of pixel maximum and minimum size
     */
    @final
    fn clampSize (self, size : vec2, clamp : WidgetSize, viewport : vec2) -> vec2 {
        let px_x = cast!u32 (size.x * viewport.x);
        let px_y = cast!u32 (size.y * viewport.y);

        let size_x = if (px_x < clamp.minWidth) {
            clamp.minWidth
        } else if (px_x > clamp.maxWidth) {
            clamp.maxWidth
        } else { px_x }

        let size_y = if (px_y < clamp.minHeight) {
            clamp.minHeight
        } else if (px_y > clamp.maxHeight) {
            clamp.maxHeight
        } else { px_y }

        makeVec2 (cast!f32 (size_x) / viewport.x, cast!f32 (size_y) / viewport.y)
    }

}
