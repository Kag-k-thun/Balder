in loader;


use balder::core::{_, application::_};
use balder::interface::_;
use balder::math::_;

use std::{config,
          config::_,
          conv,
          conv::_};

use balder::interface::widget::{_,
                                text::_,
                                layout::_};

pub enum
| BOX             = "box"
| FLOATING_LAYOUT = "floating_layout"
| GRID_LAYOUT     = "grid_layout"
| INPUT           = "input"
| LABEL           = "label"
| LINEAR_LAYOUT   = "linear_layout"
 -> WidgetKinds;


pub record WidgetLoader {

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          CTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          LOADING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a root configuration and returns the loaded widget
     * */
    pub fn load (self, dmut manager : &WidgetManager, cfg : &Config)-> dmut &Widget
        throws BalderError
    {
        if let Ok (style) = cfg ["style"]? {
            manager:.loadStyle (style.to![c8] ());
        }

        if let Ok (d : &Dict) = cfg ["gui"]? {
            let dmut root = copy FloatingLayout (alias manager, "",
                                                 defaultStyle-> "",
                                                 hoverStyle-> "");
            for name, k in d[] {
                let dmut w = self.load (alias manager, name, k);
                root:.insertChild (alias w);
            }

            return alias root;
        }

        throw copy BalderError ("Expected 'gui' configuration");
    } catch {
        b : &BalderError => { throw b; }
        err => {
            throw copy BalderError ("Failed to load widget configuration : " ~ std::conv::to!{[c8]} (err));
        }
    }

    /**
     * Load the configuration of a widget
     * */
    fn load (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws BalderError
    {
        if let Ok (Str (value-> v)) = cfg ["kind"]? match v {
            WidgetKinds::BOX => { return self.loadBox (alias manager, name, cfg); }
            WidgetKinds::FLOATING_LAYOUT => { return self.loadFloating (alias manager, name, cfg); }
            WidgetKinds::GRID_LAYOUT => { return self.loadGrid (alias manager, name, cfg); }
            WidgetKinds::LABEL => { return self.loadLabel (alias manager, name, cfg); }
            WidgetKinds::LINEAR_LAYOUT => { return self.loadLinear (alias manager, name, cfg); }
            WidgetKinds::INPUT => { return self.loadInput (alias manager, name, cfg); }
            _ => {
                throw copy BalderError ("Unknwon widget class : " ~ v);
            }
        } else {
            throw copy BalderError ("Undefined widget class");
        }
    } catch {
        err => {
            throw copy BalderError ("While loading widget  " ~ name ~ " : " ~ std::conv::to!{[c8]} (err));
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          INPUT          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of an input text
     * */
    fn loadInput (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws BalderError, CastFailure
    {
        let xalign = if let Ok (xalign) = cfg ["xalign"]? match xalign.to!{[c8]} () {
            "left" => { XAlign::LEFT }
            "right" => { XAlign::RIGHT }
            "center" => { XAlign::CENTER }
            z => { throw copy BalderError ("Unknwon xalign : " ~ z); }
        } else { XAlign::LEFT };

        let yalign = if let Ok (yalign) = cfg ["yalign"]? match yalign.to!{[c8]} () {
            "top" => { YAlign::TOP }
            "bottom" => { YAlign::BOTTOM }
            "center" => { YAlign::CENTER }
            z => { throw copy BalderError ("Unknwon yalign : " ~ z); }
        } else { YAlign::CENTER };

        let onlyN = if let Ok (b) = cfg ["only-numbers"]? { b.to!{bool} () } else { false };
        let maxLen = if let Ok (b) = cfg ["max-length"]? { cast!usize (b.to!{u32} ()) } else { 255us };
        let defaultStyle = if let Ok (b) = cfg ["style"]? { b.to!{[c8]} () } else { __INPUT_TEXT_DEFAULT_STYLE__ };
        let hoverStyle = if let Ok (b) = cfg ["hover-style"]? { b.to!{[c8]} () } else { __INPUT_TEXT_HOVER_STYLE__ };
        let focusStyle = if let Ok (b) = cfg ["focus-style"]? { b.to!{[c8]} () } else { __INPUT_TEXT_FOCUS_STYLE__ };

        copy InputText (alias manager,
                        name,
                        xalign-> xalign,
                        yalign-> yalign,
                        onlyNumbers-> onlyN,
                        maxLen-> maxLen,
                        defaultStyle-> defaultStyle,
                        hoverStyle-> hoverStyle,
                        focusStyle-> focusStyle)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          LABEL          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of an label
     * */
    fn loadLabel (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws BalderError, CastFailure
    {
        let xalign = if let Ok (xalign) = cfg ["xalign"]? match xalign.to!{[c8]} () {
            "left" => { XAlign::LEFT }
            "right" => { XAlign::RIGHT }
            "center" => { XAlign::CENTER }
            z => { throw copy BalderError ("Unknwon xalign : " ~ z); }
        } else { XAlign::LEFT };

        let yalign = if let Ok (yalign) = cfg ["yalign"]? match yalign.to!{[c8]} () {
            "top" => { YAlign::TOP }
            "bottom" => { YAlign::BOTTOM }
            "center" => { YAlign::CENTER }
            z => { throw copy BalderError ("Unknwon yalign : " ~ z); }
        } else { YAlign::CENTER };

        let defaultStyle = if let Ok (b) = cfg ["style"]? { b.to!{[c8]} () } else { __LABEL_DEFAULT_STYLE__ };
        let defaultText = if let Ok (b) = cfg ["text"]? { b.to!{[c8]} () } else { "" };

        let dmut res = copy Label (alias manager,
                                   name,
                                   xalign-> xalign,
                                   yalign-> yalign,
                                   style-> defaultStyle);

        if defaultText != "" {
            res:.setText (defaultText);
        }

        alias res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          BOX          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of an label
     * */
    fn loadBox (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws CastFailure
    {
        let defaultStyle = if let Ok (b) = cfg ["style"]? { b.to!{[c8]} () } else { __BOX_DEFAULT_STYLE__ };
        let hoverStyle = if let Ok (b) = cfg ["hover-style"]? { b.to!{[c8]} () } else { __BOX_HOVER_STYLE__ };

        copy Box (alias manager,
                  name,
                  defaultStyle-> defaultStyle,
                  hoverStyle-> hoverStyle)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          LINEAR-LAYOUT          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of a linear layout
     * */
    fn loadLinear (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws BalderError, CastFailure
    {
        let defaultStyle = if let Ok (b) = cfg ["style"]? { b.to!{[c8]} () } else { __LINEAR_DEFAULT_STYLE__ };
        let hoverStyle = if let Ok (b) = cfg ["hover-style"]? { b.to!{[c8]} () } else { __LINEAR_HOVER_STYLE__ };
        let vertical = if let Ok (b) = cfg ["vertical"]? { b.to!{bool} () } else { true };
        let scrollable = if let Ok (b) = cfg ["scrollable"]? { b.to!{bool} () } else { false };

        let dmut result = copy LinearLayout (alias manager, name,
                                             defaultStyle-> defaultStyle,
                                             hoverStyle-> hoverStyle,
                                             vertical-> vertical);

        if let Ok (d : &Dict) = cfg ["childs"]? {
            for inner, c in d[] {
                let dmut w = self.load (alias manager, inner, c);

                let size = if let Ok (size) = c ["size"]? {
                    WidgetSize (size)
                } else { WidgetSize (relative-> 1.f) };

                let level = if let Ok (v) = c ["level"]? {
                    v.to!{u32} ()
                } else { 0 };

                result:.insertChild (size, alias w, level-> level);
            }
        }

        if scrollable {
            let scrollDefaultStyle = if let Ok (b) = cfg ["scrollbar-style"]? { b.to!{[c8]} () } else { __SCROLLBAR_DEFAULT_STYLE__ };
            let scrollHoverStyle = if let Ok (b) = cfg ["scrollbar-hover-style"]? { b.to!{[c8]} () } else { __SCROLLBAR_HOVER_STYLE__ };
            let scrollFocusStyle = if let Ok (b) = cfg ["scrollbar-hover-style"]? { b.to!{[c8]} () } else { __SCROLLBAR_FOCUS_STYLE__ };

            let scrollSize = if let Ok (b) = cfg ["scrollbar-size"]? { WidgetSize (b) } else { WidgetSize (pix-> 10) };
            let scrollSpeed = if let Ok (b) = cfg ["scrollbar-speed"]? { b.to!{f32} () } else { 2.f };

            let dmut scrll = copy ScrollLayout (alias manager, name, alias result,
                                                scrollSize-> scrollSize,
                                                scrollSpeed-> scrollSpeed,
                                                defaultStyle-> scrollDefaultStyle,
                                                hoverStyle-> scrollHoverStyle,
                                                focusStyle-> scrollFocusStyle);
            return alias scrll;
        }

        alias result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          GRID-LAYOUT          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of a linear layout
     * */
    fn loadGrid (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws BalderError, CastFailure
    {
        let defaultStyle = if let Ok (b) = cfg ["style"]? { b.to!{[c8]} () } else { __GRID_DEFAULT_STYLE__ };
        let hoverStyle = if let Ok (b) = cfg ["hover-style"]? { b.to!{[c8]} () } else { __GRID_HOVER_STYLE__ };
        let cols = if let Ok (b) = cfg ["columns"]? { b.to!{u32} () } else { 1u32 };
        let rows = if let Ok (b) = cfg ["rows"]? { b.to!{u32} () } else { 1u32 };

        let dmut result = copy GridLayout (alias manager, name,
                                           defaultStyle-> defaultStyle,
                                           hoverStyle-> hoverStyle,
                                           columns-> cols,
                                           rows-> rows);

        if let Ok (d : &Dict) = cfg ["childs"]? {
            for inner, c in d[] {
                let dmut w = self.load (alias manager, inner, c);

                let col = if let Ok (v) = c ["col"]? {
                    v.to!{u32} ()
                } else { throw copy BalderError ("Expected column for " ~ inner); };

                let row = if let Ok (v) = c ["row"]? {
                    v.to!{u32} ()
                } else { throw copy BalderError ("Expected row for " ~ inner); };

                result:.insertChild (col, row, alias w);
            }
        }

        alias result
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          FLOATING-LAYOUT          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of a linear layout
     * */
    fn loadFloating (self, dmut manager : &WidgetManager, name : [c8], cfg : &Config)-> dmut &Widget
        throws BalderError, CastFailure
    {
        let defaultStyle = if let Ok (b) = cfg ["style"]? { b.to!{[c8]} () } else { __BOX_DEFAULT_STYLE__ };
        let hoverStyle = if let Ok (b) = cfg ["hover-style"]? { b.to!{[c8]} () } else { __BOX_HOVER_STYLE__ };

        let dmut result = copy FloatingLayout (alias manager, name,
                                               defaultStyle-> defaultStyle,
                                               hoverStyle-> hoverStyle);

        if let Ok (d : &Dict) = cfg ["childs"]? {
            for inner, c in d[] {
                let dmut w = self.load (alias manager, inner, c);

                let x = if let Ok (v) = c ["x"]? {
                    WidgetSize (v)
                } else { WidgetSize (relative-> 0.f) };

                let y = if let Ok (v) = c ["y"]? {
                    WidgetSize (v)
                } else { WidgetSize (relative-> 0.f) };


                let wi = if let Ok (v) = c ["width"]? {
                    WidgetSize (v)
                } else { WidgetSize (relative-> 1.f) };

                let he = if let Ok (v) = c ["height"]? {
                    WidgetSize (v)
                } else { WidgetSize (relative-> 1.f) };

                let level = if let Ok (v) = c ["level"]? {
                    v.to!{u32} ()
                } else { 0 };

                let withEvents = if let Ok (b) = c ["with-events"]? { b.to!{bool} () } else { true };
                result:.insertChild (alias w, x-> x, y-> y, width-> wi, height-> he, withEvents-> withEvents, level-> level);
            }
        }

        alias result
    }

}
